{"meta":{"title":"小青年博客","subtitle":"看似寻常最奇崛，成如容易却艰辛。","description":"小青年,小青年博客,前端开发,android,技术宅,菜鸟教程,一个神奇的博客。","author":"赵梦欢","url":"https://zhaomenghuan.github.io"},"pages":[{"title":"","date":"2017-05-03T12:37:26.791Z","updated":"2017-05-03T12:37:26.656Z","comments":false,"path":"categories/index.html","permalink":"https://zhaomenghuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-03T12:37:01.146Z","updated":"2017-05-03T12:37:01.003Z","comments":false,"path":"tags/index.html","permalink":"https://zhaomenghuan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IOS 学习笔记之基于 UITabBarController 的主流 APP 底部导航栏实现","slug":"IOS-学习笔记之基于-UITabBarController-的主流-APP-底部导航栏实现","date":"2017-07-30T16:00:00.000Z","updated":"2017-07-31T14:11:41.704Z","comments":true,"path":"2017/07/31/IOS-学习笔记之基于-UITabBarController-的主流-APP-底部导航栏实现/","link":"","permalink":"https://zhaomenghuan.github.io/2017/07/31/IOS-学习笔记之基于-UITabBarController-的主流-APP-底部导航栏实现/","excerpt":"","text":"前言当app中有多个控制器的时候，就需要对这些控制器进行管理，用一个控制器去管理其他多个控制器；如图所示： IOS UIView 提供了两个特殊的控制器，UINavigationController和UITabBarController去管理其它控制器。 本文以下面的一个简单例子加以说明基本用法： UIWindow 和 UIViewController 的基本内容新建一个 Single View Application 工程，在iOS应用中，每个程序得main函数中都调用了UIApplicationMain函数。12345678#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 先来看看UIApplicationMain函数的原型：123456UIKIT_EXTERN int UIApplicationMain( int argc, char *argv[], NSString * __nullable principalClassName, NSString * __nullable delegateClassName); 前面的argc和argv是ISO C标准的main函数的参数，直接传递给UIApplicationMain进行相关处理，principalClassName是应用程序类的名字，该类必须继承自UIApplication类，而delegateClassName是应用程序类的代理类。如果主要nib文件（在info.plist文件中指定，key是NSMainNibFile）存在，就会在nib文件对象里寻找Application对象和连接它的delegate。此函数会根据principalClassName创建UIApplication对象，然后根据delegateClassName创建一个delegate对象，并将UIApplication对象中的delegate属性设置为delegate对象，接着会建立应用的main runloop，进行事件的处理，首先调用application:didFinishLaunchingWithOptions。程序正常退出时才返回（如今iOS支持后台运行，系统在必要时会强行杀死不用的进程，一般这个函数不等返回进程就终止了）。12345678910111213141516// 程序启动完成调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 创建Window self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // 设置Window的背景颜色 self.window.backgroundColor = [UIColor whiteColor]; // 设置根控制器 ViewController *vc = [[ViewController alloc] init]; self.window.rootViewController = vc; // 设置并显示主窗口 [self.window makeKeyAndVisible]; return YES;&#125; UIWindow是一种特殊的UIView，通常在一个应用中只会有一个UIWindow。在ios程序启动完成后，建立的第一个视图控件就是UIWindow，接着创建一个控制器的View，最后将控制器的View添加到UIWindow上，于是控制器的View就是显示到屏幕上了。一个ios程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说没有UIWindow就看不到任何UI界面。 控制器的创建：1UIViewController *vc = [UIViewController alloc] init]; 可以用isViewLoaded方法判断一个UIViewController的view是否已经被加载；控制器的view加载完毕就会调用viewDidLoad方法。 将view添加到UIWindow： 直接将view添加到UIWindow中，并不理会view对应的控制器。 1- (void)addSubView:(UIView *)view; 通过设置根控制器，自动将rootViewController的view添加到UIWindow中，负责管理rootViewController的生命周期。 1@property(nonatomic,retain) UIViewController *rootViewController; 获取 RootViewController： 第一种方法：12UIWindow *window = [UIApplication sharedApplication].keyWindow;UIViewController *rootViewController = window.rootViewController; 第二种方法：12AppDelegate *appdelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;UIViewController *rootViewController = appdelegate.window.rootViewController; UINavigationController 和 UITabBarController 的基本内容UINavigationController以栈的形式保存子控制器，使用push方法能将某个控制器压入栈，使用pop方法可以移除栈顶控制器。 打开 ViewController 的方式：1- (void)pushViewController:(UIViewController*)viewController animated:(BOOL)animated; 三种移除 ViewController 的方式：123456将栈顶的控制器移除- (UIViewController*)popViewControllerAnimated:(BOOL)animated;回到指定的子控制器- (NSArray*)popToViewController:(UIViewController*)viewController animated:(BOOL)animated;回到根控制器（栈底控制器）- (NSArray*)popToRootViewControllerAnimated:(BOOL)animated; 初始化UINavigationController： 方法一：1UINavigationController *nv = [[UINavigationController alloc] init]; 方法二：1UINavigationController *nv = [[UINavigationController alloc] initWithRootViewController:rootViewController]; UITabBarController和UINavigationController类似,UITabBarController也可以轻松地管理多个控制器,轻松完成控制器之间的切换,典型的例子就是QQ、微信等应⽤。但是UITabBarController其管理的视图一直存在,而UINavigationController在pop后会销毁掉，释放内存。UITabBarController通常作为整个程序的rootViewController，而且不能添加到别的container viewController中。 UITabBarController的使用步骤： 初始化UITabBarController 创建子控制器（viewcontroller） 把子控制器添加到UITabBarController 设置UIWindow的rootViewController为UITabBarController 将子控制器添加到UITabBarController： 方法一：添加单个子控制器1- (void)addChildViewController:(UIViewController*)childController; 方法二：添加多个子控制器1view.viewControllers = NSArray *childController; UITabBarController中嵌套UINavigationController： UINavigationController中嵌套UITabBarController： 项目实战将UITabBarController的逻辑提取到一个独立的ViewController中。可以新建一个继承于UITabBarController的ViewController。 AppDelegate.m：12345678910111213141516// 程序启动完成调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 创建Window self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // 设置Window的背景颜色 self.window.backgroundColor = [UIColor whiteColor]; // 设置根控制器 ViewController *vc = [[ViewController alloc] init]; self.window.rootViewController = vc; // 设置并显示主窗口 [self.window makeKeyAndVisible]; return YES;&#125; ViewController.h:123@interface ViewController : UITabBarController@end ViewController.m:1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; // 创建子控制器 HomeViewController *homeVC=[[HomeViewController alloc] init]; [self setTabBarItem:homeVC.tabBarItem title:@&quot;首页&quot; titleSize:13.0 titleFontName:@&quot;HeiTi SC&quot; selectedImage:@&quot;i_tab_home_selected&quot; selectedTitleColor:[UIColor redColor] normalImage:@&quot;i_tab_home_normal&quot; normalTitleColor:[UIColor grayColor]]; BlogViewController *blogVC=[[BlogViewController alloc] init]; [self setTabBarItem:blogVC.tabBarItem title:@&quot;博文&quot; titleSize:13.0 titleFontName:@&quot;HeiTi SC&quot; selectedImage:@&quot;i_tab_blog_selected&quot; selectedTitleColor:[UIColor redColor] normalImage:@&quot;i_tab_blog_normal&quot; normalTitleColor:[UIColor grayColor]]; UINavigationController *homeNV = [[UINavigationController alloc] initWithRootViewController:homeVC]; UINavigationController *blogNV = [[UINavigationController alloc] initWithRootViewController:blogVC]; // 把子控制器添加到UITabBarController self.viewControllers = @[homeNV, blogNV];&#125; 我们通常需要对tabBarItem进行设置，可以封装一个setTabBarItem方法，只需要进行简单的配置即可。12345678910111213141516171819- (void)setTabBarItem:(UITabBarItem *)tabbarItem title:(NSString *)title titleSize:(CGFloat)size titleFontName:(NSString *)fontName selectedImage:(NSString *)selectedImage selectedTitleColor:(UIColor *)selectColor normalImage:(NSString *)unselectedImage normalTitleColor:(UIColor *)unselectColor&#123; //设置图片 tabbarItem = [tabbarItem initWithTitle:title image:[[UIImage imageNamed:unselectedImage]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal] selectedImage:[[UIImage imageNamed:selectedImage]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]]; // S未选中字体颜色 [[UITabBarItem appearance] setTitleTextAttributes:@&#123;NSForegroundColorAttributeName:unselectColor,NSFontAttributeName:[UIFont fontWithName:fontName size:size]&#125; forState:UIControlStateNormal]; // 选中字体颜色 [[UITabBarItem appearance] setTitleTextAttributes:@&#123;NSForegroundColorAttributeName:selectColor,NSFontAttributeName:[UIFont fontWithName:fontName size:size]&#125; forState:UIControlStateSelected];&#125; 然后对每个子ViewController进行自定义即可，如BlogViewController.h可以这样写：12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *helloBtn = [[UIButton alloc] initWithFrame:CGRectMake(100, 100, SCREEN_WIDTH - 200, 50)]; helloBtn.backgroundColor = [UIColor redColor]; [helloBtn setTitle:@&quot;hello world&quot; forState:UIControlStateNormal]; [helloBtn addTarget:self action:@selector(showToast) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:helloBtn];&#125;- (void)showToast&#123; // 打开新ViewController BlogDetailViewController *blogDetail = [[BlogDetailViewController alloc] init]; blogDetail.hidesBottomBarWhenPushed=YES; [self.navigationController pushViewController:blogDetail animated:YES];&#125; 本文源代码：https://github.com/zhaomenghuan/learn-ios/tree/master/example/UITabBarController 参考iOS －App主流框架UINavigationController &amp;&amp; UITabBarController的简单使用","categories":[{"name":"IOS 开发笔记","slug":"IOS-开发笔记","permalink":"https://zhaomenghuan.github.io/categories/IOS-开发笔记/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"https://zhaomenghuan.github.io/tags/IOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://zhaomenghuan.github.io/tags/Objective-C/"},{"name":"UINavigationController","slug":"UINavigationController","permalink":"https://zhaomenghuan.github.io/tags/UINavigationController/"},{"name":"UItabbarController","slug":"UItabbarController","permalink":"https://zhaomenghuan.github.io/tags/UItabbarController/"}]},{"title":"JavaScript 进阶之深入理解数据双向绑定","slug":"JavaScript-进阶之深入理解数据双向绑定","date":"2017-06-26T16:00:00.000Z","updated":"2017-07-31T14:07:47.055Z","comments":true,"path":"2017/06/27/JavaScript-进阶之深入理解数据双向绑定/","link":"","permalink":"https://zhaomenghuan.github.io/2017/06/27/JavaScript-进阶之深入理解数据双向绑定/","excerpt":"","text":"前言谈起当前前端最热门的 js 框架，必少不了 Vue、React、Angular，对于大多数人来说，我们更多的是在使用框架，对于框架解决痛点背后使用的基本原理往往关注不多，近期在研读 Vue.js 源码，也在写源码解读的系列文章。和多数源码解读的文章不同的是，我会尝试从一个初级前端的角度入手，由浅入深去讲解源码实现思路和基本的语法知识，通过一些基础事例一步步去实现一些小功能。 本场 Chat 是系列 Chat 的开篇，我会首先讲解一下数据双向绑定的基本原理，介绍对比一下三大框架的不同实现方式，同时会一步步完成一个简单的mvvm示例。读源码不是目的，只是一种学习的方式，目的是在读源码的过程中提升自己，学习基本原理，拓展编码的思维方式。 模板引擎实现原理对于页面渲染，一般分为服务器端渲染和浏览器端渲染。一般来说服务器端吐html页面的方式渲染速度更快、更利于SEO，但是浏览器端渲染更利于提高开发效率和减少维护成本，是一种相关舒服的前后端协作模式，后端提供接口，前端做视图和交互逻辑。前端通过Ajax请求数据然后拼接html字符串或者使用js模板引擎、数据驱动的框架如Vue进行页面渲染。 在ES6和Vue这类框架出现以前，前端绑定数据的方式是动态拼接html字符串和js模板引擎。模板引擎起到数据和视图分离的作用，模板对应视图，关注如何展示数据，在模板外头准备的数据， 关注那些数据可以被展示。模板引擎的工作原理可以简单地分成两个步骤：模板解析 / 编译（Parse / Compile）和数据渲染（Render）两部分组成，当今主流的前端模板有三种方式： String-based templating (基于字符串的parse和compile过程) Dom-based templating (基于Dom的link或compile过程) Living templating (基于字符串的parse 和 基于dom的compile过程) String-based templating基于字符串的模板引擎，本质上依然是字符串拼接的形式，只是一般的库做了封装和优化，提供了更多方便的语法简化了我们的工作。基本原理如下： String-based-Template 典型的库： art-template mustache.js doT 之前的一篇文章中我介绍了js模板引擎的实现思路，感兴趣的朋友可以看看这里：JavaScript进阶学习（一）—— 基于正则表达式的简单js模板引擎实现。这篇文章中我们利用正则表达式实现了一个简单的js模板引擎，利用正则匹配查找出模板中{{}}之间的内容，然后替换为模型中的数据，从而实现视图的渲染。 12345678910111213141516171819202122232425262728293031323334var template = function(tpl, data) &#123; var re = /&#123;&#123;(.+?)&#125;&#125;/g, cursor = 0, reExp = /(^( )?(var|if|for|else|switch|case|break|&#123;|&#125;|;))(.*)?/g, code = &apos;var r=[];\\n&apos;; // 解析html function parsehtml(line) &#123; // 单双引号转义，换行符替换为空格,去掉前后的空格 line = line.replace(/(&apos;|&quot;)/g, &apos;\\\\$1&apos;).replace(/\\n/g, &apos; &apos;).replace(/(^\\s+)|(\\s+$)/g,&quot;&quot;); code +=&apos;r.push(&quot;&apos; + line + &apos;&quot;);\\n&apos;; &#125; // 解析js代码 function parsejs(line) &#123; // 去掉前后的空格 line = line.replace(/(^\\s+)|(\\s+$)/g,&quot;&quot;); code += line.match(reExp)? line + &apos;\\n&apos; : &apos;r.push(&apos; + &apos;this.&apos; + line + &apos;);\\n&apos;; &#125; // 编译模板 while((match = re.exec(tpl))!== null) &#123; // 开始标签 &#123;&#123; 前的内容和结束标签 &#125;&#125; 后的内容 parsehtml(tpl.slice(cursor, match.index)); // 开始标签 &#123;&#123; 和 结束标签 &#125;&#125; 之间的内容 parsejs(match[1]); // 每一次匹配完成移动指针 cursor = match.index + match[0].length; &#125; // 最后一次匹配完的内容 parsehtml(tpl.substr(cursor, tpl.length - cursor)); code += &apos;return r.join(&quot;&quot;);&apos;; return new Function(code.replace(/[\\r\\t\\n]/g, &apos;&apos;)).apply(data);&#125; 源代码：http://jsrun.net/yaYKp/embedded/all/light/ 现在ES6支持了模板字符串，我们可以用比较简单的代码就可以实现类似的功能：12345678910111213141516const template = data =&gt; ` &lt;p&gt;name: $&#123;data.name&#125;&lt;/p&gt; &lt;p&gt;age: $&#123;data.profile.age&#125;&lt;/p&gt; &lt;ul&gt; $&#123;data.skills.map(skill =&gt; ` &lt;li&gt;$&#123;skill&#125;&lt;/li&gt; `).join(&apos;&apos;)&#125; &lt;/ul&gt;`const data = &#123; name: &apos;zhaomenghuan&apos;, profile: &#123; age: 24 &#125;, skills: [&apos;html5&apos;, &apos;javascript&apos;, &apos;android&apos;]&#125;document.body.innerHTML = template(data) Dom-based templating{% image http://oo1uw74rb.bkt.clouddn.com/Dom-based-Template.png 'Dom-based-Template' '' %} Dom-based templating 则是从DOM的角度去实现数据的渲染，我们通过遍历DOM树，提取属性与DOM内容，然后将数据写入到DOM树中，从而实现页面渲染。一个简单的例子如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function MVVM(opt) &#123; this.dom = document.querySelector(opt.el); this.data = opt.data || &#123;&#125;; this.renderDom(this.dom);&#125;MVVM.prototype = &#123; init: &#123; sTag: &apos;&#123;&#123;&apos;, eTag: &apos;&#125;&#125;&apos; &#125;, render: function (node) &#123; var self = this; var sTag = self.init.sTag; var eTag = self.init.eTag; var matchs = node.textContent.split(sTag); if (matchs.length)&#123; var ret = &apos;&apos;; for (var i = 0; i &lt; matchs.length; i++) &#123; var match = matchs[i].split(eTag); if (match.length == 1) &#123; ret += matchs[i]; &#125; else &#123; ret = self.data[match[0]]; &#125; node.textContent = ret; &#125; &#125; &#125;, renderDom: function(dom) &#123; var self = this; var attrs = dom.attributes; var nodes = dom.childNodes; Array.prototype.forEach.call(attrs, function(item) &#123; self.render(item); &#125;); Array.prototype.forEach.call(nodes, function(item) &#123; if (item.nodeType === 1) &#123; return self.renderDom(item); &#125; self.render(item); &#125;); &#125;&#125;var app = new MVVM(&#123; el: &apos;#app&apos;, data: &#123; name: &apos;zhaomenghuan&apos;, age: &apos;24&apos;, color: &apos;red&apos; &#125;&#125;); 源代码：http://jsrun.net/faYKp/embedded/all/light/ 页面渲染的函数 renderDom 是直接遍历DOM树，而不是遍历html字符串。遍历DOM树节点属性（attributes）和子节点（childNodes），然后调用渲染函数render。当DOM树子节点的类型是元素时，递归调用遍历DOM树的方法。根据DOM树节点类型一直遍历子节点，直到文本节点。 render的函数作用是提取{{}}中的关键词，然后使用数据模型中的数据进行替换。我们通过textContent获取Node节点的nodeValue，然后使用字符串的split方法对nodeValue进行分割，提取{{}}中的关键词然后替换为数据模型中的值。 DOM 的相关基础 注：元素类型对应NodeType| 元素类型 | NodeType ||:———:|:———:|| 元素 | 1 || 属性 | 2 || 文本 | 3 || 注释 | 8 || 文档 | 9 | childNodes 属性返回包含被选节点的子节点的 NodeList。childNodes包含的不仅仅只有html节点，所有属性，文本、注释等节点都包含在childNodes里面。children只返回元素如input, span, script, div等，不会返回TextNode，注释。 数据双向绑定实现原理js模板引擎可以认为是一个基于MVC的结构，我们通过建立模板作为视图，然后通过引擎函数作为控制器实现数据和视图的绑定，从而实现实现数据在页面渲染，但是当数据模型发生变化时，视图不能自动更新；当视图数据发生变化时，模型数据不能实现更新，这个时候双向数据绑定应运而生。检测视图数据更新实现数据绑定的方法有很多种，目前主要分为三个流派，Angular使用的是脏检查，只在特定的事件下才会触发视图刷新，Vue使用的是Getter/Setter机制，而React则是通过 Virtual DOM 算法检查DOM的变动的刷新机制。 本文限于篇幅和内容在此只探讨一下 Vue.js 数据绑定的实现，对于 angular 和 react 后续再做说明，读者也可以自行阅读源码。Vue 监听数据变化的机制是把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Vue 2.x 对 Virtual DOM 进行了支持，这部分内容后续我们再做探讨。 引子为了更好的理解Vue中视图和数据更新的机制，我们先看一个简单的例子：1234567891011121314151617181920212223var o = &#123; a: 0 &#125;Object.defineProperty(o, &quot;b&quot;, &#123; get: function () &#123; return this.a + 1; &#125;, set: function (value) &#123; this.a = value / 2; &#125;&#125;);console.log(o.a); // &quot;0&quot;console.log(o.b); // &quot;1&quot;// 更新o.ao.a = 5;console.log(o.a); // &quot;5&quot;console.log(o.b); // &quot;6&quot;// 更新o.bo.b = 10; console.log(o.a); // &quot;5&quot;console.log(o.b); // &quot;6&quot; 这里我们可以看出对象o的b属性的值依赖于a属性的值，同时b属性值的变化又可以改变a属性的值，这个过程相关的属性值的变化都会影响其他相关的值进行更新。反过来我们看看如果不使用Object.defineProperty()方法，上述的问题通过直接给对象属性赋值的方法实现，代码如下：12345678910111213141516171819var o = &#123; a: 0&#125; o.b = o.a + 1;console.log(o.a); // &quot;0&quot;console.log(o.b); // &quot;1&quot;// 更新o.ao.a = 5;o.b = o.a + 1;console.log(o.a); // &quot;5&quot;console.log(o.b); // &quot;6&quot;// 更新o.bo.b = 10; o.a = o.b / 2;o.b = o.a + 1;console.log(o.a); // &quot;5&quot;console.log(o.b); // &quot;6&quot; 很显然使用Object.defineProperty()方法可以更方便的监听一个对象的变化。当我们的视图和数据任何一方发生变化的时候，我们希望能够通知对方也更新，这就是所谓的数据双向绑定。既然明白这个道理我们就可以看看Vue源码中相关的处理细节。 Object.defineProperty() Object.defineProperty()方法可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。语法：Object.defineProperty(obj, prop, descriptor) 参数： obj：需要定义属性的对象。 prop：需被定义或修改的属性名。 descriptor：需被定义或修改的属性的描述符。 返回值：返回传入函数的对象，即第一个参数obj 该方法重点是描述，对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值： configurable：当且仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。 enumerable：当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。 数据描述符同时具有以下可选键值： value：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable：当且仅当仅当该属性的writable为 true 时，该属性才能被赋值运算符改变。默认为 false。 存取描述符同时具有以下可选键值： get：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为undefined。 set：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为undefined。 我们可以通过Object.defineProperty()方法精确添加或修改对象的属性。比如，直接赋值创建的属性默认情况是可以枚举的，但是我们可以通过Object.defineProperty()方法设置enumerable属性为false为不可枚举。1234567891011var obj = &#123; a: 0, b: 1&#125;for (var prop in obj) &#123; console.log(`obj.$&#123;prop&#125; = $&#123;obj[prop]&#125;`);&#125;结果：&quot;obj.a = 0&quot;&quot;obj.b = 1&quot; 我们通过Object.defineProperty()修改如下：12345678910111213var obj = &#123; a: 0, b: 1&#125;Object.defineProperty(obj, &apos;b&apos;, &#123; enumerable: false&#125;)for (var prop in obj) &#123; console.log(`obj.$&#123;prop&#125; = $&#123;obj[prop]&#125;`);&#125;结果：&quot;obj.a = 0&quot; 这里需要说明的是我们使用Object.defineProperty()默认情况下是enumerable属性为false，例如：123456789101112var obj = &#123; a: 0&#125;Object.defineProperty(obj, &apos;b&apos;, &#123; value: 1&#125;)for (var prop in obj) &#123; console.log(`obj.$&#123;prop&#125; = $&#123;obj[prop]&#125;`);&#125;结果：&quot;obj.a = 0&quot; 其他描述属性使用方法类似，不做赘述。Vue源码core/util/lang.jsS中定义了这样一个方法： 1234567891011/** * Define a property. */export function def (obj: Object, key: string, val: any, enumerable?: boolean) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, writable: true, configurable: true &#125;)&#125; Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptor() 返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性） 语法：Object.getOwnPropertyDescriptor(obj, prop) 参数： obj：在该对象上查看属性 prop：一个属性名称，该属性的属性描述符将被返回 返回值：如果指定的属性存在于对象上，则返回其属性描述符（property descriptor），否则返回 undefined。可以访问“属性描述符”内容，例如前面的例子： 12345678910111213141516var o = &#123; a: 0 &#125; Object.defineProperty(o, &quot;b&quot;, &#123; get: function () &#123; return this.a + 1; &#125;, set: function (value) &#123; this.a = value / 2; &#125;&#125;); var des = Object.getOwnPropertyDescriptor(o,&apos;b&apos;);console.log(des);console.log(des.get); Vue源码分析本次我们主要分析一下Vue 数据绑定的源码，这里我直接将 Vue.js 1.0.28 版本的代码稍作删减拿过来进行，2.x 的代码基于 flow 静态类型检查器书写的，代码除了编码风格在整体结构上基本没有太大改动，所以依然基于 1.x 进行分析，对于存在差异的部分加以说明。 {% image ./1497679116104.png 'Alt text' '' %} 监听对象变动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 观察者构造函数function Observer (value) &#123; this.value = value this.walk(value)&#125;// 递归调用，为对象绑定getter/setterObserver.prototype.walk = function (obj) &#123; var keys = Object.keys(obj) for (var i = 0, l = keys.length; i &lt; l; i++) &#123; this.convert(keys[i], obj[keys[i]]) &#125;&#125;// 将属性转换为getter/setterObserver.prototype.convert = function (key, val) &#123; defineReactive(this.value, key, val)&#125;// 创建数据观察者实例function observe (value) &#123; // 当值不存在或者不是对象类型时，不需要继续深入监听 if (!value || typeof value !== &apos;object&apos;) &#123; return &#125; return new Observer(value)&#125;// 定义对象属性的getter/setterfunction defineReactive (obj, key, val) &#123; var property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // 保存对象属性预先定义的getter/setter var getter = property &amp;&amp; property.get var setter = property &amp;&amp; property.set var childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; var value = getter ? getter.call(obj) : val console.log(&quot;访问：&quot;+key) return value &#125;, set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val if (newVal === value) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; // 对新值进行监听 childOb = observe(newVal) console.log(&apos;更新：&apos; + key + &apos; = &apos; + newVal) &#125; &#125;)&#125; 定义一个对象作为数据模型，并监听这个对象。123456789101112131415161718let data = &#123; user: &#123; name: &apos;zhaomenghuan&apos;, age: &apos;24&apos; &#125;, address: &#123; city: &apos;beijing&apos; &#125;&#125;observe(data)console.log(data.user.name) // 访问：user // 访问：namedata.user.name = &apos;ZHAO MENGHUAN&apos;// 访问：user// 更新：name = ZHAO MENGHUAN 效果如下：{% image http://oo1uw74rb.bkt.clouddn.com/mvvm-1.gif '' '' %} 监听数组变动上面我们通过Object.defineProperty把对象的属性全部转为 getter/setter 从而实现监听对象的变动，但是对于数组对象无法通过Object.defineProperty实现监听。Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。 1234567891011121314151617181920212223242526272829303132333435const arrayProto = Array.prototypeconst arrayMethods = Object.create(arrayProto)function def(obj, key, val, enumerable) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, writable: true, configurable: true &#125;)&#125;// 数组的变异方法;[ &apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;].forEach(function (method) &#123; // 缓存数组原始方法 var original = arrayProto[method] def(arrayMethods, method, function mutator () &#123; var i = arguments.length var args = new Array(i) while (i--) &#123; args[i] = arguments[i] &#125; console.log(&apos;数组变动&apos;) return original.apply(this, args) &#125;)&#125;) Vue.js 1.x 在Array.prototype原型对象上添加了$set 和 $remove方法，在2.X后移除了，使用全局 API Vue.set 和 Vue.delete代替了，后续我们再分析。 定义一个数组作为数据模型，并对这个数组调用变异的七个方法实现监听。 12345678let skills = [&apos;JavaScript&apos;, &apos;Node.js&apos;, &apos;html5&apos;]// 原型指针指向具有变异方法的数组对象skills.__proto__ = arrayMethodsskills.push(&apos;java&apos;)// 数组变动skills.pop()// 数组变动 效果如下：{% image http://oo1uw74rb.bkt.clouddn.com/mvvm-2.gif '' '' %} 我们将需要监听的数组的原型指针指向我们定义的数组对象，这样我们的数组在调用上面七个数组的变异方法时，能够监听到变动从而实现对数组进行跟踪。 对于__proto__属性，在ES2015中正式被加入到规范中，标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，所以 Vue 是先进行了判断，当__proto__属性存在时将原型指针__proto__指向具有变异方法的数组对象，不存在时直接将具有变异方法挂在需要追踪的对象上。 我们可以在上面Observer观察者构造函数中添加对数组的监听，源码如下：123456789101112131415161718192021222324252627282930313233343536const hasProto = &apos;__proto__&apos; in &#123;&#125;const arrayKeys = Object.getOwnPropertyNames(arrayMethods)// 观察者构造函数function Observer (value) &#123; this.value = value if (Array.isArray(value)) &#123; var augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;// 观察数组的每一项Observer.prototype.observeArray = function (items) &#123; for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125;// 将目标对象/数组的原型指针__proto__指向srcfunction protoAugment (target, src) &#123; target.__proto__ = src&#125;// 将具有变异方法挂在需要追踪的对象上function copyAugment (target, src, keys) &#123; for (var i = 0, l = keys.length; i &lt; l; i++) &#123; var key = keys[i] def(target, key, src[key]) &#125;&#125; 原型链 对于不了解原型链的朋友可以看一下我这里画的一个基本关系图：{% image ./1498395838385.png 'Alt text' '' %} 原型对象是构造函数的prototype属性，是所有实例化对象共享属性和方法的原型对象； 实例化对象通过new构造函数得到，都继承了原型对象的属性和方法； 原型对象中有个隐式的constructor，指向了构造函数本身。 Object.create Object.create 使用指定的原型对象和其属性创建了一个新的对象。12const arrayProto = Array.prototypeconst arrayMethods = Object.create(arrayProto) 这一步是通过 Object.create 创建了一个原型对象为Array.prototype的空对象。然后通过Object.defineProperty方法对这个对象定义几个变异的数组方法。有些新手可能会直接修改 Array.prototype 上的方法，这是很危险的行为，这样在引入的时候会全局影响Array 对象的方法，而使用Object.create实质上是完全了一份拷贝，新生成的arrayMethods对象的原型指针__proto__指向了Array.prototype，修改arrayMethods 对象不会影响Array.prototype。 基于这种原理，我们通常会使用Object.create 实现类式继承。123456789101112131415161718192021// 实现继承var extend = function(Child, Parent) &#123; // 拷贝Parent原型对象 Child.prototype = Object.create(Parent.prototype); // 将Child构造函数赋值给Child的原型对象 Child.prototype.constructor = Child;&#125;// 实例var Parent = function () &#123; this.name = &apos;Parent&apos;;&#125;Parent.prototype.getName = function () &#123; return this.name;&#125;var Child = function () &#123; this.name = &apos;Child&apos;;&#125;extend(Child, Parent);var child = new Child();console.log(child.getName()) 发布-订阅模式在上面一部分我们通过Object.defineProperty把对象的属性全部转为 getter/setter 以及 数组变异方法实现了对数据模型变动的监听，在数据变动的时候，我们通过console.log打印出来提示了，但是对于框架而言，我们相关的逻辑如果直接写在那些地方，自然是不够优雅和灵活的，这个时候就需要引入常用的设计模式去实现，vue.js采用了发布-订阅模式。发布-订阅模式主要是为了达到一种“高内聚、低耦合”的效果。 Vue的Watcher订阅者作为Observer和Compile之间通信的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 观察者对象 */function Watcher(vm, expOrFn, cb) &#123; this.vm = vm this.cb = cb this.depIds = &#123;&#125; if (typeof expOrFn === &apos;function&apos;) &#123; this.getter = expOrFn &#125; else &#123; this.getter = this.parseExpression(expOrFn) &#125; this.value = this.get()&#125;/** * 收集依赖 */Watcher.prototype.get = function () &#123; // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this // 触发getter，将自身添加到dep中 const value = this.getter.call(this.vm, this.vm) // 依赖收集完成，置空，用于下一个Watcher使用 Dep.target = null return value&#125;Watcher.prototype.addDep = function (dep) &#123; if (!this.depIds.hasOwnProperty(dep.id)) &#123; dep.addSub(this) this.depIds[dep.id] = dep &#125;&#125;/** * 依赖变动更新 * * @param &#123;Boolean&#125; shallow */Watcher.prototype.update = function () &#123; this.run()&#125;Watcher.prototype.run = function () &#123; var value = this.get() if (value !== this.value) &#123; var oldValue = this.value this.value = value // 将newVal, oldVal挂载到MVVM实例上 this.cb.call(this.vm, value, oldValue) &#125;&#125;Watcher.prototype.parseExpression = function (exp) &#123; if (/[^\\w.$]/.test(exp)) &#123; return &#125; var exps = exp.split(&apos;.&apos;) return function(obj) &#123; for (var i = 0, len = exps.length; i &lt; len; i++) &#123; if (!obj) return obj = obj[exps[i]] &#125; return obj &#125;&#125; Dep 是一个数据结构，其本质是维护了一个watcher队列，负责添加watcher，更新watcher，移除watcher，通知watcher更新。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let uid = 0function Dep() &#123; this.id = uid++ this.subs = []&#125;Dep.target = null/** * 添加一个订阅者 * * @param &#123;Directive&#125; sub */Dep.prototype.addSub = function (sub) &#123; this.subs.push(sub)&#125;/** * 移除一个订阅者 * * @param &#123;Directive&#125; sub */Dep.prototype.removeSub = function (sub) &#123; let index = this.subs.indexOf(sub); if (index !== -1) &#123; this.subs.splice(index, 1); &#125;&#125;/** * 将自身作为依赖添加到目标watcher */Dep.prototype.depend = function () &#123; Dep.target.addDep(this)&#125;/** * 通知数据变更 */Dep.prototype.notify = function () &#123; var subs = toArray(this.subs) // stablize the subscriber list first for (var i = 0, l = subs.length; i &lt; l; i++) &#123; // 执行订阅者的update更新函数 subs[i].update() &#125;&#125; 模板编译compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136function Compile(el, value) &#123; this.$vm = value this.$el = this.isElementNode(el) ? el : document.querySelector(el) if (this.$el) &#123; this.compileElement(this.$el) &#125;&#125;Compile.prototype.compileElement = function (el) &#123; let self = this let childNodes = el.childNodes ;[].slice.call(childNodes).forEach(node =&gt; &#123; let text = node.textContent let reg = /\\&#123;\\&#123;((?:.|\\n)+?)\\&#125;\\&#125;/ // 处理element节点 if (self.isElementNode(node)) &#123; self.compile(node) &#125; else if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; // 处理text节点 self.compileText(node, RegExp.$1.trim()) &#125; // 解析子节点包含的指令 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node) &#125; &#125;)&#125;Compile.prototype.compile = function (node) &#123; let nodeAttrs = node.attributes let self = this ;[].slice.call(nodeAttrs).forEach(attr =&gt; &#123; var attrName = attr.name if (self.isDirective(attrName)) &#123; let exp = attr.value let dir = attrName.substring(2) if (self.isEventDirective(dir)) &#123; compileUtil.eventHandler(node, self.$vm, exp, dir) &#125; else &#123; compileUtil[dir] &amp;&amp; compileUtil[dir](node, self.$vm, exp) &#125; node.removeAttribute(attrName) &#125; &#125;);&#125;Compile.prototype.compileText = function (node, exp) &#123; compileUtil.text(node, this.$vm, exp);&#125;Compile.prototype.isDirective = function (attr) &#123; return attr.indexOf(&apos;v-&apos;) === 0&#125;Compile.prototype.isEventDirective = function (dir) &#123; return dir.indexOf(&apos;on&apos;) === 0;&#125;Compile.prototype.isElementNode = function (node) &#123; return node.nodeType === 1&#125;Compile.prototype.isTextNode = function (node) &#123; return node.nodeType === 3&#125;// 指令处理集合var compileUtil = &#123; text: function (node, vm, exp) &#123; this.bind(node, vm, exp, &apos;text&apos;) &#125;, html: function (node, vm, exp) &#123; this.bind(node, vm, exp, &apos;html&apos;) &#125;, model: function (node, vm, exp) &#123; this.bind(node, vm, exp, &apos;model&apos;) let self = this, val = this._getVMVal(vm, exp) node.addEventListener(&apos;input&apos;, function (e) &#123; var newValue = e.target.value if (val === newValue) &#123; return &#125; self._setVMVal(vm, exp, newValue) val = newValue &#125;); &#125;, bind: function (node, vm, exp, dir) &#123; var updaterFn = updater[dir + &apos;Updater&apos;] updaterFn &amp;&amp; updaterFn(node, this._getVMVal(vm, exp)) new Watcher(vm, exp, function (value, oldValue) &#123; updaterFn &amp;&amp; updaterFn(node, value, oldValue) &#125;) &#125;, eventHandler: function (node, vm, exp, dir) &#123; var eventType = dir.split(&apos;:&apos;)[1], fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]; if (eventType &amp;&amp; fn) &#123; node.addEventListener(eventType, fn.bind(vm), false); &#125; &#125;, _getVMVal: function (vm, exp) &#123; var val = vm exp = exp.split(&apos;.&apos;) exp.forEach(function (k) &#123; val = val[k] &#125;) return val &#125;, _setVMVal: function (vm, exp, value) &#123; var val = vm; exp = exp.split(&apos;.&apos;) exp.forEach(function (k, i) &#123; // 非最后一个key，更新val的值 if (i &lt; exp.length - 1) &#123; val = val[k] &#125; else &#123; val[k] = value &#125; &#125;) &#125;&#125;var updater = &#123; textUpdater: function (node, value) &#123; node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value &#125;, htmlUpdater: function (node, value) &#123; node.innerHTML = typeof value == &apos;undefined&apos; ? &apos;&apos; : value &#125;, modelUpdater: function (node, value, oldValue) &#123; node.value = typeof value == &apos;undefined&apos; ? &apos;&apos; : value &#125;&#125; 这种实现和我们讲到的Dom-based templating类似，只是更加完备，具有自定义指令的功能。在遍历节点属性和文本节点的时候，可以编译具备{{}}表达式或v-xxx的属性值的节点，并且通过添加 new Watcher()及绑定事件函数，监听数据的变动从而对视图实现双向绑定。 MVVM实例在数据绑定初始化的时候，我们需要通过new Observer()来监听数据模型变化，通过new Compile()来解析编译模板指令，并利用Watcher搭起Observer和Compile之间的通信桥梁。12345678910111213141516/** * @class 双向绑定类 MVVM * @param &#123;[type]&#125; options [description] */function MVVM(options) &#123; this.$options = options || &#123;&#125; // 简化了对data的处理 let data = this._data = this.$options.data // 监听数据 observe(data) new Compile(options.el || document.body, this)&#125;MVVM.prototype.$watch = function (expOrFn, cb) &#123; new Watcher(this, expOrFn, cb)&#125; 为了能够直接通过实例化对象操作数据模型，我们需要为MVVM实例添加一个数据模型代理的方法：12345678910MVVM.prototype._proxy = function (key) &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get: () =&gt; this._data[key], set: (val) =&gt; &#123; this._data[key] = val &#125; &#125;)&#125; 至此我们可以通过一个小例子来说明本文的内容：1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;&#123;&#123;user.name&#125;&#125;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model=&quot;modelValue&quot;&gt; &lt;p&gt;&#123;&#123;modelValue&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let vm = new MVVM(&#123; el: &apos;#app&apos;, data: &#123; modelValue: &apos;&apos;, user: &#123; name: &apos;zhaomenghuan&apos;, age: &apos;24&apos; &#125;, address: &#123; city: &apos;beijing&apos; &#125;, skills: [&apos;JavaScript&apos;, &apos;Node.js&apos;, &apos;html5&apos;] &#125; &#125;) vm.$watch(&apos;modelValue&apos;, val =&gt; console.log(`watch modelValue ：$&#123;val&#125;`))&lt;/script&gt; 本文目的不是为了造一个轮子，而是在学习优秀框架实现的过程中去提升自己，搞清楚框架发展的前因后果，由浅及深去学习基础，本文参考了网上很多优秀博主的文章，由于时间关系，有些内容没有做深入探讨，觉得还是有些遗憾，在后续的学习中会更多的独立思考，提出更多自己的想法。 参考文档 前端模板技术面面观 Object.defineProperty() Vue.js 源码学习笔记 vue早期源码学习系列 解析最简单的observer和watcher 剖析Vue实现原理 - 如何实现双向绑定mvvm 说明 本文的完整代码及图片可以在这里下载：learn-javascript/mvvm","categories":[{"name":"JavaScript进阶学习","slug":"JavaScript进阶学习","permalink":"https://zhaomenghuan.github.io/categories/JavaScript进阶学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhaomenghuan.github.io/tags/JavaScript/"},{"name":"MVVM","slug":"MVVM","permalink":"https://zhaomenghuan.github.io/tags/MVVM/"}]},{"title":"从0到1搭建webpack2+vue2自定义模板详细教程","slug":"从0到1搭建webpack2-vue2自定义模板详细教程","date":"2017-05-17T08:53:48.000Z","updated":"2017-05-17T09:07:39.783Z","comments":true,"path":"2017/05/17/从0到1搭建webpack2-vue2自定义模板详细教程/","link":"","permalink":"https://zhaomenghuan.github.io/2017/05/17/从0到1搭建webpack2-vue2自定义模板详细教程/","excerpt":"","text":"前言webpack2和vue2已经不是新鲜东西了，满大街的文章在讲解webpack和vue，但是很多内容写的不是很详细，对于很多个性化配置还是需要自己过一遍文档。Vue官方提供了多个vue-templates，基于vue-cli用的最多，不过对于很多人来说，vue-cli 的配置还是过于复杂，对于我们了解细节实现不是很好，所以想自己从零开始搭建一个模板工程，也顺便重新认识一下webpack和vue工程化。 webpack 核心概念 Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 官方网站：https://webpack.js.org/ 安装在开始前，先要确认你已经安装Node.js的最新版本。使用 Node.js 最新的 LTS 版本，是理想的起步。使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能或缺少相关 package 包。 本地局部安装：123456# 安装 latest releasenpm install --save-dev webpack# 简写模式npm install -D webpack# 安装特定版本npm install --save-dev webpack@&lt;version&gt; 全局安装：1npm install -g webpack 注意：不推荐全局安装 webpack。这会锁定 webpack 到指定版本，并且在使用不同的 webpack 版本的项目中可能会导致构建失败。但是全局安装可以在命令行调用 webpack 命令。 【补充】npm install 安装模块参数说明：12345-g, --global 全局安装（global）-S, --save 安装包信息将加入到dependencies（生产阶段的依赖）-D, --save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它-O, --save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）-E, --save-exact 精确安装指定模块版本 npm 相关的更多命令参考这篇文章：npm 常用命令详解 然后在根目录下创建一个 webpack.config.js 文件后，你可以通过配置定义webpack的相关操作。 入口(Entry) 入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么。可以将您应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件。 单个入口（简写）语法：用法：entry: string|Array&lt;string&gt; webpack.config.js：123module.exports = &#123; entry: &apos;./src/main.js&apos;&#125;; 对象语法：用法：entry: {[entryChunkName: string]: string|Array&lt;string&gt;} webpack.config.js：123456module.exports = &#123; entry: &#123; app: &apos;./src/main.js&apos;, vendor: [&apos;vue&apos;] &#125;&#125;; 这里我们将vue作为库vendor打包，业务逻辑代码作为app打包，实现了多个入口，同时也可以将多个页面分开打包。 多页面应用程序通常使用对象语法构建。对象语法是“可扩展的 webpack 配置”，可重用并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如webpack-merge）将它们合并。 注：vue-cli 生成的模板中build文件夹下有四个配置文件： webpack.base.conf.js：基本配置 webpack.dev.conf.js：开发阶段配置 webpack.prod.conf.js：准生产阶段配置 webpack.test.conf.js：测试配置 后三个文件通过webpack-merge插件合并了基本配置，将不同环境下的配置拆分多个文件，这样更加方便管理。 出口(Output) 将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)。output 选项控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 在 webpack 中配置output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： output.filename：编译文件的文件名； output.path对应一个绝对路径，此路径是你希望一次性打包的目录。 单个入口：12345678const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;build&apos;) //__dirname + &apos;/build&apos; &#125;&#125; 多个入口：如果你的配置创建了多个 “chunk”（例如使用多个入口起点或使用类似CommonsChunkPlugin 的插件），你应该使用以下的替换方式来确保每个文件名都不重复。 [name] 被 chunk 的 name 替换。 [hash] 被 compilation 生命周期的 hash 替换。 [chunkhash] 被 chunk 的 hash 替换。 12345678910111213const path = require(&apos;path&apos;);module.exports = &#123; entry: &#123; app: &apos;./src/main.js&apos;, vendor: [&apos;vue&apos;] &#125;, output: &#123; filename: &apos;[name].js&apos;, path: path.resolve(__dirname, &apos;build&apos;) &#125;&#125;// 写入到硬盘：./build/app.js, ./build/vendor.js 加载器(Loaders) loader 用于对模块的源代码进行转换。loader 可以使你在 require() 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你在 JavaScript 中 require() CSS文件！ 在你的应用程序中，有三种方式使用 loader： 通过webpack.config.js配置 使用 require 语句中显示使用 通过 webpack CLI 这里我们主要说明一下使用webpack.config.js配置，使用loader需要在module的rules下配置相应的规则，以css-loader的webpack.config.js为例说明： 1234567module.exports = &#123; module: &#123; rules: [ &#123;test: /\\.css$/, use: &apos;css-loader&apos;&#125; ] &#125;&#125;; 这三种配置方式等效：12345678&#123;test: /\\.css$/, use: &apos;css-loader&apos;&#125;&#123;test: /\\.css$/, loader: &apos;css-loader&apos;，options: &#123; modules: true &#125;&#125;&#123;test: /\\.css$/, use: &#123; loader: &apos;css-loader&apos;, options: &#123; modules: true &#125;&#125;&#125; 注：loader/query可以和options可以在同一级使用，但是不要使用use和options在同一级使用。 CSS样式分离为了用 webpack 对 CSS 文件进行打包，你可以像其它模块一样将 CSS 引入到你的 JavaScript 代码中，同时用css-loader(像 JS 模块一样输出 CSS)，也可以选择使用ExtractTextWebpackPlugin(将打好包的 CSS 提出出来并输出成 CSS 文件)。 引入 CSS：1import &apos;bootstrap/dist/css/bootstrap.css&apos;; 安装css-loader和style-loader：1npm install --save-dev css-loader style-loader 在 webpack.config.js 中配置如下：12345678module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;] &#125;&#125; 资源路径处理因为.png等图片文件不是一个 JavaScript 文件，你需要配置 Webpack 使用file-loader或者url-loader去处理它们。使用它们的好处： file-loader 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存。此外，这意味着 你可以就近管理你的图片文件，可以使用相对路径而不用担心布署时URL问题。使用正确的配置，Webpack 将会在打包输出中自动重写文件路径为正确的URL。 url-loader 允许你有条件将文件转换为内联的 base-64 URL（当文件小于给定的阈值），这会减少小文件的 HTTP 请求。如果文件大于该阈值，会自动的交给 file-loader 处理。 安装 file-loader 和 url-loader：1npm install --save-dev file-loader url-loader 配置说明：12345678910111213141516&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: &apos;img/[name]_[hash:7].[ext]&apos; &#125;&#125;,&#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: &apos;fonts/[name].[hash:7].[ext]&apos; &#125;&#125; 插件(Plugins) 由于 loader 仅在每个文件的基础上执行转换，而插件(plugins)最常用于（但不限于）在打包模块的“compilation”和“chunk”生命周期执行操作和自定义功能（查看更多）。webpack 的插件系统极其强大和可定制化。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，你需要使用 new 创建实例来调用它。 生产环境构建对于Vue生产环境构建过程中压缩应用代码和使用Vue.js 指南 - 删除警告去除 Vue.js 中的警告，这里我们参考vue-loader文档中的配置说明：12345678910111213141516171819if (process.env.NODE_ENV === &apos;production&apos;) &#123; // http://vue-loader.vuejs.org/zh-cn/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; NODE_ENV: &apos;&quot;production&quot;&apos; &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: false, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; 显然我们不想在开发过程中使用这些配置，所以这里我们需要使用环境变量动态构建，我们也可以使用两个分开的 Webpack 配置文件，一个用于开发环境，一个用于生产环境，类似于vue-cli中使用 webpack-merge 合并配置的方式。 可以使用 Node.js 模块的标准方式：在运行 webpack 时设置环境变量，并且使用 Node.js 的process.env 来引用变量。NODE_ENV变量通常被视为事实标准（查看这里）。使用cross-env 包来跨平台设置(cross-platform-set)环境变量。 安装cross-env：1npm install --save-dev cross-env 设置package.json中的scripts字段：1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --progress --hide-modules&quot;&#125; 这里我们使用了cross-env插件，cross-env使得你可以使用单个命令，而无需担心为平台正确设置或使用环境变量。 模块热替换 模块热替换功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载页面。这使得你可以在独立模块变更后，无需刷新整个页面，就可以更新这些模块，极大地加速了开发时间。 这里我们使用webpack-dev-server插件，webpack-dev-server 为你提供了一个服务器和实时重载（live reloading）功能。webpack-dev-server是一个小型的node.js Express服务器,它使用webpack-dev-middleware中间件来为通过webpack打包生成的资源文件提供Web服务。它还有一个通过Socket.IO连接着webpack-dev-server服务器的小型运行时程序。webpack-dev-server发送关于编译状态的消息到客户端，客户端根据消息作出响应。 安装 webpack-dev-server：1npm install --save-dev webpack-dev-server 安装完成之后，你应该可以使用 webpack-dev-server 了，方式如下：1webpack-dev-server --open 上述命令应该自动在浏览器中打开 http://localhost:8080。 webpack.config.js配置：123456789101112module.exports = &#123; ... devServer: &#123; historyApiFallback: true, // 任意的 404 响应都替代为 index.html hot: true, // 启用 webpack 的模块热替换特性 inline: true // 启用内联模式 &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ] ...&#125; 更多的配置说明可以看文档：DevServer 动态生成 html 文件该插件将为你生成一个HTML5文件，其中包括使用script标签的body中的所有webpack包，也就是我们不需要手动通过script去引入打包生成的js，特别是如果我们生成的文件名是动态变化的，使用这个插件就可以轻松的解决，只需添加插件到您的webpack配置如下：12345678910111213const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; ... plugins: [ new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: true &#125;) ] ...&#125; 提取 CSS 文件extract-text-webpack-plugin是一个 可以将*.vue 文件内的 &lt;style&gt; 提取，以及JavaScript 中导入的 CSS 提取为单个 CSS 文件。配置文档具体见这里：extract-text-webpack-plugin。 安装：1npm install --save-dev extract-text-webpack-plugin 配置：123456789101112131415161718const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;styles.css&quot;), ]&#125; 同时支持我们可以配置生成多个css文件，这样我们可以将业务逻辑代码和引用的样式组件库分离。123456789101112131415161718192021222324const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);// Create multiple instancesconst extractCSS = new ExtractTextPlugin(&apos;stylesheets/[name]-one.css&apos;);const extractLESS = new ExtractTextPlugin(&apos;stylesheets/[name]-two.css&apos;);module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: extractCSS.extract([ &apos;css-loader&apos;, &apos;postcss-loader&apos; ]) &#125;, &#123; test: /\\.less$/i, use: extractLESS.extract([ &apos;css-loader&apos;, &apos;less-loader&apos; ]) &#125;, ] &#125;, plugins: [ extractCSS, extractLESS ]&#125;; clean-webpack-plugin在编译前，删除之前编译结果目录或文件:1npm install --save-dev clean-webpack-plugin 配置：123plugins: [ new CleanWebpackPlugin([&apos;dist&apos;])] 这样当我们在构建的时候可以自动删除之前编译的代码。 解析(Resolve)这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。 1234567resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: path.join(__dirname, &apos;src&apos;) &#125;, extensions: [&apos;.js&apos;, &apos;.json&apos;, &apos;.vue&apos;, &apos;.css&apos;]&#125; 我们使用最多的就是别名（alias）和自动解析确定的扩展（extensions），例如上面的@可以代替项目中src的路径，例如：1import tab from &apos;@/components/tab.vue&apos; 我们引用src/components目录下的tab.vue组件，不需要通过../之类的计算文件相对路径。这里的extensions可以让我们在引入模块时不带扩展：1import tab from &apos;@/components/tab&apos; 至此我们已经学习了我们项目devDependencies依赖中常用的模块：12345678webpack css-loader / style-loaderfile-loader / url-loader cross-env webpack-dev-server html-webpack-plugin extract-text-webpack-pluginclean-webpack-plugin 这里我们只说明了css、图片、html模板资源webpack相关的加载器和插件，对于js相关的内容丝毫没有提到，显然这是不合乎情理的。之所以要把js单独拿出来是因为js相关的内容很重要，独立出来详细去归纳一下更合适。 webpack 中如何使用 es6 ~ es8?作为一个前端，相信 es6 几乎是无人不知，很多人也一定知道可以使用Babel做语法转换，但是对于Babel有哪一些版本，每个版本支持的es6语法有哪一些应该不是所有人都清楚的，这就是这部份内容要写的意义。毕竟如果我们的插件只用到了es6中的没一些新特性，为此将整个包引入就有点不太合适，另外为了更好的用上新特性，我们至少要明白有哪一些新特性吧。 ECMAScript 标准建立的过程ECMAScript 和 JavaScript 的关系在此不再赘述，建议阅读一下阮一峰老师的《ECMAScript 6简介》，我们需要了解的是从ECMAScript 2016开始，ECMAScript将进入每年发布一次新标准的阶段。制定ECMAScript 标准的组织是ECMAScript TC39，TC39（ECMA技术委员为39）是推动JavaScript发展的委员会。 它的成员是都是企业（主要是浏览器厂商）。TC39会定期的开会， 会议的主要成员时是成员公司的代表，以及受邀请的专家。 一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。 Stage 0 - Strawman（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段） 建议看一下alinode 团队的图说ECMAScript新标准（一）就可以大致了解整个过程。 安装 BabelBabel 现在的官网提供了一个可以根据你的工具提示下载合适的包，具体见这里：Using Babel。 如果你想要在命令行使用Babel，你可以安装babel-cli，但是全局的安装babel-cli不是一个好的选择，因为这样限定了你Babel的版本；如果你需要在一个Node项目中使用Babel，你可以使用babel-core。 我们这里自然选择webpack构建我们的工程，下载方案如下：1npm install --save-dev babel-loader babel-core 然后我们需要在项目根目录下建立.babelrc文件：1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; 注：在window下无法通过 右键=&gt;新建 命令来创建以点开头的文件和文件夹，我们可以通过下面的命令生成.babelrc文件：1type NUL &gt; .babelrc Linux和Mac下可以通过touch命令生成：1touch .babelrc Babel 预设(presets)Babel是一个编译器。 在高层次上，它有3个阶段，它运行代码：解析，转换和生成（像许多其他编译器）。默认情况下，Babel 6并没有携带任何转换器，因此如果对你的代码使用Babel的话，它将会原文输出你的代码，不会有任何的改变。因此你需要根据你需要完成的任务来单独安装相应的插件。 你可以通过安装插件（plugins）或预设（presets，也就是一组插件）来指示 Babel 去做什么事情。Babel 提供了多个版本的官方预设： env es2015 es2016 es2017 latest (deprecated in favor of env) babel-preset-envbabel-preset-env可以根据你配置的选项，自动添加一些其他的转换器，来满足你当前的装换需求。.babelrc文件新增了options选项：123&#123; &quot;presets&quot;: [&quot;env&quot;, options]&#125; 具体的配置内容： targets.node 支持到哪个版本的 node targets.browsers 支持到哪个版本的浏览器 loose 启动宽松模式，配合 webpack 的 loader 使用 modules 使用何种模块加载机制 debug 开启调试模式 include 包含哪些文件 exclude 排除哪些文件 useBuiltIns 是否对 babel-polyfill 进行分解，只引入所需的部分 babel-preset-es2015es2015(ES6)相关方法转译使用的插件，具体见文档。 check-es2015-constants // 检验const常量是否被重新赋值 transform-es2015-arrow-functions // 编译箭头函数 transform-es2015-block-scoped-functions // 函数声明在作用域内 transform-es2015-block-scoping // 编译const和let transform-es2015-classes // 编译class transform-es2015-computed-properties // 编译计算对象属性 transform-es2015-destructuring // 编译解构赋值 transform-es2015-duplicate-keys // 编译对象中重复的key，其实是转换成计算对象属性 transform-es2015-for-of // 编译for…of transform-es2015-function-name // 将function.name语义应用于所有的function transform-es2015-literals // 编译整数(8进制/16进制)和unicode transform-es2015-modules-commonjs // 将modules编译成commonjs transform-es2015-object-super // 编译super transform-es2015-parameters // 编译参数，包括默认参数，不定参数和解构参数 transform-es2015-shorthand-properties // 编译属性缩写 transform-es2015-spread // 编译展开运算符 transform-es2015-sticky-regex // 正则添加sticky属性 transform-es2015-template-literals // 编译模版字符串 transform-es2015-typeof-symbol // 编译Symbol类型 transform-es2015-unicode-regex // 正则添加unicode模式 transform-regenerator // 编译generator函数 babel-preset-es2016es2016(ES7)相关方法转译使用的插件，具体见文档。 transform-exponentiation-operator // 编译幂运算符 babel-preset-es2017es2017(ES8)相关方法转译使用的插件，具体见文档。 syntax-trailing-function-commas // function最后一个参数允许使用逗号 transform-async-to-generator // 把async函数转化成generator函数 babel-preset-latestlatest是一个特殊的presets，包括了es2015，es2016，es2017的插件，不过已经废弃，使用babel-preset-env代替，具体见文档。 stage-x(stage-0/1/2/3/4)stage-x预设中的任何转换都是尚未被批准为发布Javascript的语言（如ES6 / ES2015）的更改。 stage-x和上面的es2015等有些类似，但是它是按照JavaScript的提案阶段区分的，一共有5个阶段。而数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。 babel-preset-stage-4： stage-4的插件： syntax-trailing-function-commas // function最后一个参数允许使用逗号（ES8已经存在） transform-async-to-generator // 把async函数转化成generator函数（ES8已经存在） transform-exponentiation-operator // 编译幂运算符（ES7已经存在） babel-preset-stage-3： 除了stage-4的内容，还包括以下插件： transform-object-rest-spread // 编译对象的解构赋值和不定参数 transform-async-generator-functions // 将async generator function和for await编译为es2015的generator。 babel-preset-stage-2： 除了stage-3的内容，还包括以下插件： syntax-dynamic-import // 动态加载模块 transform-class-properties // 编译静态属性(es2015)和属性初始化语法声明的属性(es2016)。 transform-decorators已禁用的等待提案更新（可以在此期间使用旧版转换） babel-preset-stage-1： 除了stage-2的内容，还包括以下插件： transform-class-constructor-call(弃用) // 编译class中的constructor，在Babel7中会被移除 transform-export-extensions // 编译额外的export语法，如export * as ns from “mod”;细节可以看这个。 babel-preset-stage-0： 除了stage-1的内容，还包括以下插件： transform-do-expressions // 编译do表达式 transform-function-bind // 编译bind运算符，即:: 为了方便，我们暂时引用 babel-preset-env 和babel-preset-stage-2这两个预设。为了启用预设，必须在.babelrc文件中定义预设的相关配置，这里参考vue-cli 模板中的配置。安装：1npminstall --save-dev babel-preset-env babel-preset-stage-2 .babelrc配置说明：12345678&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false &#125;], &quot;stage-2&quot; ]&#125; Babel 插件(plugins)我们看一下预设的构成就知道，其实就是plugins的组合。如果你不采用presets，完全可以单独引入某个功能，比如以下的设置就会引入编译箭头函数的功能，在.babelrc文件中进行配置：123&#123; &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]&#125; babel-polyfill 与 babel-runtimeBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 举例来说，ES6在 Array 对象上新增了 Array.from 方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill ，为当前环境提供一个垫片。babel-polyfill 是对浏览器缺失API的支持。 babel-runtime 是为了减少重复代码而生的。 babel生成的代码，可能会用到一些_extend()， classCallCheck() 之类的工具函数，默认情况下，这些工具函数的代码会包含在编译后的文件中。如果存在多个文件，那每个文件都有可能含有一份重复的代码。babel-runtime插件能够将这些工具函数的代码转换成require语句，指向为对babel-runtime的引用，如require(&#39;babel-runtime/helpers/classCallCheck&#39;). 这样， classCallCheck的代码就不需要在每个文件中都存在了。 启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数。除此之外，babel 还为源代码的非实例方法（Object.assign，实例方法是类似这样的 “foobar”.includes(“foo”)）和 babel-runtime/helps 下的工具函数自动引用了 polyfill。这样可以避免污染全局命名空间，非常适合于 JavaScript 库和工具包的实现。 总结： 具体项目还是需要使用 babel-polyfill，只使用 babel-runtime 的话，实例方法不能正常工作（例如 “foobar”.includes(“foo”)）； JavaScript 库和工具可以使用 babel-runtime，在实际项目中使用这些库和工具，需要该项目本身提供 polyfill。 transform-runtime只会对es6的语法进行转换，而不会对新api进行转换。如果需要转换新api，就要引入babel-polyfill。 安装插件1npm install --save-dev babel-plugin-transform-runtime .babelrc 配置：123&#123; &quot;plugins&quot;: [&quot;transform-runtime&quot;, options]&#125; options主要有以下设置项： helpers: boolean，默认true，使用babel的helper函数； polyfill: boolean，默认true，使用babel的polyfill，但是不能完全取代babel-polyfill； regenerator: boolean，默认true，使用babel的regenerator； moduleName: string，默认babel-runtime，使用对应module处理。 注：默认moduleName为babel-runtime，这里我们可以不必显式的下载babel-runtime，因为babel-plugin-transform-runtime依赖于babel-runtime。 babel-registerbabel-register 模块改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js 、 .jsx 、 .es 和 .es6 后缀名的文件，就会先用Babel进行转码。引入babel-register，这样后面的文件就可以用 import 代替require，import的优点在于可以引入所需方法或者变量，而不需要加载整个模块，提高了性能。 安装：1npm install --save-dev babel-register 这部分我们又介绍了下面几个模块的安装：123456babel-loaderbabel-corebabel-preset-env babel-preset-stage-2 babel-plugin-transform-runtimebabel-register webpack 中如何使用 vue?既然本文的目标是vue的自定义模板工程，那么自然这里需要单独介绍一下webpack中vue相关的插件。 Vue2 dist 目录下各个文件的区别npm 安装：1npm install --save vue vue2 经过 2.2 版本升级后, 文件变成 8 个: UMD CommonJS ES Module 独立构建 vue.js vue.common.js vue.esm.js 运行构建 vue.runtime.js vue.runtime.common.js vue.runtime.esm.js vue.min.js 和 vue.runtime.min.js 都是对应的压缩版。 AMD:异步模块规范vue 没有单独提供 AMD 模块的版本，但是UMD版本中进行了包装，可以直接用作 AMD 模块，使用方法如下： 123456define([&quot;Vue&quot;],function(Vue) &#123; function myFn() &#123; ... &#125; return myFn;&#125;); CommonJS:node中常用的模块规范，通过require引入模块，module.exports导出模块。 123456...function Vue$3() &#123; ...&#125;...module.exports = Vue$3; UMD: 通用模块规范兼容了AMD和CommonJS，同时还支持老式的“全局”变量规范： 123456789101112(function (global, factory) &#123; typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos; ? module.exports = factory() : typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory) : (global.Vue = factory());&#125;(this, (function () &#123; &apos;use strict&apos;; ... function Vue$3() &#123; ... &#125; ... return Vue$3;&#125;))); ES ModuleES6在语言标准的层面上，实现的模块功能。模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 12345...function Vue$3() &#123; ...&#125;export default Vue$3; 总结： vue.js 和 vue.runtime.js 可以用于直接 CDN 引用； vue.common.js和vue.runtime.common.js可以使用Webpack1 / Browserify 打包构建； vue.esm.js和vue.runtime.esm.js可以使用Webpack2 / rollup 打包构建。 vue有两种构建方式，独立构建和运行时构建。它们的区别独立构建前者包含模板编译器而运行构建不包含。模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 template 选项，你就需要编译器。 独立构建包含模板编译器并支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。 运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%，只有 17.14 Kb min+gzip大小。 独立构建方式可以这样使用template选项：12345678import Vue from &apos;vue&apos;new Vue(&#123; template: ` &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Basic&lt;/h1&gt; &lt;/div&gt; `&#125;).$mount(&apos;#app&apos;) 这里我们使用ES Module规范，默认 NPM 包导出的是运行时构建。为了使用独立构建，在 webpack 配置中添加下面的别名：12345resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos; &#125;&#125; vue-loader安装：1npm install --save-dev vue-loader vue-template-compiler vue-loader 依赖于 vue-template-compiler。 vue-loader 是一个 Webpack 的 loader，可以将用下面这个格式编写的 Vue 组件转换为 JavaScript 模块。这里有一些 vue-loader 提供的很酷的特性： ES2015 默认支持; 允许对 Vue 组件的组成部分使用其它 Webpack loaders，比如对 &lt;style&gt; 使用 SASS 和对 &lt;template&gt; 使用 Jade； .vue 文件中允许自定义节点，然后使用自定义的 loader 处理他们； 把&lt;style&gt;和 &lt;template&gt; 中的静态资源当作模块来对待，并使用 Webpack loaders 进行处理； 对每个组件模拟出 CSS 作用域； 支持开发期组件的热重载。 简而言之，编写 Vue.js 应用程序时，组合使用 Webpack 和 vue-loader 能带来一个现代，灵活并且非常强大的前端工作流程。 在 Webpack 中，所有的预处理器需要匹配对应的 loader。 vue-loader 允许你使用其它 Webpack loaders 处理 Vue 组件的某一部分。它会根据 lang 属性自动推断出要使用的 loaders。 上述我们提到extract-text-webpack-plugin插件提取css，这里说明一下.vue中style标签之间的样式提取的办法： 1234567891011121314151617181920212223var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; use: &apos;css-loader&apos;, fallback: &apos;vue-style-loader&apos; // &lt;- 这是vue-loader的依赖，所以如果使用npm3，则不需要显式安装 &#125;) &#125; &#125; &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;app.css&quot;) ]&#125; pug 模板用过模板的都知道，熟悉了模板写起来快多了，大名鼎鼎的jade恐怕无人不知吧。pug是什么鬼？第一次听到的时候我也好奇了，然后查了一下才知道，Pug原名不叫Pug，原来是大名鼎鼎的jade，后来由于商标的原因，改为Pug，哈巴狗。以下是官方解释： it has been revealed to us that “Jade” is a registered trademark, and as a result a rename is needed. After some discussion among the maintainers, “Pug” has been chosen as the new name for this project. 简单看了看还是原来jade熟悉的语法规则，果断在这个模板工程里面用上。 vue-loader里面对于模版的处理方式略有不同，因为大多数 Webpack 模版处理器（比如 pug-loader）会返回模版处理函数，而不是编译的 HTML 字符串，我们使用原始的 pug 替代 pug-loader:1npm install pug --save-dev 使用：1234&lt;template lang=&quot;pug&quot;&gt;div h1 Hello world!&lt;/template&gt; 重要: 如果你使用 vue-loader@&lt;8.2.0， 你还需要安装 template-html-loader。 PostCSS安装vue-loader的时候默认安装了postcss，由vue-loader处理的 CSS 输出，都是通过PostCSS进行作用域重写，你还可以为 PostCSS 添加自定义插件，例如autoprefixer或者CSSNext。 在 webpack 工程中使用 postcss，我们需要下载 postcss-loader：1npm install --save-dev postcss-loader cssnext cssnext 是一个 CSS transpiler，允许你使用最新的 CSS 语法。cssnext 把 新 CSS 规范转换成兼容性更强的 CSS，所以不需要等待各种浏览器支持。 安装：1npm install --save-dev postcss-cssnext postcss.config.js:12345module.exports = &#123; plugins: [ require(&apos;postcss-cssnext&apos;) ]&#125; webpack.config.js:12345678910module.exports = &#123; module: &#123; loaders: [ &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;] &#125; ] &#125;&#125; cssnext 依赖了autoprefixer，所以我们无需显式下载autoprefixer。更多关于postcss的插件可以看这里：postcss plugins。 这一部分我们学习了这些依赖：123456vuevue-loader vue-template-compilerpugpostcss-loaderpostcss-cssnext webpack2 开启 eslint 校验规范自己的代码从ESlint开始。ESlint和webpack集成，在babel编译代码开始前，进行代码规范检测。这里我们使用javascript-style-standard风格的校验。 主要依赖的几个包：123456789101112eslint —— 基础包eslint-loader —— webpack loaderbabel-eslint —— 校验babeleslint-plugin-html —— 提取并检验你的 .vue 文件中的 JavaScripteslint-friendly-formatter —— 生成美化的报告格式# javascript-style-standard 依赖的包eslint-config-standardeslint-plugin-importeslint-plugin-nodeeslint-plugin-promiseeslint-plugin-standard 安装：1npm install --save-dev eslint eslint-loader babel-eslint eslint-plugin-html eslint-friendly-formatter eslint-config-standard eslint-plugin-import eslint-plugin-node eslint-plugin-node eslint-plugin-promise eslint-plugin-standard 关于eslint的配置方式，比较多元化，具体可以看配置文档： js注释 .eslintrc.*文件 package.json里面配置eslintConfig字段 安装eslint-loader之后，我们可以在webpack配置中使用eslint加载器。webpack.config.js123456789101112131415161718...module: &#123; loaders: [ &#123; test: /\\.vue|js$/, enforce: &apos;pre&apos;, include: path.resolve(__dirname, &apos;src&apos;), exclude: /node_modules/, use: [&#123; loader: &apos;eslint-loader&apos;, options: &#123; formatter: require(&apos;eslint-friendly-formatter&apos;) &#125; &#125;] &#125; ]&#125;,... 此外，我们既可以在webpack配置文件中指定检测规则，也可以遵循最佳实践在一个专门的文件中指定检测规则，我们就采用后面的方式。在根目录下：1touch .eslintrc.js .eslintrc.js：123456789101112131415161718192021222324module.exports = &#123; root: true, parser: &apos;babel-eslint&apos;, parserOptions: &#123; sourceType: &apos;module&apos; &#125;, env: &#123; browser: true &#125;, extends: &apos;standard&apos;, // required to lint *.vue files plugins: [ &apos;html&apos; ], // add your custom rules here rules: &#123; // allow paren-less arrow functions &apos;arrow-parens&apos;: 0, // allow async-await &apos;generator-star-spacing&apos;: 0, // allow debugger during development &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? 2 : 0 &#125;&#125; 这部份我们主要学习了一下eslint相关插件的含义和配置方法。 创建属于你的模板如果你对官方的模板不感兴趣，你可以自己fork下来然后进行修改（或者重新写一个），然后用 vue-cli 来调用。因为 vue-cli 可以直接拉取 git源：1vue init username/repo my-project 这里我们参考vue-cli的模板工程自己写一个模板工程，主要是需要通过meta.*（js,json）进行配置：12345678910111213141516171819202122232425262728293031323334353637383940414243module.exports = &#123; &quot;helpers&quot;: &#123; &quot;if_or&quot;: function (v1, v2, options) &#123; if (v1 || v2) &#123; return options.fn(this); &#125; return options.inverse(this); &#125; &#125;, &quot;prompts&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;required&quot;: true, &quot;message&quot;: &quot;Project name&quot; &#125;, &quot;version&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;required&quot;: false, &quot;message&quot;: &quot;Project version&quot;, &quot;default&quot;: &quot;1.0.0&quot; &#125;, &quot;description&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;required&quot;: false, &quot;message&quot;: &quot;Project description&quot;, &quot;default&quot;: &quot;A Vue.js project&quot; &#125;, &quot;author&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;message&quot;: &quot;Author&quot; &#125;, &quot;router&quot;: &#123; &quot;type&quot;: &quot;confirm&quot;, &quot;message&quot;: &quot;Install vue-router?&quot; &#125;, &quot;vuex&quot;: &#123; &quot;type&quot;: &quot;confirm&quot;, &quot;message&quot;: &quot;Install vuex?&quot; &#125; &#125;, &quot;completeMessage&quot;: &quot;To get started:\\n\\n &#123;&#123;^inPlace&#125;&#125;cd &#123;&#123;destDirName&#125;&#125;\\n &#123;&#123;/inPlace&#125;&#125;npm install\\n npm run dev\\n\\nDocumentation can be found at https://github.com/zhaomenghuan/vue-webpack-template&quot;&#125;; 这里我们就是采用最简单的方式，对于vue-router、vuex的配置每个人习惯不一样，所以不写在模板工程里面。 然后使用vue-cli使用这个模板创建工程，没有安装vue-cli的执行：1npm install --global vue-cli 然后创建工程：123456# 创建一个基于 webpack 模板的新项目vue init zhaomenghuan/vue-webpack-template my-project# 安装依赖，走你cd my-projectnpm installnpm run dev 这里按照国际惯例安利一下本文的模板工程：vue-webpack-template 参考webpack官方文档babel官方文档vue-loader中文文档JavaScript books by Dr. Axel RauschmayerES7新特性及ECMAScript标准的制定流程如何写好.babelrc？Babel的presets和plugins配置解析babel的polyfill和runtime的区别webpack2集成eslint","categories":[{"name":"vue.js+node.js全栈开发","slug":"vue-js-node-js全栈开发","permalink":"https://zhaomenghuan.github.io/categories/vue-js-node-js全栈开发/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://zhaomenghuan.github.io/tags/vue-js/"},{"name":"webpack","slug":"webpack","permalink":"https://zhaomenghuan.github.io/tags/webpack/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://zhaomenghuan.github.io/tags/vue-cli/"}]},{"title":"Linux CentOS7 搭建node服务详细教程","slug":"Linux CentOS7 搭建node服务详细教程","date":"2017-05-12T06:44:18.000Z","updated":"2017-05-17T09:13:52.942Z","comments":true,"path":"2017/05/12/Linux CentOS7 搭建node服务详细教程/","link":"","permalink":"https://zhaomenghuan.github.io/2017/05/12/Linux CentOS7 搭建node服务详细教程/","excerpt":"","text":"前言近期在准备搭建一个vue.js+node.js全栈开发的社区，之前由于没有云服务器搭建经验，这篇文章做一下相关的记录，后续再深入学习研究。本文不局限于只是流水账式的记录，会顺便说明一下Linux的相关内容。 登录Linux云服务器至于购买云服务的过程在此不做赘述，各大云服务提供商都有相关的说明文档。当我们买好了云主机，可以通过控制面板登录，也可以使用密码从本地登录。 Linux或Mac OS用户登录Linux云服务器，直接使用SSH命令进行连接，如：ssh root@Linux云服务器公网IP，然后输入root用户的初始密码，即可完成登录。 Window系统上 Linux 远程登录客户端有SecureCRT, Putty, SSH Secure Shell等，本文以Putty为例来登录远程服务器。 下载远程链接软件Putty，参考下载地址：http://www.chiark.greenend.org.uk/~sgtatham/putty/ 打开Putty客户端，在PuTTY Configuration 窗口中输入以下内容：Host Name：Linux云服务器的公网IP。Port：云服务器的端口，必须填22。（请确保云主机22端口已开放）Connect type：选择“SSH”。 全部输入完后，点击“Open”，创建一个新对话。 在Putty会话窗口中， 输入管理员帐号，按回车键。再输入初始密码，回车完成登录过程。 Linux 系统目录结构登录系统后，在当前命令窗口下输入命令：1ls / 结果如下：123[root@centos ~]# ls /bin data etc lib lost+found mnt proc run srv tmp varboot dev home lib64 media opt root sbin sys usr 树状目录结构： 以下是对这些目录的解释：/bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。/dev：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root：该目录为系统管理员，也称作超级权限者的用户主目录。/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。/selinux：这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。/srv：该目录存放一些服务启动之后需要提取的数据。/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。/tmp：这个目录是用来存放一些临时文件的。/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。/usr/bin：系统用户使用的应用程序。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。 了解系统目录结构，对于我们安装管理一些依赖包更加清晰。 Linux 文件基本属性Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：123[root@VM_195_14_centos ~]# ls -ltotal 4-rw-------. 1 root root 2523 Apr 21 2016 anaconda-ks.cfg 实例中，anaconda-ks.cfg文件的第一个属性用”-“表示，”-“在Linux中代表该文件是一个文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件，对应规则如下： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定，如下图： {% image http://upload-images.jianshu.io/upload_images/1945738-a03a98765e603fb4.png '' '' %} Linux 文件与目录管理Linux的目录结构为树状结构，最顶级的目录为根目录 /。 绝对路径：从根目录 / 写起，如：/usr/share/applications相对路径：使用../或~（/root的简称）。 处理目录的常用命令： ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 注：可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 文件内容查看的命令： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 Linux 磁盘管理inux磁盘管理常用三个命令为df、du和fdisk。 df：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 fdisk：用于磁盘分区 df 命令 df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。语法：1df [-ahikHTm] [目录或文件名] 选项与参数：-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来显示 du命令Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。语法：du [-ahskm] 文件或目录名称选项与参数：-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； Linux vimVim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 史上最全Vim快捷键键位图（入门到进阶） {% image http://upload-images.jianshu.io/upload_images/1945738-1fe0b909665b1f09.png '' '' %} 打开文件的命令 {% image http://upload-images.jianshu.io/upload_images/1945738-43dee391c6bf6a74.png '' '' %} 基本上 vim 共分为三种模式，分别是命令模式（Command mode），插入模式（Insert mode）和末行模式（Last line mode）。 这三种模式的作用分别是：命令模式、输入模式、末行模式。 vi/vim三种模式切换{% image http://upload-images.jianshu.io/upload_images/1945738-8a3e2e194c142040.png 'vi/vim三种模式切换' '' %} 命令模式用户刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令：i 切换到插入模式，以输入字符。x 删除当前光标所在处的字符。: 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 移动光标的位置：{% image http://upload-images.jianshu.io/upload_images/1945738-6ef7c0c3957760d3.png '' '' %} 字符串的复制、删除、粘贴：{% image http://upload-images.jianshu.io/upload_images/1945738-6872cedbde22d898.png '' '' %} 输入模式在命令模式下按下i、I、a、A、o、O、r和R中的某一个键就进入了输入模式。在输入模式中，可以使用以下按键：字符按键以及Shift组合，输入字符ENTER，回车键，换行BACK SPACE，退格键，删除光标前一个字符DEL，删除键，删除光标后一个字符方向键，在文本中移动光标HOME/END，移动光标到行首/行尾Page Up/Page Down，上/下翻页Insert，切换光标为输入/替换模式，光标将变成竖线/下划线ESC，退出输入模式，切换到命令模式 {% image http://upload-images.jianshu.io/upload_images/1945738-bd165fe4e4f95459.png '' '' %} 末行模式在命令模式下按下:（英文冒号）就进入了底线命令模式。末行模式可以输入单个或多个字符的命令，可用的命令非常多。在末行模式中，基本的命令有：：q 退出程序：w 保存文件按ESC键可随时退出底线命令模式。 vim的保存文件和退出命令 :w —— 保存编辑后的文件内容，但不退出vim编辑器。这个命令的作用是把内存缓冲区中的数据写到启动vim时指定的文件中。:w! —— 强制写文件，即强制覆盖原有文件。如果原有文件的访问权限不允许写入文件，例如，原有的文件为只读文件，则可使用这个命令强制写入。但是，这种命令用法仅当用户是文件的属主时才适用，而超级用户则不受此限制。:wq —— 保存文件内容后退出vim编辑器。这个命令的作用是把内存缓冲区中的数据写到启动vim时指定的文件中，然后退出vim编辑器。另外一种替代的方法是用ZZ命令。:wq! —— 强制保存文件内容后退出vim编辑器。这个命令的作用是把内存缓冲区中的数据强制写到启动vim时指定的文件中，然后退出vim编辑器。ZZ —— 使用ZZ命令时，如果文件已经做过编辑处理，则把内存缓冲区中的数据写到启动vim时指定的文件中，然后退出vim编辑器。否则只是退出vim而已。注意，ZZ命令前面无需加冒号“：”，也无需按Enter键。:q —— 在未做任何编辑处理而准备退出vim时，可以使用此命令。如果已做过编辑处理，则vim不允许用户使用“:q”命令退出，同时还会输出下列警告信息：No write since last change (:quit! overrides):q! —— 强制退出vim编辑器，放弃编辑处理的结果。如果确实不需要保存修改后的文件内容，可输入“:q!”命令，强行退出vim编辑器。:w filename —— 把编辑处理后的结果写到指定的文件中保存:w! filename —— 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有的文件。:wq! filename —— 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有文件，并退出vim编辑器。 Linux Yum 包管理器 Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 yum 语法1yum [options] [command] [package ...] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 yum常用命令 1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install 4.仅更新指定的软件命令：yum update 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers 安装及启动nginxNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。具有很有特性： 热部署：在master管理进程与worker工作进程的分离设计，使的Nginx具有热部署的功能，那么在7×24小时不间断服务的前提下，升级Nginx的可执行文件。也可以在不停止服务的情况下修改配置文件，更换日志文件等功能。 可以高并发连接：理论上，Nginx支持的并发连接上限取决于你的内存，10万远未封顶。 低的内存消耗：在一般的情况下，10000个非活跃的HTTP Keep-Alive 连接在Nginx中仅消耗2.5M的内存，这也是Nginx支持高并发连接的基础。 处理响应请求很快：在正常的情况下，单次请求会得到更快的响应。在高峰期，Nginx可以比其他的Web服务器更快的响应请求。 具有很高的可靠性：高可靠性来自其核心框架代码的优秀设计、模块设计的简单性；并且这些模块都非常的稳定。 yum 安装：1yum install -y nginx 启动nginx服务：1service nginx start 测试nginx服务：1wget http://127.0.0.1 若结果如下，说明nginx服务正常。12345678910[root@VM_195_14_centos ~]# wget http://127.0.0.1--2017-05-11 20:32:34-- http://127.0.0.1/Connecting to 127.0.0.1:80... connected.HTTP request sent, awaiting response... 200 OKLength: 3700 (3.6K) [text/html]Saving to: &apos;index.html&apos;100%[======================================&gt;] 3,700 --.-K/s in 0s2017-05-11 20:32:34 (632 MB/s) - &apos;index.html&apos; saved [3700/3700] 在浏览器中，访问通过CentOS云服务器公网IP查看nginx服务是否正常运行。 nginx 服务器命令启动nginx：service nginx start访问（nginx默认是80端口）：curl 127.0.0.1nginx配置文件目录：nginx -t重启nginx：service nginx restart停用nginx：service nginx stop Linux 源码编译安装node.js开篇说了我会尝试建立一个vue.js+node.js全栈开发的交流社区，自然这个站点会基于node.js构建后端。 Linux下node有多种安装方式，这里我们手工安装官方最新版本。 1.安装编译环境我的CentOS版本是7.2，安装前先安装编译环境，如gcc编译器：1yum install -y gcc gcc-c++ openssl-devel 然后执行gcc -v运行正常：12...gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) 2.检查和核对Python版本Node.js环境需要Python2.6以上，我们需要检查，如果不是则需要安装和升级最新版Python。1python 退出python命令行使用exit() 命令或者Ctrl-D快捷键。 3.安装最新版本Node.js 我们将我们的node下载到/usr/local/src文件夹下进行安装：1cd /usr/local/src 下载：1wget http://nodejs.org/dist/node-latest.tar.gz 解压：1tar -zxvf node-latest.tar.gz 进入当前版本进行编译，先通过ls查询解压的文件夹名：12[root@VM_195_14_centos src]# lsnode-latest.tar.gz node-v7.10.0 然后进入node-v7.10.0文件夹进行安装：123cd node-v0.12.7./configuremake &amp;&amp; make install 然后检查node是否正确安装：1node -v 如果正确打印出版本则正确安装。 通过Filezilla实现本地Windows上传文件到Linux服务器/从Linux服务器下载文件本方法仅适合本地为Windows系统的用户，可实现将本地文件上传至Linux服务器/下载Linux服务器上的文件。本地为Linux系统的用户可直接使用SCP命令进行上传下载。本地安装Filezilla客户端，参考下载地址：https://www.filezilla.cn/download/client 点击【文件】-【站点管理器】，点击【新站点】按钮，输入以下内容：{% image https://mccdn.qcloud.com/static/img/58132d70663ac9ce5169462eb9ccb944/image.png '' '' %}主机：Linux云服务器的公网IP端口：远程连接端口，默认22协议：选择【SFTP】ssh文件传输协议登录类型：选择正常用户：Linux云服务器的登录用户，默认为root/ubuntu密码：Linux云服务器的登录密码 点击【连接】按钮，等待连接Linux云服务器。{% image https://mccdn.qcloud.com/static/img/6653190a5e08b34c83d1f3d9ed9a84f6/image.png '' '' %}连接成功后，左侧为本地文件，右侧为服务器端文件。需要上传本地文件至服务器时，在左侧需要上传的文件上右键单击【上传】按钮，文件即可上传到右侧服务器文件目录下；需要下载服务器文件至本地时，在右侧需要下载的文件上右键单击【下载】按钮，文件即可下载到左侧本地文件目录下； Linux Nginx ssl证书部署我是在腾讯云上部署的，在这里申请免费的SSL证书：申请免费证书。申请完了后下载证书然后可以利用上面说的Filezilla上传到服务器上，参考这里的文档Nginx 证书部署。 下载解压证书，Nginx文件夹内获得SSL证书文件 1_www.domain.com_bundle.crt 和私钥文件 2_www.domain.com.key,1_www.domain.com_bundle.crt 文件包括两段证书代码 “—–BEGIN CERTIFICATE—–”和“—–END CERTIFICATE—–”,2_www.domain.com.key 文件包括一段私钥代码“—–BEGIN RSA PRIVATE KEY—–”和“—–END RSA PRIVATE KEY—–”。 将域名 www.domain.com 的证书文件1_www.domain.com_bundle.crt 、私钥文件2_www.domain.com.key保存到同一个目录，例如/usr/share/nginx/conf目录下。 更新Nginx根目录下conf/nginx.conf 文件。 这里重点说说更新nginx.conf文件，新手一般不知道nginx.conf的位置，这时候我们就需要使用nginx -t来查找nginx配置文件，并使用vi命令修改该配置文件，如下：123[root@VM_195_14_centos ~]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 打开 vim 修改nginx.conf文件：1vim /etc/nginx/nginx.conf 主要修改server：123456789101112server &#123; listen 443; server_name www.domain.com; #填写绑定证书的域名 ssl on; ssl_certificate /usr/share/nginx/conf/1_www.domain.com_bundle.crt; ssl_certificate_key /usr/share/nginx/conf/2_www.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; #其他不修改...&#125; 配置完成后，正确无误的话，重启nginx。就可以使 https://www.domain.com 来访问了。 注：（配置关键字段） 配置文件参数 说明 listen 443 SSL访问端口号为443 ssl on 启用SSL功能 ssl_certificate 证书文件 ssl_certificate_key 私钥文件 ssl_protocols 使用的协议 ssl_ciphers 配置加密套件，写法遵循openssl标准 Linux node服务nginx配置前面我们已经正确下载了node环境，这里我们写一个简单的node程序开启一个node服务。 {% image http://upload-images.jianshu.io/upload_images/1945738-456d2a56f7fcc3f5.png '' '' %} 使用vim /var/www/index.js在/var/www文件夹下建立一个index.js，起一个最简单的服务。123456789const http = require(&apos;http&apos;);const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;); res.end(&apos;Hello World\\n&apos;);&#125;);server.listen(3000, () =&gt; &#123; console.log(`node server is now running/`);&#125;); nodejs默认端口是3000，需要配置nginx反向代理到nodejs的3000端口。1234567891011121314151617181920server &#123; listen 443; server_name www.domain.com; ssl on; ssl_certificate /usr/share/nginx/conf/1_www.vuenode.com_bundle.crt; ssl_certificate_key /usr/share/nginx/conf/2_www.vuenode.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection ‘upgrade’; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &#125;&#125; 然后重启nginx及打开node服务：12service nginx restartnode /var/www/index 我们打开浏览器，页面页面会出现 hello world，至此我们的node服务已经搭建完成。这里需要说明的是我们容易产生一个误区的是 node 提供了 https 模块，我们在构建node服务的时候是使用 http 模块还是 https 模块，如果我们之间使用 node 做服务，不经过nginx反向代理，确实是可以使用 https 模块，不过这里我们使用了nginx对外部访问的时候是使用 https，服务器内部使用http模块即可。 参考Linux 教程Linux学习笔记：5.Vim编辑器(2)：三种模式和命令我们为什么要用nginx，nginx的特点","categories":[{"name":"node学习之路","slug":"node学习之路","permalink":"https://zhaomenghuan.github.io/categories/node学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zhaomenghuan.github.io/tags/Linux/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhaomenghuan.github.io/tags/CentOS7/"},{"name":"node.js","slug":"node-js","permalink":"https://zhaomenghuan.github.io/tags/node-js/"}]},{"title":"cordova研习笔记(二) —— cordova 6.X 源码解读","slug":"cordova研习笔记(二)——cordova 6.X 源码解读（上）","date":"2017-05-03T16:00:00.000Z","updated":"2017-05-08T05:43:46.652Z","comments":true,"path":"2017/05/04/cordova研习笔记(二)——cordova 6.X 源码解读（上）/","link":"","permalink":"https://zhaomenghuan.github.io/2017/05/04/cordova研习笔记(二)——cordova 6.X 源码解读（上）/","excerpt":"","text":"前言cordova(PhoneGap) 是一个优秀的经典的中间件框架，网上对其源代码解读的文章确实不多，本系列文章试着解读一下，以便对cordova 框架的原理理解得更深入。本文源码为cordova android版本6.1.2。 源码结构我们使用IDE的代码折叠功能先从整体上把握代码结构。123456/** 版权申明及注释部分*/;(function() &#123; ...&#125;)(); ;是保证导入的其它js脚本，使用工具压缩js文件时不出错。一个自执行匿名函数包裹，防止内部变量污染到外部命名空间。阅读过jQuery源码的人都知道，jQuery的也是相同的结构，只是jQuery定义的匿名函数多了两个参数window和undefined，然后调用的时候只传入window，这样，window可以在jQuery内部安全使用，而undefined也的确表示未定义（有些浏览器实现允许重定义undefined）。 继续展开代码，可以看到如下的结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576;(function() &#123;var PLATFORM_VERSION_BUILD_LABEL = '6.1.2';// 模块化系统/* ------------------------------------------------------------- */var require, // 加载使用module define; // 定义注册module// require|define 的逻辑(function () &#123; ...&#125;)();// Export for use in nodeif (typeof module === \"object\" &amp;&amp; typeof require === \"function\") &#123; module.exports.require = require; module.exports.define = define;&#125;/* ------------------------------------------------------------- */// 事件的处理和回调，外部访问cordova.js的入口define(\"cordova\", function(require, exports, module) &#123; ... &#125;// JS-&gt;Native的具体交互形式define(\"cordova/android/nativeapiprovider\", function(require, exports, module) &#123; ... &#125;// 通过prompt()和Native交互define(\"cordova/android/promptbasednativeapi\", function(require, exports, module) &#123; ... &#125;// 用于plugin中校验参数，比如argscheck.checkArgs('fFO', 'Camera.getPicture', arguments); 参数应该是2个函数1个对象define(\"cordova/argscheck\", function(require, exports, module) &#123; ... &#125;// JS-&gt;Native交互时对ArrayBuffer进行uint8ToBase64（WebSockets二进制流）define(\"cordova/base64\", function(require, exports, module) &#123; ... &#125;// 对象属性操作，比如把一个对象的属性Merge到另外一个对象define(\"cordova/builder\", function(require, exports, module) &#123; ... &#125;// 事件通道define(\"cordova/channel\", function(require, exports, module) &#123; ... &#125;// 执行JS-&gt;Native交互define(\"cordova/exec\", function(require, exports, module) &#123; ... &#125;// 用于Plugin中往已经有的模块上添加方法define(\"cordova/exec/proxy\", function(require, exports, module) &#123; ... &#125;// 初始化处理define(\"cordova/init\", function(require, exports, module) &#123; ... &#125;define(\"cordova/init_b\", function(require, exports, module) &#123; ... &#125;// 把定义的模块clobber到一个对象，在初始化的时候会赋给windowdefine(\"cordova/modulemapper\", function(require, exports, module) &#123; ... &#125;define(\"cordova/modulemapper_b\", function(require, exports, module) &#123; ... &#125;// 平台启动处理define(\"cordova/platform\", function(require, exports, module) &#123; ... &#125;// 清缓存、loadUrl、退出程序等define(\"cordova/plugin/android/app\", function(require, exports, module) &#123; ... &#125;// 载所有cordova_plugins.js中定义的模块，执行完成后会触发define(\"cordova/pluginloader\", function(require, exports, module) &#123; ... &#125;define(\"cordova/pluginloader_b\", function(require, exports, module) &#123; ... &#125;// 获取绝对URL，InAppBrowser中会用到define(\"cordova/urlutil\", function(require, exports, module) &#123; ... &#125;// 工具类define(\"cordova/utils\", function(require, exports, module) &#123; ... &#125;// 所有模块注册完之后，导入cordova至全局环境中window.cordova = require('cordova');// 初始化启动require('cordova/init'); 从上可以清晰的看出，在cordova内部，首先是定义了两个公共的require和define函数，然后是使用define注册所有模块，再通过window.cordova=require(‘cordova’)导入库文件至全局执行环境中。 模块机制类似于Java的package/import，在JavaScript中也有类似的define/require，它用来异步加载module化的js，从而提高运行效率。模块化加载的必要性，起源于nodejs的出现。但是JavaScript并没有内置模块系统，所以就出现了很多规范。 主要有2种：CommonJS 和 AMD（Asynchronous Module Definition）。还有国内兴起的CMD（Common Module Definition） 。CommonJS主要面对的是服务器，代表是Node.js；AMD针对浏览器进行了优化，主要实现require.js；CMD是seajs。 cordova-js最开始采用的是require.js作者写的almond.js（兼容AMD和CommonJS），但之后由于特殊需求（比如模块不存在的时候要throw异常），最终从almond.js fork过来实现了一个简易CommonJS风格的模块系统，同时提供了和nodejs之间很好的交互。在cordova.js中可以直接使用define()和require()，在其他文件可以通过cordova.define()和cordova.require()来调用。所以src/scripts/require.js中定义的就是一个精简的JavaScript模块系统。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// cordova.js内部使用的全局函数require/definevar require, define;(function () &#123; // 初始化一个空对象，缓存所有的模块 var modules = &#123;&#125;, // 正在build中的模块ID的栈 requireStack = [], // 标示正在build中模块ID的Map inProgressModules = &#123;&#125;, SEPARATOR = \".\"; // 模块build function build(module) &#123; // 备份工厂方法 var factory = module.factory, // 对require对象进行特殊处理 localRequire = function (id) &#123; var resultantId = id; //Its a relative path, so lop off the last portion and add the id (minus \"./\") if (id.charAt(0) === \".\") &#123; resultantId = module.id.slice(0, module.id.lastIndexOf(SEPARATOR)) + SEPARATOR + id.slice(2); &#125; return require(resultantId); &#125;; // 给模块定义一个空的exports对象，防止工厂类方法中的空引用 module.exports = &#123;&#125;; // 删除工厂方法 delete module.factory; // 调用备份的工厂方法（参数必须是require,exports,module） factory(localRequire, module.exports, module); // 返回工厂方法中实现的module.exports对象 return module.exports; &#125; // 加载使用模块 require = function (id) &#123; // 如果模块不存在抛出异常 if (!modules[id]) &#123; throw \"module \" + id + \" not found\"; // 如果模块正在build中抛出异常 &#125; else if (id in inProgressModules) &#123; var cycle = requireStack.slice(inProgressModules[id]).join('-&gt;') + '-&gt;' + id; throw \"Cycle in require graph: \" + cycle; &#125; // 如果模块存在工厂方法说明还未进行build（require嵌套） if (modules[id].factory) &#123; try &#123; // 标示该模块正在build inProgressModules[id] = requireStack.length; // 将该模块压入请求栈 requireStack.push(id); // 模块build，成功后返回module.exports return build(modules[id]); &#125; finally &#123; // build完成后删除当前请求 delete inProgressModules[id]; requireStack.pop(); &#125; &#125; // build完的模块直接返回module.exports return modules[id].exports; &#125;; // 定义注册模块 define = function (id, factory) &#123; // 如果已经存在抛出异常 if (modules[id]) &#123; throw \"module \" + id + \" already defined\"; &#125; // 模块以ID为索引包含ID和工厂方法 modules[id] = &#123; id: id, factory: factory &#125;; &#125;; // 移除模块 define.remove = function (id) &#123; delete modules[id]; &#125;; // 返回所有模块 define.moduleMap = modules;&#125;)(); 首先在外部cordova环境中定义require和define两个变量，用来存储实现导入功能的函数和实现注册功能的函数。然后用一个立即调用的匿名函数来实例化这两个变量，在这个匿名函数内部，缓存了所有的功能模块。注册模块时，如果已经注册了，就直接抛出异常，防止无意中重定义，如确实需要重定义，可先调用define.remove。 从内部私有函数build中，可以看出，调用工厂函数时， factory(localRequire, module.exports, module);第一个参数localRequire实质还是调用全局的require()函数，只是把ID稍微加工了一下支持相对路径。cordova.js没有用到相对路径的require，但在一些Plugin的js中有，比如Contact.js 中 ContactError = require(&#39;./ContactError&#39;); 这里我们写个测试用例：12345678910111213141516171819&lt;script src=\"module.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; define('plugin.first', function (require, exports, module) &#123; module.exports = &#123; name: 'first plugin', show: function () &#123; console.log(\"call \"+this.name); &#125; &#125; &#125;); define('plugin.second', function (require, exports, module) &#123; var first = require(\"plugin.first\"); first.show(); &#125;); require(\"plugin.second\"); // call first plugin&lt;/script&gt; 注：module.js为上述cordova的模块代码。 上面例子中我们定义了两个模块，这里是写在同一个页面下，在实际中我们自然希望写在两个不同的文件中，然后按需加载。我们上一篇文章中说明了cordova的插件使用方法，我们会发现cordova_plugins.js中定义了cordova插件的id、路径等变量，并且该文件定义了一个id为cordova/plugin_list的模块，我们在cordova.js中可以看到有这个模块的引用。 定义了require和define并赋值后，是将cordova所有模块一一注册，例如：123define(\"cordova\",function(require,exports,module)&#123; // 工厂函数内部实现代码&#125;); 这里需要注意的是，define只是注册模块，不会调用其factory。factory函数在这个时候并没有实际执行，而只是定义，并作为一个参数传递给define函数。所有模块注册完之后，通过：1window.cordova = require('cordova'); 导入至全局环境。 因为是注册后第一次导入，所以在执行require(&#39;cordova&#39;)时，modules[&#39;cordova&#39;].factory的值是注册时的工厂函数，转变为boolean值时为true，从而在这里会通过build调用这个工厂函数，并将这个工厂函数从注册缓存里面删除，接下来的就是去执行cordova的这个factory函数了。 事件通道作为观察者模式(Observer)的一种变形，很多MV*框架（比如：Vue.js、Backbone.js）中都提供发布/订阅模型来对代码进行解耦。cordova.js中也提供了一个自定义的pub-sub模型，基于该模型提供了一些事件通道，用来控制通道中的事件什么时候以什么样的顺序被调用，以及各个事件通道的调用。 src/common/channel.js的代码结构也是一个很经典的定义结构（构造函数、实例、修改函数原型共享实例方法），它提供事件通道上事件的订阅（subscribe）、撤消订阅（unsubscribe）、调用（fire）。pub-sub模型用于定义和控制对cordova初始化的事件的触发以及此后的自定义事件。 页面加载和Cordova启动期间的事件顺序如下： onDOMContentLoaded ——（内部事件通道）页面加载后DOM解析完成 onNativeReady ——（内部事件通道）Cordova的native准备完成 onCordovaReady ——（内部事件通道）所有Cordova的JavaScript对象被创建完成可以开始加载插件 onDeviceReady —— Cordova全部准备完成 onResume —— 应用重新返回前台 onPause —— 应用暂停退到后台 可以通过下面的事件进行监听：123document.addEventListener(\"deviceready\", myDeviceReadyListener, false);document.addEventListener(\"resume\", myResumeListener, false);document.addEventListener(\"pause\", myPauseListener, false); DOM生命周期事件应用于保存和恢复状态： window.onload window.onunload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224define(\"cordova/channel\", function(require, exports, module) &#123; var utils = require('cordova/utils'), nextGuid = 1; // 事件通道的构造函数 var Channel = function(type, sticky) &#123; // 通道名称 this.type = type; // 通道上的所有事件处理函数Map（索引为guid） this.handlers = &#123;&#125;; // 通道的状态（0：非sticky, 1:sticky但未调用, 2:sticky已调用） this.state = sticky ? 1 : 0; // 对于sticky事件通道备份传给fire()的参数 this.fireArgs = null; // 当前通道上的事件处理函数的个数 this.numHandlers = 0; // 订阅第一个事件或者取消订阅最后一个事件时调用自定义的处理 this.onHasSubscribersChange = null; &#125;, // 事件通道外部接口 channel = &#123; // 把指定的函数h订阅到c的各个通道上，保证h在每个通道的最后被执行 join: function(h, c) &#123; var len = c.length, i = len, f = function() &#123; if (!(--i)) h(); &#125;; for (var j=0; j&lt;len; j++) &#123; if (c[j].state === 0) &#123; throw Error('Can only use join with sticky channels.'); &#125; c[j].subscribe(f); &#125; if (!len) h(); &#125;, // 创建事件通道 create: function(type) &#123; return channel[type] = new Channel(type, false); &#125;, // 创建sticky事件通道 createSticky: function(type) &#123; return channel[type] = new Channel(type, true); &#125;, // 保存deviceready事件之前要调用的事件 deviceReadyChannelsArray: [], deviceReadyChannelsMap: &#123;&#125;, // 设置deviceready事件之前必须要完成的事件 waitForInitialization: function(feature) &#123; if (feature) &#123; var c = channel[feature] || this.createSticky(feature); this.deviceReadyChannelsMap[feature] = c; this.deviceReadyChannelsArray.push(c); &#125; &#125;, // 初始化代码已经完成 initializationComplete: function(feature) &#123; var c = this.deviceReadyChannelsMap[feature]; if (c) &#123; c.fire(); &#125; &#125; &#125;; // 校验事件处理函数 function checkSubscriptionArgument(argument) &#123; if (typeof argument !== \"function\" &amp;&amp; typeof argument.handleEvent !== \"function\") &#123; throw new Error( \"Must provide a function or an EventListener object \" + \"implementing the handleEvent interface.\" ); &#125; &#125; /** * 向事件通道订阅事件处理函数(subscribe部分） * f:事件处理函数 c:事件的上下文 */ Channel.prototype.subscribe = function(eventListenerOrFunction, eventListener) &#123; // 校验事件处理函数 checkSubscriptionArgument(eventListenerOrFunction); var handleEvent, guid; if (eventListenerOrFunction &amp;&amp; typeof eventListenerOrFunction === \"object\") &#123; // 接收到一个实现handleEvent接口的EventListener对象 handleEvent = eventListenerOrFunction.handleEvent; eventListener = eventListenerOrFunction; &#125; else &#123; // 接收到处理事件的回调函数 handleEvent = eventListenerOrFunction; &#125; // 如果是被订阅过的sticky事件，就直接调用 if (this.state == 2) &#123; handleEvent.apply(eventListener || this, this.fireArgs); return; &#125; guid = eventListenerOrFunction.observer_guid; // 如果事件有上下文，要先把事件函数包装一下带上上下文 if (typeof eventListener === \"object\") &#123; handleEvent = utils.close(eventListener, handleEvent); &#125; // 自增长的ID if (!guid) &#123; guid = '' + nextGuid++; &#125; // 把自增长的ID反向设置给函数，以后撤消订阅或内部查找用 handleEvent.observer_guid = guid; eventListenerOrFunction.observer_guid = guid; // 判断该guid索引的事件处理函数是否存在（保证订阅一次） if (!this.handlers[guid]) &#123; // 订阅到该通道上（索引为guid） this.handlers[guid] = handleEvent; // 通道上的事件处理函数的个数增1 this.numHandlers++; if (this.numHandlers == 1) &#123; // 订阅第一个事件时调用自定义的处理（比如：第一次按下返回按钮提示“再按一次...”） this.onHasSubscribersChange &amp;&amp; this.onHasSubscribersChange(); &#125; &#125; &#125;; /** * 撤消订阅通道上的某个函数（guid） */ Channel.prototype.unsubscribe = function(eventListenerOrFunction) &#123; // 事件处理函数校验 checkSubscriptionArgument(eventListenerOrFunction); var handleEvent, guid, handler; if (eventListenerOrFunction &amp;&amp; typeof eventListenerOrFunction === \"object\") &#123; // 接收到一个实现handleEvent接口的EventListener对象 handleEvent = eventListenerOrFunction.handleEvent; &#125; else &#123; // 接收到处理事件的回调函数 handleEvent = eventListenerOrFunction; &#125; // 事件处理函数的guid索引 guid = handleEvent.observer_guid; // 事件处理函数 handler = this.handlers[guid]; if (handler) &#123; // 从该通道上撤消订阅（索引为guid） delete this.handlers[guid]; // 通道上的事件处理函数的个数减1 this.numHandlers--; if (this.numHandlers === 0) &#123; // 撤消订阅最后一个事件时调用自定义的处理 this.onHasSubscribersChange &amp;&amp; this.onHasSubscribersChange(); &#125; &#125; &#125;; /** * 调用所有被发布到该通道上的函数 */ Channel.prototype.fire = function(e) &#123; var fail = false, fireArgs = Array.prototype.slice.call(arguments); // sticky事件被调用时，标示为已经调用过 if (this.state == 1) &#123; this.state = 2; this.fireArgs = fireArgs; &#125; if (this.numHandlers) &#123; // 把该通道上的所有事件处理函数拿出来放到一个数组中 var toCall = []; for (var item in this.handlers) &#123; toCall.push(this.handlers[item]); &#125; // 依次调用通道上的所有事件处理函数 for (var i = 0; i &lt; toCall.length; ++i) &#123; toCall[i].apply(this, fireArgs); &#125; // sticky事件是一次性全部被调用的，调用完成后就清空 if (this.state == 2 &amp;&amp; this.numHandlers) &#123; this.numHandlers = 0; this.handlers = &#123;&#125;; this.onHasSubscribersChange &amp;&amp; this.onHasSubscribersChange(); &#125; &#125; &#125;; /** * 创建事件通道（publish部分） */ //（内部事件通道）页面加载后DOM解析完成 channel.createSticky('onDOMContentLoaded'); //（内部事件通道）Cordova的native准备完成 channel.createSticky('onNativeReady'); //（内部事件通道）所有Cordova的JavaScript对象被创建完成可以开始加载插件 channel.createSticky('onCordovaReady'); //（内部事件通道）所有自动load的插件js已经被加载完成（待删除） channel.createSticky('onPluginsReady'); // Cordova全部准备完成 channel.createSticky('onDeviceReady'); // 应用重新返回前台 channel.create('onResume'); // 应用暂停退到后台 channel.create('onPause'); // 设置deviceready事件之前必须要完成的事件 channel.waitForInitialization('onCordovaReady'); channel.waitForInitialization('onDOMContentLoaded'); module.exports = channel;&#125;); 我们可以写一个测试用例：12345678910&lt;script src=\"channel.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var test = channel.create('onTest'); // 订阅事件（此处test = channel.onTest） test.subscribe(function () &#123; console.log('test fire'); &#125;); // 触发事件（此处test = channel.onTest） test.fire();&lt;/script&gt; 但是很多时候我们希望能够传递参数，通过阅读上面的源码可以得知：12345678if (eventListenerOrFunction &amp;&amp; typeof eventListenerOrFunction === \"object\") &#123; // 接收到一个实现handleEvent接口的EventListener对象 handleEvent = eventListenerOrFunction.handleEvent; eventListener = eventListenerOrFunction;&#125; else &#123; // 接收到处理事件的回调函数 handleEvent = eventListenerOrFunction;&#125; 我们上面的例子中我们传递的是一个方法，这里我们也可以传递一个EventListener对象。1234567891011121314151617// 创建事件通道channel.create('onTest');// 订阅事件channel.onTest.subscribe(function (event) &#123; console.log(event); console.log(event.data.name+' fire');&#125;);// 创建 Event 对象var event = document.createEvent('Events');// 初始化事件event.initEvent('onTest', false, false);// 绑定数据event.data = &#123;name: 'test'&#125;;// 触发事件channel.onTest.fire(event); 工具模块我们在写插件的时候如果熟悉cordova自带的工具函数，可以更加方便的拓展自己的插件。 123456789101112131415161718192021222324252627282930define(\"cordova/utils\", function(require, exports, module) &#123; var utils = exports; // 定义对象属性（或方法）的setter/getter utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) &#123;...&#125; // 定义对象属性（或方法）的getter utils.defineGetter = utils.defineGetterSetter; // Array IndexOf 方法 utils.arrayIndexOf = function(a, item) &#123;...&#125; // Array remove 方法 utils.arrayRemove = function(a, item) &#123;...&#125; // 类型判断 utils.typeName = function(val) &#123;...&#125; // 数组判断 utils.isArray = Array.isArray || function(a) &#123;return utils.typeName(a) == 'Array';&#125;; // Date判断 utils.isDate = function(d) &#123;...&#125; // 深度拷贝 utils.clone = function(obj) &#123;...&#125; // 函数包装调用 utils.close = function(context, func, params) &#123;...&#125; // 内部私有函数，产生随机数 function UUIDcreatePart(length) &#123;...&#125; // 创建 UUID (通用唯一识别码) utils.createUUID = function() &#123;...&#125; // 继承 utils.extend = (function() &#123;...&#125; // 调试 utils.alert = function(msg) &#123;...&#125;&#125;); UUIDcreatePart函数用来随机产生一个16进制的号码，接受一个表示号码长度的参数（实际上是最终号码长度的一半），一般用途是做为元素的唯一ID。 utils.isArray 在这里不使用instanceof来判断是不是Array类型，主要是考虑到跨域或者多个frame的情况，多个frame时每个frame都会有自己的Array构造函数，从而得出不正确的结论。使用’[object Array]’来判断是根据ECMA标准中的返回值来进行的，事实上，这里不需要类型转换，而可以用全等“===”来判断。 utils.close函数，封装函数的调用，将执行环境作为一个参数，调用的函数为第二个参数，调用函数本身的参数为后续参数。 原型继承实现详解 123456789101112utils.extend = (function() &#123; // proxy used to establish prototype chain var F = function() &#123;&#125;; // extend Child from Parent return function(Child, Parent) &#123; F.prototype = Parent.prototype; Child.prototype = new F(); Child.__super__ = Parent.prototype; Child.prototype.constructor = Child; &#125;;&#125;()); 这里的继承是通过原型链的方式实现，我们可以通过下述方式调用：1234567891011121314var Parent = function () &#123; this.name = 'Parent';&#125;Parent.prototype.getName = function () &#123; return this.name;&#125;var Child = function () &#123; this.name = 'Child';&#125;utils.extend(Child, Parent);var child = new Child();console.log(child.getName()) ES5中有一个Object.create方法，我们可以使用这个函数实现继承：12345678910111213141516171819202122232425262728// 创建一个新的对象Object.create = Object.create || function (proto) &#123; var F = function () &#123;&#125;; F.prototype = proto; return new F();&#125;// 实现继承var extend = function(Child, Parent) &#123; // 拷贝Parent原型对象 Child.prototype = Object.create(Parent.prototype); // 将Child构造函 Child.prototype.constructor = Child;&#125;// 实例var Parent = function () &#123; this.name = 'Parent';&#125;Parent.prototype.getName = function () &#123; return this.name;&#125;var Child = function () &#123; this.name = 'Child';&#125;extend(Child, Parent);var child = new Child();console.log(child.getName()) 原型链的概念对于初学者而言可能有点绕，但是我们把握构造函数、实例化对象、原型对象三者的关系就很简单了。我们以此为例说明：12345678910// 构造函数var Child = function () &#123; this.name = 'Child';&#125;// 原型对象Child.prototypeChild.prototype.getName = function () &#123; return this.name;&#125;// 实例化对象var child = new Child(); 原型对象是构造函数的prototype属性，是所有实例化对象共享属性和方法的原型对象。 实例化对象通过new构造函数得到，都继承了原型对象的属性和方法。 如何访（qiu）问（jie）原型对象？若已知构造函数Child，则可以通过Child.prototype得到；若已知实例化对象child，则可以通过child.__proto__或者Object.getPrototypeOf(child)得到，也通过Object.setPrototypeOf方法来重写对象的原型。 12Child.prototype === child.__proto__ // truechild.__proto__ === Object.getPrototypeOf(child) // true 原型对象中有个隐式的constructor，指向了构造函数本身，也就是我们可以通过Child.prototype.constructor（虽然看似多此一举，但是经常需要重新设置构造函数）或child.__proto__.constructor或者Object.getPrototypeOf(child).constructor得到构造函数。 instanceof和Object.isPrototypeOf()可以判断两个对象是否是继承关系12child instanceof Child // trueChild.prototype.isPrototypeOf(child) // true 至此构造函数、实例化对象、原型对象三者的关系我们已经很清除了，再回过头看看上面继承的实现就很简单了。 我们可以通过instanceof来检验是否满足继承关系：1child instanceof Child &amp;&amp; child instanceof Parent // true 其实上述继承的思路很简单：1.首先获得父类原型对象的方法，这里的F对象作为中间变量引用拷贝Parent.prototype对象（即和Parent.prototype共享同一内存空间）；例如我们修改上述的Object.create为：12345678Object.create = function (proto) &#123; var F = function () &#123;&#125;; F.prototype = proto; F.prototype.setName = function(name)&#123; this.name = name; &#125; return new F();&#125; 此时Parent.prototype、Child.prototype、child都拥有的setName方法，但是我们应当避免这样做，这也是为什么我们不直接通过Child.prototype = Parent.prototype获得；通过实例化中间对象F间接得到Parent.prototype的方法，此时通过Object.create方法获得的对象和Parent.prototype不再是共享内存空间。Child通过extend(Child, Parent)从Parent.prototype对象获得一份新的拷贝。实质是因为我们通过new一个构造函数获得的实例化对象是获得了一个新的内存空间，子对象互不影响；2.对子类进行修正，我们通过拷贝获得了父类的一个备份，此时子类原型对象下的constructor属性依然是父类的构造函数，显然不符合我们的要求，我们需要重置，同时有时候我们希望保留对父类的引用，如cordova这里用一个__super__属性保存。12Child.__super__ = Parent.prototype;Child.prototype.constructor = Child; 其实继承的本质我们是希望能实现以下功能： 父类有的我都有，我也能重载，但不至于影响到父类的属性和方法 除了继承之外，我也能添加自己的方法和属性 我们可以利用es6新特性实现同样的效果：123456789101112131415161718class Parent &#123; constructor () &#123; this.name = 'Parent'; &#125; getName () &#123; return this.name; &#125;&#125;class Child extends Parent &#123; constructor () &#123; super(); this.name = 'Child'; &#125;&#125;var child = new Child();console.log(child.getName()) super关键字在这里表示父类的构造函数，用来新建父类的this对象。在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 cordova 模块本文最后一部分我们来看看cordova模块，cordova模块是事件的处理和回调，外部访问cordova.js的入口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950define(\"cordova\", function(require, exports, module) &#123; if (window.cordova &amp;&amp; !(window.cordova instanceof HTMLElement)) &#123; throw new Error(\"cordova already defined\"); &#125; // 导入事件通道模块 var channel = require('cordova/channel'); // 导入平台模块 var platform = require('cordova/platform'); // 保存addEventListener、removeEventListener的原生实现 var m_document_addEventListener = document.addEventListener; var m_document_removeEventListener = document.removeEventListener; var m_window_addEventListener = window.addEventListener; var m_window_removeEventListener = window.removeEventListener; // 缓存所有的事件处理函数 var documentEventHandlers = &#123;&#125;, windowEventHandlers = &#123;&#125;; // 重新定义addEventListener、removeEventListener，方便后面注册添加pause、resume、deviceReady等事件 document.addEventListener = function(evt, handler, capture) &#123;...&#125; window.addEventListener = function(evt, handler, capture) &#123;...&#125; document.removeEventListener = function(evt, handler, capture) &#123;...&#125; window.removeEventListener = function(evt, handler, capture) &#123;...&#125; function createEvent(type, data) &#123;...&#125; var cordova = &#123; define: define, require: require, version: PLATFORM_VERSION_BUILD_LABEL, platformVersion: PLATFORM_VERSION_BUILD_LABEL, platformId: platform.id, addWindowEventHandler: function(event) &#123;...&#125;, addStickyDocumentEventHandler: function(event) &#123;...&#125;, addDocumentEventHandler: function(event) &#123;...&#125;, removeWindowEventHandler: function(event) &#123;...&#125;, removeDocumentEventHandler: function(event) &#123;...&#125;, getOriginalHandlers: function() &#123;...&#125;, fireDocumentEvent: function(type, data, bNoDetach) &#123;...&#125;, fireWindowEvent: function(type, data) &#123;...&#125;, callbackId: Math.floor(Math.random() * 2000000000), callbacks: &#123;&#125;, callbackStatus: &#123;&#125;, callbackSuccess: function(callbackId, args) &#123;...&#125;, callbackError: function(callbackId, args) &#123;...&#125;, callbackFromNative: function(callbackId, isSuccess, status, args, keepCallback) &#123;...&#125;, addConstructor: function(func) &#123;...&#125; &#125; // 暴露cordova对象给外部 module.exports = cordova;&#125;); 这里我们以document Event为例说明一下cordova模块中关于事件的处理：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 保存addEventListener、removeEventListener的原生实现var m_document_addEventListener = document.addEventListener;var m_document_removeEventListener = document.removeEventListener;// 缓存事件处理函数var documentEventHandlers = &#123;&#125;;// 重新定义addEventListenerdocument.addEventListener = function(evt, handler, capture) &#123; var e = evt.toLowerCase(); if (typeof documentEventHandlers[e] != 'undefined') &#123; documentEventHandlers[e].subscribe(handler); &#125; else &#123; m_document_addEventListener.call(document, evt, handler, capture); &#125;&#125;;// 重新定义removeEventListenerdocument.removeEventListener = function(evt, handler, capture) &#123; var e = evt.toLowerCase(); // If unsubscribing from an event that is handled by a plugin if (typeof documentEventHandlers[e] != \"undefined\") &#123; documentEventHandlers[e].unsubscribe(handler); &#125; else &#123; m_document_removeEventListener.call(document, evt, handler, capture); &#125;&#125;;// 创建 Event 对象function createEvent(type, data) &#123; var event = document.createEvent('Events'); event.initEvent(type, false, false); if (data) &#123; for (var i in data) &#123; if (data.hasOwnProperty(i)) &#123; event[i] = data[i]; &#125; &#125; &#125; return event;&#125;var codova = &#123; ... // 创建事件通道 addStickyDocumentEventHandler:function(event) &#123; return (documentEventHandlers[event] = channel.createSticky(event)); &#125;, addDocumentEventHandler:function(event) &#123; return (documentEventHandlers[event] = channel.create(event)); &#125;, // 取消事件通道 removeDocumentEventHandler:function(event) &#123; delete documentEventHandlers[event]; &#125;, // 发布事件消息 fireDocumentEvent: function(type, data, bNoDetach) &#123; var evt = createEvent(type, data); if (typeof documentEventHandlers[type] != 'undefined') &#123; if( bNoDetach ) &#123; documentEventHandlers[type].fire(evt); &#125; else &#123; setTimeout(function() &#123; // Fire deviceready on listeners that were registered before cordova.js was loaded. if (type == 'deviceready') &#123; document.dispatchEvent(evt); &#125; documentEventHandlers[type].fire(evt); &#125;, 0); &#125; &#125; else &#123; document.dispatchEvent(evt); &#125; &#125;, ...&#125;module.exports = cordova; 在初始化启动模块cordova/init中有这样的代码：1234567891011121314151617181920212223242526272829// 注册pause、resume、deviceReady事件channel.onPause = cordova.addDocumentEventHandler('pause');channel.onResume = cordova.addDocumentEventHandler('resume');channel.onActivated = cordova.addDocumentEventHandler('activated');channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');// 监听DOMContentLoaded事件并发布事件消息if (document.readyState == 'complete' || document.readyState == 'interactive') &#123; channel.onDOMContentLoaded.fire();&#125; else &#123; document.addEventListener('DOMContentLoaded', function() &#123; channel.onDOMContentLoaded.fire(); &#125;, false);&#125;// 原生层加载完成事件if (window._nativeReady) &#123; channel.onNativeReady.fire();&#125;// 加载完成发布时间事件消息channel.join(function() &#123; modulemapper.mapModules(window); platform.initialize &amp;&amp; platform.initialize(); channel.onCordovaReady.fire(); channel.join(function() &#123; require('cordova').fireDocumentEvent('deviceready'); &#125;, channel.deviceReadyChannelsArray);&#125;, platformInitChannelsArray); 这里通过addDocumentEventHandler及addStickyDocumentEventHandler创建了事件通道，并通过fireDocumentEvent或者fire发布事件消息，这样我们就可以通过document.addEventListener订阅监听事件了。 如果我们要创建一个自定义事件Test,我们可以这样做：123456789101112131415// 创建事件通道cordova.addWindowEventHandler('Test');// 发布事件消息cordova.fireWindowEvent('Test', &#123; name: 'test', data: &#123; time: new Date() &#125;&#125;)// 订阅事件消息window.addEventListener('Test', function (evt) &#123; console.log(evt);&#125;); 参考Cordova 3.x 入门 - 目录PhoneGap源码分析 写在后面本文至此已经说完了cordova的模块机制和事件机制，已经cordova的工具模块，了解这些后写起插件来才能得心应手，对于原理实现部分不属于本文的范畴，下一篇会详细讲解cordova原理实现。敬请关注，不过近来在写毕设，估计一时半会儿也不会写完，本文前前后后已是拖了半个月。如果觉得本文对您有帮助，不妨打赏支持。","categories":[{"name":"hybrid App深入浅出研究","slug":"hybrid-App深入浅出研究","permalink":"https://zhaomenghuan.github.io/categories/hybrid-App深入浅出研究/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"https://zhaomenghuan.github.io/tags/cordova/"},{"name":"hybrid App","slug":"hybrid-App","permalink":"https://zhaomenghuan.github.io/tags/hybrid-App/"}]},{"title":"cordova研习笔记(一) —— 初试牛刀之cordova.js概要","slug":"cordova研习笔记(一) ——初试牛刀之cordova.js概要","date":"2017-04-25T16:00:00.000Z","updated":"2017-05-07T12:21:31.942Z","comments":true,"path":"2017/04/26/cordova研习笔记(一) ——初试牛刀之cordova.js概要/","link":"","permalink":"https://zhaomenghuan.github.io/2017/04/26/cordova研习笔记(一) ——初试牛刀之cordova.js概要/","excerpt":"","text":"前言来新公司的第一个任务，研究hybrid App中间层实现原理，做中间层插件开发。这个任务挺有意思，也很有挑战性，之前在DCloud虽然做过5+ App开发，但是中间层的东西确实涉及不多。本系列文章属于系列开篇cordova学习笔记，本文主要是从零开始搭建一个cordova工程，并了解cordova开发的基本内容。 创建第一个AppApache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等。 cordova应用架构 Cordova官网：http://cordova.apache.org/Cordova中文网：http://cordova.axuer.com/Cordova中文站：http://www.cordova.org.cn/ 1.安装 Cordova CLI1npm install -g cordova 安装完成可以通过cordova -v查看版本号，本文是在V6.5.0下构建。 2.新建项目1cordova create &lt;PATH&gt; [ID [NAME [CONFIG]]] [options] Create a Cordova project： PATH —— 项目路径 ID —— app 包名 - used in NAME —— app 名称 CONFIG —— 配置文件地址 json string whose key/values will be included in [PATH]/.cordova/config.json Options： –template= … use a custom template located locally, in NPM, or GitHub. –copy-from|src= ……………… deprecated, use –template instead. –link-to= …………………… symlink to custom www assets without creating a copy. Example：1cordova create hello-cordova io.zhaomenghuan HelloCordova 这将会为你的cordova应用创造必须的目录。默认情况下，cordova create命令生成基于web的应用程序的骨骼，项目的主页是 www/index.html 文件。 {% image http://upload-images.jianshu.io/upload_images/1945738-d58f8fe035702f11.png '图为创建好的项目' '' %} 3.添加平台 所有后续命令都需要在项目目录或者项目目录的任何子目录运行：1cd hello-cordova 给你的App添加目标平台。我们将会添加ios和android平台，并确保他们保存在了config.xml中：12cordova platform add ios --savecordova platform add android --save 运行add或者remove平台的命令将会影响项目platforms的内容，在这个目录中每个指定平台都有一个子目录。 注意：在你使用CLI创建应用的时候， 不要 修改/platforms/目录中的任何文件。当准备构建应用或者重新安装插件时这个目录通常会被重写。 检查你当前平台设置状况：123456789101112cordova platform isInstalled platforms: android 6.1.2Available platforms: amazon-fireos ~3.6.3 (deprecated) blackberry10 ~3.8.0 browser ~4.1.0 firefoxos ~3.6.3 webos ~3.7.0 windows ~4.4.0 wp8 ~3.8.2 (deprecated) 安装构建先决条件：要构建和运行App，你需要安装每个你需要平台的SDK。另外，当你使用浏览器开发你可以添加 browser平台，它不需要任何平台SDK。 检测你是否满足构建平台的要求：1234567cordova requirementsRequirements check results for android:Java JDK: installed 1.8.0Android SDK: installed trueAndroid target: installed android-7,android-8,android-9,android-10,android-11,android-12,android-13,android-14,android-15,android-16,android-17,android-18,android-19,android-20,android-21,android-22,android-23,android-24,android-25Gradle: installed 初次使用我们可能会遇到下面的报错：12Error: Failed to find &apos;ANDROID_HOME&apos; environment variable. Try setting setting it manually.Failed to find &apos;android&apos; command in your &apos;PATH&apos;. Try update your &apos;PATH&apos; to include path to valid SDK directory. 这是因为我们没有配置环境变量： 设置JAVA_HOME环境变量，指定为JDK安装路径 设置ANDROID_HOME环境变量，指定为Android SDK安装路径 添加Android SDK的tools和platform-tools目录到你的PATH 对于android平台下的环境配置在这里不再赘述，具体可以参考： Android平台的要求 iOS平台的要求 Windows平台的要求 4.构建App 默认情况下, cordova create生产基于web应用程序的骨架，项目开始页面位于www/index.html 文件。任何初始化任务应该在www/js/index.js文件中的deviceready事件的事件处理函数中。 运行下面命令为所有添加的平台构建：1cordova build 你可以在每次构建中选择限制平台范围 - 这个例子中是android：1cordova build android 注意：首次使用时，命令行提示 Downloading https://services.gradle.org/distributions/gradle-2.14.1-all.zip，是在下载对应的gradle并自动解压安装，根据网络状况，可能耗时极长，且容易报错。 使用Cordova编译Android平台程序提示：Could not reserve enough space for 2097152KB object heap。12Error occurred during initialization of VMCould not reserve enough space for 2097152KB object heap 大体的意思是系统内存不够用，创建VM失败。试了网上好几种方法都不行，最后这个方法可以了： 开始-&gt;控制面板-&gt;系统-&gt;高级设置-&gt;环境变量-&gt;系统变量新建变量：变量名: _JAVA_OPTIONS变量值: -Xmx512M 5.运行App 我们有多种方式运行我们的App，在不同场景下使用不同的方式有助于我们快速开发和测试我们的应用。 在命令行运行下面的命令，会重新构建App并可以在特定平台的模拟器上查看：1cordova emulate android 你可以将你的手机插入电脑，在手机上直接测试App：1cordova run android 在进行打包操作前，我们可以通过创建一个本地服务预览app UI，使用指定的端口或缺省值为8000运行本地Web服务器www/assets。访问项目：http://HOST_IP:PORT/PLATFORM/www。1cordova serve [port] 参考文档： 设置Android模拟器 Cordova run 命令参考文档 Cordova emulate 命令参考文档 6.安装插件 cordova的强大之处在于我们可以通过安装插件，拓展我们web工程的能力，比如调用系统底层API来调用设备上的底层功能，如摄像头、相册。通过cordova plugin命令实现插件管理。 可以在这里搜索需要的插件：Cordova Plugins 。 1234567cordova &#123;plugin | plugins&#125; [ add &lt;plugin-spec&gt; [..] &#123;--searchpath=&lt;directory&gt; | --noregistry | --link | --save | --browserify | --force&#125; | &#123;remove | rm&#125; &#123;&lt;pluginid&gt; | &lt;name&gt;&#125; --save | &#123;list | ls&#125; | search [&lt;keyword&gt;] | save |] 添加插件：1cordova plugin add &lt;plugin-spec&gt; [...] 移除插件：1cordova plugin remove [...] 7.平台为中心的工作流开发App 上面我们是在跨平台(CLI)的工作流进行，原则上如果我们不需要自己写原生层自定义组件，我们完全可以只在CLI上完成我们的工作，当然如果需要进一步深入了解cordova native与js的通信联系，我们需要切换到平台为中心的工作流，即将我们的cordova工程导入到原生工程。例如：我们可以使用android studio导入我们新建的cordova工程。 自定义插件开发官方推荐的插件遵循相同的目录结构，根目录下是plugin.xml配置文件，src目录下放平台原生代码，www下放js接口代码，基本配置方法和代码结构由一定规律，我们使用plugman可以生成一个插件模板，改改就可以写一个自定义插件。 1.安装 plugman ，使用 plugman 创建插件模板1npm install -g plugman 比如这里我们创建一个nativeUI的插件：1plugman create --name NativeUI --plugin_id cordova-plugin-nativeui --plugin_version 0.0.1 参数介绍：pluginName: 插件名字：NativeUIpluginID: 插件id : cordova-plugin-nativeuioversion: 版本 : 0.0.1directory:一个绝对或相对路径的目录，该目录将创建插件项目variable NAME=VALUE: 额外的描述，如作者信息和相关描述 进入插件目录1cd NativeUI 给 plugin.xml 增加Android平台1plugman platform add --platform_name android 生成的插件文件结构为：12345678NativeUI：├── src └── android └── NativeUI.java├── www └── NativeUI.js└── plugin.xml 2.修改配置文件 plugin.xml文件字段含义： 元素 描述 plugin 定义命名空间，ID和插件版本。应该用定义在http://apache.org/cordova/ns/plugins/1.0命名空间。plugin的ID在输入cordova plugins命令时在插件列表中显示。 name 定义插件的名字。 description 定义插件的描述信息。 author 定义插件作者的名字。 keywords 定义与插件相关的关键字。Cordova研发组建立了公开、可搜索的插件仓库，添加的关键字能在你把插件提交到仓库后帮助被发现。 license 定义插件的许可。 engines 用来定义插件支持的Cordova版本。再添加engine元素定义每个支持的Cordova版本。 js-module 指js文件名，而这个文件会自动以&lt;script&gt;标签的形式添加到Cordova项目的起始页。通过在js-module中列出插件，可以减少开发者的工作。 info 它是另一个除了description外说插件信息的地方。 12345678910111213141516&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;plugin id=&quot;cordova-plugin-nativeui&quot; version=&quot;0.0.1&quot; xmlns=&quot;http://apache.org/cordova/ns/plugins/1.0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;name&gt;NativeUI&lt;/name&gt; &lt;js-module name=&quot;NativeUI&quot; src=&quot;www/NativeUI.js&quot;&gt; &lt;clobbers target=&quot;agree.nativeUI&quot; /&gt; &lt;/js-module&gt; &lt;platform name=&quot;android&quot;&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;res/xml/config.xml&quot;&gt; &lt;feature name=&quot;NativeUI&quot;&gt; &lt;param name=&quot;android-package&quot; value=&quot;cn.com.agree.nativeui.NativeUI&quot; /&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;AndroidManifest.xml&quot;&gt;&lt;/config-file&gt; &lt;source-file src=&quot;src/android/NativeUI.java&quot; target-dir=&quot;src/cn/com/agree/nativeui&quot; /&gt; &lt;/platform&gt;&lt;/plugin&gt; 这个配置文件有几个地方很关键，一开始没有认真看，将插件导进工程跑的时候各种问题，十分头痛，不得不重新认真看看plugin.xml文档。 id：原则上没有严格规定，参考官方插件写法，这里我也写的是cordova-plugin-nativeui，通过plugman创建插件模板的时候需要指定。 name：插件名称。 clobbers-&gt;target：用于指定插入module.exports的窗口对象下的命名空间，也就是用户调用该插件时的js层暴露的顶层对象。这个很关键，虽然可以任意指定，但是涉及到我们调用插件的属性或者方法，所以需要特别关注。plugman默认生成的是将id中的-转换成`.’的对象。这里需要说明的是我们可以写多个js-module，每个js-module下可以指定不同的clobbers。 feature -&gt; param - &gt; value 标识了实际提供服务的Native类别名称，这里直接定位至具体类，然而上述通过plugman生成模板的时候中没有指定NativeUI的包名，会自定生成cordova-plugin-nativeui.NativeUI，这里我们需要改成符合自己要求的类名，如我这里使用公司的域名：cn.com.agree.nativeui.NativeUI。需要说明的是这里的类名可以与插件名称不同。 source-file -&gt; target-dir 同理target-dir需要修改为： src/cn/com/agree/nativeui，同时需要修改平台下的native部分的代码：如：package cn.com.agree.nativeui; platform -&gt; config-file下可以指定程序所需的权限uses-permission，如：123&lt;config-file target=&quot;AndroidManifest.xml&quot; parent=&quot;/*&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;/config-file&gt; 3.导入到平台工程中的目录结构 这里我们以android平台为例： cordova.js在创建Android工程的时候，是从cordova的lib目录下Copy到platforms\\android\\assets\\www\\cordova.js的。同时备份到platforms\\android\\platform_www\\cordova.js。下一篇文章我会试着读一下cordova.js的源码，这里对cordova.js暂不做深入探究。 这里我们主要关心几个地方，我们的原生代码在src目录下，assets/www目录下是我们的web 程序。www目录下的plugins文件夹就是我们的插件js部分，cordova_plugins.js是根据plugins文件夹的内容生成的。 cordova_plugins.js的整体结构：1234567891011121314151617181920cordova.define(&apos;cordova/plugin_list&apos;, function(require, exports, module) &#123;module.exports = [ &#123; &quot;id&quot;: &quot;cordova-plugin-nativeui.NativeUI&quot;, &quot;file&quot;: &quot;plugins/cordova-plugin-nativeui/www/NativeUI.js&quot;, &quot;pluginId&quot;: &quot;cordova-plugin-nativeui&quot;, &quot;clobbers&quot;: [ &quot;agree.nativeUI&quot; ] &#125;, ...];module.exports.metadata = // TOP OF METADATA&#123; &quot;cordova-plugin-nativeui&quot;: &quot;0.0.1&quot;, ...&#125;;// BOTTOM OF METADATA&#125;); Android插件开发指南Android插件基于Cordova-Android，它是基于具有Javscript-to-native桥接的Android WebView构建的。 Android插件的本机部分至少包含一个扩展CordovaPlugin类的Java类，并重写其一个执行方法。 插件类映射 插件的JavaScript接口使用cordova.exec方法，如下所示：1cordova.exec(&lt;successFunction&gt;, &lt;failFunction&gt;, &lt;service&gt;, &lt;action&gt;, [&lt;args&gt;]); function(winParam) {}: 成功回调 function(error) {}: 错误回调 “service”: 原生层服务名称 “action”: js层调用方法名 [arguments]: js层传递到原生层的数据 这将WebView的请求传递给Android本机端，有效地在服务类上调用action方法，并在args数组中传递其他参数。无论您将插件分发为Java文件还是作为自己的jar文件，必须在Cordova-Android应用程序的res / xml / config.xml文件中指定该插件。 有关如何使用plugin.xml文件注入此要素的详细信息，请参阅应用程序插件：123&lt;feature name=&quot;&lt;service_name&gt;&quot;&gt; &lt;param name=&quot;android-package&quot; value=&quot;&lt;full_name_including_namespace&gt;&quot; /&gt;&lt;/feature&gt; 插件初始化及其生命周期 一个插件对象的一个实例是为每个WebView的生命创建的。 插件不会被实例化，直到它们被JavaScript的调用首次引用为止，除非在config.xml中将具有onload name属性的设置为“true”。1234&lt;feature name=&quot;Echo&quot;&gt; &lt;param name=&quot;android-package&quot; value=&quot;&lt;full_name_including_namespace&gt;&quot; /&gt; &lt;param name=&quot;onload&quot; value=&quot;true&quot; /&gt;&lt;/feature&gt; 插件使用 initialize 初始化启动：12345@Overridepublic void initialize(CordovaInterface cordova, CordovaWebView webView) &#123; super.initialize(cordova, webView); // your init code here&#125; 插件还可以访问Android生命周期事件，并可以通过扩展所提供的方法（onResume，onDestroy等）来处理它们。 具有长时间运行请求的插件，媒体播放，侦听器或内部状态等背景活动应实现onReset（）方法。 当WebView导航到新页面或刷新时，它会执行，这会重新加载JavaScript。 编写Android Java插件 一个JavaScript调用触发对本机端的插件请求，并且相应的Java插件在config.xml文件中正确映射，但最终的Android Java Plugin类是什么样的？ 使用JavaScript的exec函数发送到插件的任何东西都被传递到插件类的execute方法中。 插件的JavaScript不会在WebView界面的主线程中运行; 而是在WebCore线程上运行，执行方法也是如此。 如果需要与用户界面进行交互，应该使用Activity的runOnUiThread方法。 如果不需要在UI线程上运行，但不希望阻止WebCore线程，则应使用cordova.getThreadPool()获得的Cordova ExecutorService执行代码。 1234567891011121314151617181920212223242526272829...@Overridepublic boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException &#123; if (action.equals(&quot;toast&quot;)) &#123; this.toast(args.getString(0)); return true; &#125; return false;&#125;/** * Builds and shows a native Android toast with given Strings * * @param message The message the toast should display */private void toast(final String message) &#123; final CordovaInterface cordova = this.cordova; if (message != null &amp;&amp; message.length() &gt; 0) &#123; final int duration = Toast.LENGTH_SHORT; Runnable runnable = new Runnable() &#123; public void run() &#123; Toast toast = Toast.makeText(cordova.getActivity().getApplicationContext(), message, duration); toast.show(); &#125; &#125;; cordova.getActivity().runOnUiThread(runnable); &#125;&#125;... js部分的代码：1234567var exec = require(&apos;cordova/exec&apos;);module.exports = &#123; toast: function(message) &#123; exec(null, null, &apos;NativeUI&apos;, &apos;toast&apos;, [message]); &#125;&#125; callbackContext.success可以将原生层字符串作为参数传递给JavaScript层的成功回调，callbackContext.error可以将给JavaScript层的错误回调函数传递参数。 添加依赖库 如果你的Android插件有额外的依赖关系，那么它们必须以两种方式之一列在plugin.xml中： 首选的方法是使用标签（有关详细信息，请参阅插件规范）。以这种方式指定库可以通过Gradle的依赖管理逻辑来解决。这允许诸如gson，android-support-v4和google-play-services之类的常用库被多个插件使用而没有冲突。 第二个选项是使用标签来指定jar文件的位置（有关更多详细信息，请参阅插件规范）。 只有当您确定没有其他插件将依赖于您所引用的库（例如，该库特定于您的插件）时，才应使用此方法。 否则，如果另一个插件添加了相同的库，则可能导致插件用户造成构建错误。 值得注意的是，Cordova应用程序开发人员不一定是本地开发人员，因此本地平台构建错误可能特别令人沮丧。 Android集成 Android具有Intent系统，允许进程相互通信。插件可以访问CordovaInterface对象，可以访问运行应用程序的Android Activity。 这是启动新的Android Intent所需的上下文。 CordovaInterface允许插件为结果启动Activity，并为Intent返回应用程序时设置回调插件。 从Cordova 2.0开始，插件无法再直接访问上下文，并且旧的ctx成员已被弃用。 所有的ctx方法都存在于Context中，所以getContext()和getActivity()都可以返回所需的对象。 运行权限（Cordova-Android 5.0.0+） Android 6.0 “Marshmallow” 引入了新的权限模型，用户可以根据需要启用和禁用权限。这意味着应用程序必须将这些权限更改处理为将来，这是Cordova-Android 5.0.0发行版的重点。 就插件而言，可以通过调用权限方法来请求权限，该签名如下：1cordova.requestPermission(CordovaPlugin plugin, int requestCode, String permission); 为了减少冗长度，将此值分配给本地静态变量是标准做法：1public static final String READ = Manifest.permission.READ_CONTACTS; 定义requestCode的标准做法如下：1public static final int SEARCH_REQ_CODE = 0; 然后，在exec方法中，应该检查权限：12345if(cordova.hasPermission(READ)) &#123; search(executeArgs);&#125; else &#123; getReadPermission(SEARCH_REQ_CODE);&#125; 在这种情况下，我们只需调用requestPermission：123protected void getReadPermission(int requestCode) &#123; cordova.requestPermission(this, requestCode, READ);&#125; 这将调用该活动并引起提示出现要求该权限。 一旦用户拥有权限，结果必须使用onRequestPermissionResult方法处理，每个插件应该覆盖该方法。 一个例子可以在下面找到：12345678910111213141516171819public void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResults) throws JSONException &#123; for(int r:grantResults) &#123; if(r == PackageManager.PERMISSION_DENIED) &#123; this.callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, PERMISSION_DENIED_ERROR)); return; &#125; &#125; switch(requestCode) &#123; case SEARCH_REQ_CODE: search(executeArgs); break; case SAVE_REQ_CODE: save(executeArgs); break; case REMOVE_REQ_CODE: remove(executeArgs); break; &#125;&#125; 上面的switch语句将从提示符返回，并且根据传入的requestCode，它将调用该方法。 应该注意的是，如果执行不正确地处理权限提示可能会堆叠，并且应该避免这种情况。 除了要求获得单一权限的权限之外，还可以通过定义权限数组来请求整个组的权限，如同Geolocation插件所做的那样：1234String [] permissions = &#123; Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION &#125;; 然后当请求权限时，需要完成的所有操作如下：1cordova.requestPermissions(this, 0, permissions); 这将请求数组中指定的权限。 提供公开访问的权限阵列是一个好主意，因为可以使用插件作为依赖关系使用，尽管这不是必需的。 启动其他活动 如果你的插件启动将Cordova活动推送到后台的活动，则需要特别考虑。 如果设备运行内存不足，Android操作系统将在后台销毁活动。在这种情况下，CordovaPlugin实例也将被销毁。 如果您的插件正在等待其启动的活动的结果，则当Cordova活动返回到前台并获得结果时，将创建一个新的插件实例。 但是，插件的状态不会自动保存或恢复，插件的CallbackContext将丢失。 CordovaPlugin可以实现两种方法来处理这种情况：12345678910111213141516171819202122/** * Called when the Activity is being destroyed (e.g. if a plugin calls out to an * external Activity and the OS kills the CordovaActivity in the background). * The plugin should save its state in this method only if it is awaiting the * result of an external Activity and needs to preserve some information so as * to handle that result; onRestoreStateForActivityResult() will only be called * if the plugin is the recipient of an Activity result * * @return Bundle containing the state of the plugin or null if state does not * need to be saved */public Bundle onSaveInstanceState() &#123;&#125;/** * Called when a plugin is the recipient of an Activity result after the * CordovaActivity has been destroyed. The Bundle will be the same as the one * the plugin returned in onSaveInstanceState() * * @param state Bundle containing the state of the plugin * @param callbackContext Replacement Context to return the plugin result to */public void onRestoreStateForActivityResult(Bundle state, CallbackContext callbackContext) &#123;&#125; 总结cordova 是否能够发挥出它出彩的一面还是源于我们对原生的熟练程度，只有对原生足够熟练，对cordova的运行机制足够熟悉才能做出一个相对比较令人满意的App，后面的文章我会尝试阅读cordova的源码，深入解析cordova的实现原理和插件机制，也会教大家封装一些常用的自定义组件。本文内容基本取材于官方文档，只是借助谷歌翻译以及自己在探索过程中的一些问题，做了一些增删，如果有任何问题，希望各位不吝指教。","categories":[{"name":"hybrid App深入浅出研究","slug":"hybrid-App深入浅出研究","permalink":"https://zhaomenghuan.github.io/categories/hybrid-App深入浅出研究/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"https://zhaomenghuan.github.io/tags/cordova/"},{"name":"hybrid App","slug":"hybrid-App","permalink":"https://zhaomenghuan.github.io/tags/hybrid-App/"}]},{"title":"node学习之路（二）—— Node.js 连接 MongoDB","slug":"node学习之路（二）—Node.js 连接 MongoDB","date":"2017-04-11T16:00:00.000Z","updated":"2017-05-12T06:47:43.005Z","comments":true,"path":"2017/04/12/node学习之路（二）—Node.js 连接 MongoDB/","link":"","permalink":"https://zhaomenghuan.github.io/2017/04/12/node学习之路（二）—Node.js 连接 MongoDB/","excerpt":"","text":"前言之前对于node的学习，一直只是停留在一种帮前端打辅助的层面，没有深入去研究，是时候需要改变一下了，近来找工作诸多不顺心（找个两情相悦的真不容易啊~），多数对前端有后端语言经验和工作年限有要求，对于我这个应届生真心不是一般的尴尬，所以先继续深入学习一下node咯，本文主要记录一下学习MongoDB数据库相关的内容（属于比较流水账的文章），弥补一下自己的知识空白。这两天收到两个offer心情还是不错的，就是有点难抉择。 mongodb的安装什么是MongoDB ? MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 官网：https://www.mongodb.com/ window下mongodb的安装、启动由于暂时只有window笔记本，这里只介绍window的安装，在官网上下载zip，这个我装在E盘的mongodb目录下。安装教程及常见问题如下： Windows下面安装和使用mongodb win8 win10 安装msi 提示2502、2503的错误代码 安装完成后，我们在E:/mongodb/bin下运行mongod会报错：1-bash: mongod: command not found 这是因为我们配置环境变量，如果不想配置我们可以先使用./mongod代替，如果出现下图结果则说明安装成功。 {% image http://upload-images.jianshu.io/upload_images/1945738-180ed76e04b327b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 '' '' %} 为了启动mongodb方便，还是将mongod.exe路径加入环境变量，电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量,在path里加入路径：{% image http://upload-images.jianshu.io/upload_images/1945738-495c585f6bdd396b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 '' '' %} 我们需要给数据库指定存放目录，在E:/mongodb文件夹中创建一个 data 文件夹，再在 data 文件夹中创建 db 文件夹，在命令行执行：1mongod --dbpath E:/mongodb/data/db 其中 –dbpath是指定数据库存放目录，这里要注意有两个 “-“ 浏览器打开http://localhost:27017/,我们会看到：1It looks like you are trying to access MongoDB over HTTP on the native driver port. 至此我们已经成功启动mongodb。 MongoDB安装为Windows服务我们在E:/mongodb/data文件夹下再建立一个log文件夹，文件夹下新建一个mongodb.log文件，然后在命令行执行： 1sc create MongoDB binPath= &quot;E:\\mongodb\\bin\\mongod.exe --service --dbpath E:\\mongodb\\data\\db --logpath=E:\\mongodb\\data\\log\\mongodb.log --logappend&quot; 然后我们可以通过net start MongoDB启动MongoDB。 我们可能需要用到的三个命令： 启动MongoDB：net start MongoDB 停止MongoDB：net stop MongoDB 删除MongoDB：sc delete MongoDB 需要特别说明的是，我们需要在管理员模式下输入命令，window+x可以打开管理员命令行。window+R运行打开服务的命令：services.msc，可以打开服务设置界面查看服务相关内容。 mongodb初试安装可视化工具robomongodb在开始操作数据库之前，向大家推荐一个连接mongo的客户端可视化工具 robomongodb，它是跨平台的工具，安装后建立连接打开界面是这个样子： 接下来我们的数据操作就可以在这里查看。 MongoDB 概念解析不管我们学习什么数据库都应该学习其中的基础概念，在mongodb中基本的概念是文档、集合、数据库，下表将帮助你更容易理解Mongo中的一些概念： SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 下表列出了 RDBMS 与 MongoDB 对应的术语： RDBMS MongoDB 数据库 数据库 表格 集合 行 文档 列 字段 表联合 嵌入文档 主键 主键 (MongoDB 提供了 key 为 _id ) 数据库服务和客户端的区别： RDBMS MongoDB Mysqld/Oracle mongod mysql/sqlplus mongo 数据库一个mongodb中可以建立多个数据库。MongoDB的默认数据库为”test”，该数据库存储在data目录中。MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。 数据库通过名字来标识，数据库名可以是满足以下条件的任意UTF-8字符串： 不能是空字符串（””); 不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符); 应全部小写; 最多64字节。 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库： admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 集合集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。 合法的集合名： 集合名不能是空字符串””。 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。 集合名不能以”system.”开头，这是为系统集合保留的前缀。 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。 文档文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。文档中的键/值对是有序的。文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。MongoDB区分类型和大小写。MongoDB的文档不能有重复的键。文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。 文档键命名规范： 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。 和$有特别的意义，只有在特定环境下才能使用。 以下划线”_”开头的键是保留的(不是严格要求的)。 MongoDB 数据类型 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位 Boolean 布尔值。用于存储布尔值（真/假） Double 双精度浮点值。用于存储浮点值 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比 Arrays 用于将数组或列表或多个值存储为一个键 Timestamp 时间戳，记录文档修改或添加的具体时间 Object 用于内嵌文档 Null 用于创建空值 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息 Object ID 对象 ID。用于创建文档的 ID Binary Data 二进制数据。用于存储二进制数据 Code 代码类型。用于在文档中存储 JavaScript 代码 Regular expression 正则表达式类型。用于存储正则表达式 数据库操作我们可以通过mongodb提供的命令行工具（mongo.exe）进行数据库操作，也可以通过程序操作，这里我们先使用命令行工具熟悉基本操作，然后再使用node进行程序操作。打开安装目录bin文件夹下的mongo.exe文件： 列出所有的数据库列表 —— show dbs 命令行输入show dbs，结果如下：123&gt; show dbsadmin 0.000GBlocal 0.000GB 显示当前数据库对象或集合 —— db 执行 “db” 命令可以显示当前数据库对象或集合。12&gt; dbtest 创建数据库 —— use DATABASE_NAME MongoDB 创建数据库的语法格式如下：1use DATABASE_NAME 如果数据库不存在，则创建数据库，否则切换到指定数据库。 运行”use”命令，可以连接到一个指定的数据库。1234&gt; use localswitched to db local&gt; dblocal 新建一个数据库，要想通过show dbs展示出来，需要先插入数据。 删除数据库——db.dropDatabase() MongoDB 删除数据库的语法格式如下：1db.dropDatabase() 删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。 集合操作 创建集合 —— createCollection() MongoDB 创建集合的语法格式如下：1db.createCollection(name, options) 在命令中, name 是要创建的集合的名称. Options 是一个文件，用于指定配置的集合 参数 类型 描述 Name String 要创建的集合名称 Options Document （可选）指定有关内存大小和索引选项 选项​​参数是可选的，所以只需要到指定的集合名称。以下是可以使用的选项列表： 参数 类型 描述 capped Boolean （可选）如果为true，则启用封顶集合。封顶集合是固定大小的集合，会自动覆盖最早的条目，当它达到其最大大小。如果指定true，则需要也指定尺寸参数。 autoIndexID Boolean （可选）如果为true，自动创建索引_id字段的默认值是false。 size number （可选）指定最大大小字节封顶集合。如果封顶如果是 true，那么你还需要指定这个字段。 max number （可选）指定封顶集合允许在文件的最大数量。 当插入文档，MongoDB 第一检查大小字段封顶集合，然后它会检查最大的字段中。 createCollection() 方法不使用选项的例子如下：1db.createCollection(\"blogs\") 列出当前数据库所有的集合列表 —— show collections 12&gt; show collectionsblogs 删除集合 —— db.collection.drop() MongoDB 删除数据库的语法格式如下： 1db.COLLECTION_NAME.drop() 如果集合成功删除，drop() 方法将返回 true，否则将返回 false。 文档操作 插入文档 —— db.COLLECTION_NAME.insert(document) 或 db.COLLECTION_NAME.save(document) 1234567891011&gt; db.blogs.insert(&#123;... \"pageId\":\"20170401\",... \"pageUrl\":\"http://zhaomenghuan.github.io/#!/blog/20170401\",... \"title\":\"Angular系列学习笔记（二）—— 基于gulp构建Angular单页面应用\",... \"from\":\"原创\",... \"time\":\"2017-4-1\",... \"keyword\":[\"gulp\",\"angular\",\"angular-ui-router\",\"angular-material\"],... \"digest\":\"构建打包工具之前一直是使用 webpack（歪脖帕克，毕竟尤大推荐的工具），由于公司这边是使用gulp，为了和公司同步，私下还是要学习学习，毕竟懂点万一需要和老大交流也不至于说有啥问题，这篇文章将会以零基础的角度去写一下基于gulp搭建angular的工程，借这个机会顺便重构一下自己的博客。\"... &#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;) 这里 blogs是集合的名称，如上面的例子中创建。如果集合在数据库中不存在，那么MongoDB 将创建此集合，然后把它插入文档。插入文档中，如果我们不指定_id参数，然后MongoDB 本文档分配一个独特的ObjectId。_id 是12个字节的十六进制数，唯一一个集合中的每个文档。 12个字节被划分如下：1_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer) 要插入单个查询的多个文档，可以传递一个文件数组作为 insert() 命令的参数。 mongodb insert()和save()的相同点和区别： 若新增的数据中存在主键 ，insert() 会提示错误，而save() 则更改原来的内容为新内容。若新增的数据中没有主键时，会增加一条记录。如：已存在数据： {_id : 1, “ name “ : “ n1 “ }，再次进行插入操作时，insert({_id : 1, “ name “ : “ n2 “ }) 会报主键重复的错误提示；save({ _id : 1, “ name “ : “ n2 “ }) 会把 n1 修改为 n2 。 查询文档 —— db.COLLECTION_NAME.find() find() 方法将在非结构化的方式显示所有的文件，还有一个 findOne() 法返回一个文件。 1234&gt; db.blogs.find()&#123; \"_id\" : ObjectId(\"58ecf1a2b36ebd2cfd5321f6\"), \"pageId\" : \"20170401\", \"pageUrl\" : \"http://zhaomenghuan.github.io/#!/blog/20170401\", \"title\" : \"Angular系列学习笔记（二）—— 基于gulp构建Angular单页面应用\", \"from\" : \"原创\", \"time\" : \"2017-4-1\", \"keyword\" : [ \"gulp\", \"angular\", \"angular-ui-router\", \"angular-material\" ], \"digest\" : \"构建打包工具之前一直是使用 webpack（歪脖帕克，毕竟尤大推荐的工具），由于公司这边是使用gulp，为了和公司同步，私下还是要学习学习，毕竟懂点万一需要和老大交流也不至于说有啥问题，这篇文章将会以零基础的角度去写一下基于gulp搭建angular的工程，借这个机会顺便重构一下自己的博客。\" &#125; 如果需要格式化显示结果，可以使用pretty()方法。1db.COLLECTION_NAME.find().pretty() RDBMS Where子句和MongoDB等同语句：要查询文件的一些条件的基础上，可以使用下面的操作： 操作 语法 例子 RDBMS 等同 等于 {:} db.mycol.find({“by”:”tutorials yiibai”}).pretty() where by = ‘tutorials yiibai’ 小于 {:{$lt:}} db.mycol.find({“likes”:{$lt:50}}).pretty() where likes &lt; 50 小于或等于 {:{$lte:}} db.mycol.find({“likes”:{$lte:50}}).pretty() where likes &lt;= 50 大于 {:{$gt:}} db.mycol.find({“likes”:{$gt:50}}).pretty() where likes &gt; 50 大于或等于 {:{$gte:}} db.mycol.find({“likes”:{$gte:50}}).pretty() where likes &gt;= 50 不等于 {:{$ne:}} db.mycol.find({“likes”:{$ne:50}}).pretty() where likes != 50 注：$gt —— greater than；$gte —— greater than equal；$lt —— less than；$lte —— less than equal；$ne —— not equal AND 条件在MongoDB中用法：在 find() 方法，如果通过多个键分离’,’，那么 MongoDB 处理 AND 条件。AND 基本语法如下所示：1db.COLLECTION_NAME.find(&#123;key1:value1, key2:value2&#125;).pretty() OR 条件在MongoDB中用法：OR条件的基础上要查询文件，需要使用$or关键字。OR 基本语法如下所示：123db.COLLECTION_NAME.find(&#123; $or: [&#123;key1: value1&#125;, &#123;key2:value2&#125;]&#125;).pretty() 更新文档 —— db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA) 或 db.COLLECTION_NAME.save(document) 123456789db.COLLECTION_NAME.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的。 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 12345db.blogs.update(&#123; 'pageId':'20170401'&#125;,&#123; $set:&#123;'pageId':'2017-04-01'&#125;&#125;) save() 方法通过传入的文档来替换已有文档。语法格式如下：123456db.COLLECTION_NAME.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) 参数说明： document : 文档数据。 writeConcern :可选，抛出异常的级别。 删除文档 —— db.COLLECTION_NAME.remove(DELLETION_CRITTERIA) 1234567db.COLLECTION_NAME.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明：query :（可选）删除的文档的条件。justOne : （可选）如果设为 true 或 1，则只删除一个文档。writeConcern :（可选）抛出异常的级别。 文档排序 —— db.COLLECTION_NAME.find().sort() 在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。 $type 操作符 $type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。MongoDB 中可以使用的类型如下表所示： 类型 数字 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 (已废弃) Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255(Query with -1) Max key 127 1db.blogs.find(&#123;\"title\" : &#123;$type : 2&#125;&#125;) Limit与Skip方法限制记录 —— db.COLLECTION_NAME.find().limit(NUMBER) 如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。 除了limit() 方法，还有一个方法skip() 也接受数字类型的参数，并使用跳过的文档数。skip()方法默认参数为 0 。1db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) Node.js 连接 MongoDB使用 Node.js 来连接 MongoDB，并对数据库进行操作，我们需要先下载MongoDB的node版本的驱动。 官方文档地址：http://mongodb.github.io/node-mongodb-native/ 1.下载依赖包：1npm install mongodb --save 2.建立连接12345678var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/zhaomenghuan';// Use connect method to connect to the serverMongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"Connected successfully to server\"); db.close();&#125;); 与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。 3.操作数据库 和前面将到的操作类似，下面我们直接给出例子：12345678910111213141516171819202122232425262728293031var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/zhaomenghuan';MongoClient.connect(DB_CONN_STR, function(err, db) &#123; insertData(db, function (result) &#123; console.log(result); db.close(); &#125;);&#125;);function insertData(db, callback) &#123; var data = &#123; \"pageId\":\"20160816\", \"pageUrl\":\"http://zhaomenghuan.github.io/#!/blog/20160816\", \"title\":\"JavaScript进阶学习（三）—— 基于html5 File API文件操作\", \"from\":\"原创\", \"time\":\"2016-08-16\", \"keyword\":[\"blob\",\"File\",\"FileReader\",\"DataURI\",\"URL\"], \"digest\":\"这段时间一直有朋友在问文件上传下载的事，搜一下论坛发现相关的问题不少，但是不够系统，本着为人民服务的态度本文试着将一些问题整理一下，争取用初学者可以更明确的去处理相关的问题。文件上传是开发中绕不过的一个坎儿，对于很多没有经验的人来说，简直懵逼，目前我所知道的上传方式有下面这几种：传统flash上传、隐藏iframe框上传、表单数据提交、HTML5的新工具——File API。\" &#125;; // 连接到表 blogs var collection = db.collection('blogs'); collection.insertOne(data, function (err, result) &#123; if (err) &#123; console.log('Error:' + err); return; &#125; callback(result); &#125;);&#125; 对于具体的差异，需要通过查阅API文档进行进一步的学习，API文档见这里：API DOC。 本文介绍了一下mongodb的基本操作，详细的操作更多需要继续学习官方手册，接下来我们结合node，做点有意思的内容。 参考 MongoDB教程 MongoDB API DOC","categories":[{"name":"node学习之路","slug":"node学习之路","permalink":"https://zhaomenghuan.github.io/categories/node学习之路/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhaomenghuan.github.io/tags/JavaScript/"},{"name":"node.js","slug":"node-js","permalink":"https://zhaomenghuan.github.io/tags/node-js/"},{"name":"mongodb","slug":"mongodb","permalink":"https://zhaomenghuan.github.io/tags/mongodb/"}]},{"title":"Angular系列学习笔记（二）—— 基于gulp构建Angular单页面应用","slug":"Angular系列学习笔记（二）—基于gulp构建Angular单页面应用","date":"2017-03-31T16:00:00.000Z","updated":"2017-05-03T16:13:59.548Z","comments":true,"path":"2017/04/01/Angular系列学习笔记（二）—基于gulp构建Angular单页面应用/","link":"","permalink":"https://zhaomenghuan.github.io/2017/04/01/Angular系列学习笔记（二）—基于gulp构建Angular单页面应用/","excerpt":"","text":"前言构建打包工具之前一直是使用 webpack（歪脖帕克，毕竟尤大推荐的工具），由于公司这边是使用gulp，为了和公司同步，私下还是要学习学习，毕竟懂点万一需要和老大交流也不至于说有啥问题，这篇文章将会以零基础的角度去写一下基于gulp搭建angular的工程，借这个机会顺便重构一下自己的博客。 gulp基础入门在开工之前确保自己已经安装了node环境，没有安装的自行安装好node，安装的时候默认会安装npm包管理器。安装好了通过下列的命令检查版本：1234$ node -vv7.5.0$ npm -v4.1.2 然后看看gulp的文档和文章取取经开始我们今天的工作：node官网npm官网gulp中文网入门指南Gulp开发教程（翻译） 基本流程创建package.json文件新建一个文件夹开始，这里我以zhaomenghuan-blog，然后然后命令行进入项目目录：12# 创建 package.json 文件，直接一路回车就好npm init 这是在创建一个 package.json 文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。详细介绍可以看阮一峰老师的这篇文章：package.json文件。 安装 gulp全局安装 gulp1npm install gulp -g 作为项目的开发依赖（devDependencies）安装：1npm install gulp -D 这两者的区别可以看看这篇文章：npm 常用命令详解。执行完这一步，目录下就多了一个node_modules文件夹，里面都是依赖的模块。一般来说，我们可能会在其它项目中使用的工具，如这里的gulp我们会先进行全局按照，这样会在本地有一个“仓库”，以后再用的时候直接下载到项目中岂可，避免每次不必要的下载等待。另外，dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。下载模块的时候注意区分，分清楚依赖模块的差异有助于我们后期优化代码，避免不必要的模块引入到项目最终源码中，造成代码打包过大的问题。 创建 gulpfile.js 文件在项目根目录下创建一个名为 gulpfile.js 的文件：12345var gulp = require('gulp');gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 运行gulp1gulp 或 gulp default 默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。想要单独执行特定的任务（task），请输入 gulp ，例如在gulpfile.js里面添加如下代码：123gulp.task('console', function() &#123; console.log('hello gulp');&#125;); 然后执行gulp console就会输入hello gulp。 很显然我们通过一些命令就可以执行一下任务（task），那么接下来的重点就是写task相关的代码。 gulpfile.js配置说明上面的流程只是对gulp基本流程入门，但是对于gulp的强大功能还没有直观的感觉，下面我们通过常用的几段配置看看配置的基本方法。需要说明的是，在使用插件之前我们都需要先安装相关的模块。 创建具有热更新的本地服务 —— browser-sync参考文档拥有实时重载（live-reloading）和 CSS 注入的服务器这篇文章可知，使用 BrowserSync 和 gulp，你可以轻松地创建一个开发服务器，然后同一个 WiFi 中的任何设备都可以方便地访问到。BrowserSync 同时集成了 live-reload 所以不需要另外做配置了。 安装browser-sync模块：1npm install browser-sync -D 可以通过gulp.watch监听文件变动并且自动刷新，如下：123456789101112131415161718192021var gulp = require('gulp');var sass = require('gulp-ruby-sass');var browserSync = require('browser-sync');var reload = browserSync.reload;gulp.task('sass', function() &#123; return sass('scss/styles.scss') .pipe(gulp.dest('app/css')) .pipe(reload(&#123; stream:true &#125;));&#125;);// 监视 Sass 文件的改动，如果发生变更，运行 'sass' 任务，并且重载文件gulp.task('serve', ['sass'], function() &#123; browserSync(&#123; server: &#123; baseDir: 'app' &#125; &#125;); gulp.watch('app/scss/*.scss', ['sass']);&#125;); Jade 模板文件转换为 HTML 文件 —— gulp-jade我们可以通过gulp-jade插件将jade模板转成html文件，如下：12345678910111213141516171819var source = &#123; templates: [ &#123; src: './src/index.jade', dist: './app/'&#125;, &#123; src: './src/components/**/*.jade', dist: './app/components/'&#125; ]&#125;;gulp.task('templates', function()&#123; source.templates.forEach(function (item) &#123; gulp.src(item.src) .pipe(jade(&#123; pretty: true &#125;)) .pipe(gulp.dest(item.dist)) .pipe(reload(&#123; stream:true &#125;)); &#125;)&#125;); less 文件转换成css文件 —— gulp-less123456789101112131415161718192021222324var gulp = require('gulp');var less = require('gulp-less'); // 解析lessvar minifycss = require('gulp-minify-css'); // 压缩cssvar uglify = require(\"gulp-uglify\"); // 压缩代码var concat = require(\"gulp-concat\"); // 合并文件var source = &#123; styles: [ './src/index.less', './src/components/**/*.less', './src/pages/**/*.less' ]&#125;;gulp.task('styles:source', function () &#123; return gulp.src(source.styles) // 压缩的文件 .pipe(less()) .pipe(minifycss()) // 执行压缩 .pipe(concat('all.min.css')) .pipe(gulp.dest('./app/css/')) //输出到指定目录 .pipe(reload(&#123; stream:true &#125;));&#125;); 压缩图片——gulp-imagemin12345678910111213141516var gulp = require('gulp');var imagemin = require('gulp-imagemin'); // 图片压缩var source = &#123; images: &#123; src: './src/assets/images/*', dist: './app/assets/images' &#125;&#125;;gulp.task('images', function () &#123; gulp.src(source.images.src) .pipe(imagemin(&#123; optimizationLevel: 7 &#125;)) .pipe(gulp.dest(source.images.dist));&#125;); 从命令行传递参数设置项目开发模式项目开发环境下我们经常写很多console.log调试程序，在上线的时候我们又不想手动删除这些调试日志，这时候我们可以通过插件来完成。我们需要来配置两个环境： DEV 模式：在开发环境中，为了方便 debug，JavaScript 通常不做压缩和混淆； PROD 模式：上生产环境时，JavaScript 必须并合压缩、混淆并成一个文件，同时需要去除所有的 log 输出语句。 我们可以通过命令行传递参数说明是什么模式，我们可以通过官方的例子从命令行传递参数学习如何使用。 12345678910111213141516171819202122// npm install --save-dev gulp gulp-if gulp-uglify minimist gulp-strip-debugvar gulp = require('gulp');var gulpif = require('gulp-if');var uglify = require('gulp-uglify');var stripDebug = require('gulp-strip-debug');var minimist = require('minimist');var knownOptions = &#123; string: 'env', default: &#123; env: process.env.NODE_ENV || 'production' &#125;&#125;;var options = minimist(process.argv.slice(2), knownOptions);gulp.task('scripts', function() &#123; return gulp.src('**/*.js') .pipe(gulpif(options.env === 'production', uglify())) // 仅在生产环境时候进行压缩 .pipe(gulpif(options.env === 'production', stripDebug())) // 去掉console.log .pipe(gulp.dest('dist'));&#125;); 默认是development环境下，如果想使用production环境可以通过如下命令运行 gulp：1$ gulp scripts --env development 每次在命令行输入参数容易出错，为了方便我们可以将脚本写在package.json中的scripts字段里面：1234\"scripts\": &#123; \"dev\": \"gulp serve --env development\", \"build\": \"gulp serve --env production\" &#125;, 然后执行npm run dev和npm run build命令就可以。 对于新手而言，可能理解这个流程更重要，这个流程跑通了，接下来无非就是看文档入门了，关于gulp后文不再一步步赘述，而是直接给出gulpfile.js的代码。这里我们可以看出来gulp强大的功能得以实现，依赖于各种方便的插件，与webpack中提供的各种loader十分类似。可见要想完成各种负责的功能，需要对常用插件进行学习，我们可以通过这里的例子学习相关的插件使用方法：gulp 技巧集。 项目实战上面的例子对于我们搭建一个基础工程足够了，下面我们通过一个实际例子来说明。 项目结构： 123456789101112131415161718192021├── node_modules // 打包过程中依赖的包├── package.json // 包含各种所需模块以及项目的配置信息├── gulpfile.js // 打包配置文件├── app // 打包之后最终部署到服务器上的文件（名称自定义）├── src // 资源文件（名称自定义） ├── components // 自定义全局组件 ├── pageloading （如：页面切换loading） ... ├── pages // 页面路由组件 ├── index ├── index.jade 默认路由视图 ├── index.controller.js 默认路由控制器 └── index.config.js 默认视图路由配置 ├── blog ··· ├── assets // 静态资源 ├── images // 图片资源 ├── app.module.js // 全局模块 ├── index.jade // 入口视图模板 └── index.less // 入口视图样式└── vendor.config.js // 依赖的库配置文件（自定义） 本文工程地址：learn-angular =&gt; angular-material ui-router使用指南我们知道一个大型的单页面应用离不开路由，angular自带了ngRouter，但是我们常用的是angularUI的ui-router，这是因为UI-Router有两个重要的特性： 多样化视图 嵌入式视图 ui-router支持多样化视图，并且每一个视图都有自己相应的控制，所以每个区块都是封装好，可以复用到整个应用程序需要的地方，这就意味着我们可以实现视图的复用和分治。ui-router 引进了状态机设计模式，抽象高于传统的路由。路由成了状态，URL就成了状态的一个简单属性。 对于ui-router最好的学习教程就是ui-router 官方wiki，我们下面会来讲解一下新手常见的几个问题。 下载：1npm install angular-ui-router -S 引入依赖:1var app = angular.module('app', ['ui.router']); 注意：是ui.router不是ui-router! $stateProvider 处理路由状态的服务，路由的状态反映了该项在应用程序中的位置，描述了在当前状态下UI是应该怎么样的，并且该做什么。 依赖：$urlRouterProvider $urlMatcherFactoryProvider decorator(name,func)：通过内部的$stateProvider以扩展或者重写状态生成器。可用于添加ui-router的自定义功能，例如，基于状态名称推断templateUrl。警告：因为生成器的函数执行顺序的不确定，decorator不应该相互依赖。参数：name：需要修改的生成函数名称。func：负责修改生成器函数的函数。 state(name,stateConfig)：注册一个状态，并给定其配置。参数：name：状态的名称。stateConfig：状态配置对象。配置具有以下各项属性：template： string/function，html模板字符串，或者一个返回html模板字符串的函数；templateUrl：string/function，模板路径的字符串，或者返回模板路径字符串的函数；templateProvider：function，返回html模板字符串或模板路径的服务；controller：string/function，新注册一个控制器函数或者一个已注册的控制器的名称字符串；controllerProvider：function，返回控制器或者控制器名称的服务；controllerAs：string，控制器别名；parent：string/object，手动指定该状态的父级；resolve：object，将会被注入controller去执行的函数，形式。url：string，当前状态的对应url；views：object，视图展示的配置，形式；abstract：boolean，一个永远不会被激活的抽象的状态，但可以给其子级提供特性的继承。默认是true；onEnter：function，当进入一个状态后的回调函数；onExit：function，当退出一个状态后的回调函数；reloadOnSearch：boolean，如果为false，那么当一个search/query参数改变时不会触发相同的状态，用于当你修改$location.search()的时候不想重新加载页面。默认为true；data：object，任意对象数据，用于自定义配置。继承父级状态的data属性。换句话说，通过原型继承可以达到添加一个data数据从而整个树结构都能获取到；params：url里的参数值，通过它可以实现页面间的参数传递。 $urlRouterProvider $urlRouterProvider 在这里有两个主要目的：一是建立一个默认路由，用于管理未知的URL（统一跳转到某处）；二是监听浏览器地址栏URL的变化，重定向到路由定义的状态中。总之，$urlRouterProvider让我们处理状态机抽象的$stateProvider没有检测到的情况。 $urlRouterProvider负责监听$location.当$location变化的时候，$urlRouterProvider开始在一个规则的列表中一个个的查找，直到找到匹配的值。$urlRouterProvider用于在后端指定url的状态配置。所有的url被编译成UrlMatcher对象。依赖： $urlMatcherFactoryProvider $locationProvider deferIntercept(defer) ：禁用（或启用）延迟location变化的拦截。如果你想定制与URL同步的行为（例如，你需要保持当前的URL去并且推迟一个变化），那么在配置的时候使用这个方法。参数：defer：boolean，确定是禁止还是启用该拦截。123angular.module('app',['ui.router']).config([\"$urlRouterProvider\",function()&#123; $urlRouterProvider.deferIntercept(defer); // defer = true/false &#125;]) otherwise(rule)：定义一个当请求的路径是无效路径时跳转的路径。 参数：rule：你想重定向的url路径或一个返回的网址路径的规则函数。函数传入两个参数：$injector和$location服务，而且必须返回一个string的url。123angular.module('app',['ui.router']).config([\"$urlRouterProvider\",function()&#123; $urlRouterProvider.otherwise(rule); // rule = 重定向的url规则&#125;]) rule(rule)： 定义使用$urlRouterProvider来匹配指定的URL的规则。 参数： rule：将$injector和$location作为arguments传入的处理函数。用来返回一个string类型的url路径。123456789angular.module('app',['ui.router']).config([\"$urlRouterProvider\",function($urlRouterProvider)&#123; $urlRouterProvider.rule(function ($injector, $location) &#123; var path = $location.path(), normalized = path.toLowerCase(); if (path !== normalized) &#123; return normalized; &#125; &#125;);&#125;]) when(what,handler)：为给定的URL匹配注册一个处理程序。参数：what：需要重定向的传入路径。handler：你想要重定向的路径/处理程序。12345678angular.module('Demo', ['ui.router']);.config([\"$urlRouterProvider\",function ($urlRouterProvider) &#123; $urlRouterProvider.when($state.url, function ($match, $stateParams) &#123; if ($state.$current.navigable !== state || !equalForKeys($match, $stateParams) &#123; $state.transitionTo(state, $match, false); &#125; &#125;);&#125;]); $urlRouter依赖：$location $rootScope $injector $browser href(urlMacther,params,options)：一个生成URL的方法，为给定的UrlMatcher返回编译后的URL，并且用提供的参数填充。参数：urlMacther：用于当作生成URL的模板的UrlMacther对象。params：一个参数值的对象用来填补所需的匹配参数。options：option对象，absolute-boolean，如果为true，将会生成一个绝对地址。1234$bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), &#123; person: \"bob\"&#125;);// $bob == \"/about/bob\"; 触发更新：发生在地址栏URL变化时执行相同的更新。 $state $state服务负责代表状态及提供状态之间的转换。它还提供你当前的状态及上一个状态。 依赖：$rootScope $q $view $injector $resolve $stateParams $urlRouter get(stateOrName,context)：返回任何指定的状态或所有状态的配置对象。参数：stateOrName：如果提供此参数，返回的是指定状态的配置对象；如果不提供此参数，则返回全部状态的配置对象。context：当context是一个相对的参考状态，状态会在相关上下文中检索。 go(to,params,options)：参数：to：string，即将跳转的状态。params:object，跳转所带的参数。options：object，可选配置对象。有 location(是否更新地址栏的url，或以什么字符串替换url)，inherit(是否继承当前url的参数)，relative(当变化相对路径：如”^,定义的状态是相对的)，notify(是否广播$stateChangeStart和$stateChangeSuccess事件)，reload(是否重新载入)。1$state.go('contact.detail'); href(stateOeName,params,options)：一个URL生成方法，返回为给定的状态填充指定的参数编译后的链接。参数：stateOeName：string，你想要生成的url的状态或者状态对象。params：object，一个用于填充状态需要的参数的对象。options：可选配置对象。有lossy(当第一个参数url未被提供时是否继承导航的url进行构建href),inherit(是否继承当前url的参数),relative(当变化相对路径：如”^,定义的状态是相对的),absolute(是否生成绝对url)。1$state.href(\"about.person\", &#123; person: \"bob\" &#125;) include(stateOrName,params,options)：一个确定当前有效的状态是不是与stateOrName平级的还是其子状态。参数：stateOeName：string，部分名称，相对名称，或者通过当前状态进行全局模式查找。params：object，一个参数对象。options：可选配置对象。有relative。 is(stateOrName,params,options)：与$state.include相似，只是这个针对的是全名。参数性质同上。 reload(state)：重新载入当前状态的方法。参数：state：一个状态名称或者状态对象。1$state.reload('contact.detail'); transitionTo(to,toParams,options)：过渡到一个新状态的方法。参数：to：状态名称。toParams：将会发送到下一个状态的参数。options：可选参数。有location，inherit，relative，notify，reload。123$state.transitionTo($state.current, $stateParams, &#123; reload: true, inherit: false, notify: true&#125;); current：获取当前路由 $stateChangeError：路由状态变化发生错误时触发的事件。参数：event，toState，toParams，fromState，fromParams，error。 $stateChangeStart：路由状态变化发生前触发的事件。参数：event，toState，toParams，fromState，fromParams。 $stateChangeSuccess：路由状态变化正确时触发的事件。参数：event，toState，toParams，fromState，fromParams。 $stateNotFound：路由状态没找到的时候触发的事件。参数：event，unfoundState，fromState，fromParams。 三种常用的方式激活路由状态 $state.go()：优先级较高的便利方式 ui-sref：点击包含此指令跳转 url：url导航 ui-sref：一种将链接（&lt;a&gt;标签）绑定到一个状态的指令。点击该链接将触发一个可以带有可选参数的状态转换。ui-sref此指令必须绑定到&lt;a&gt;标签，如果该路由有对应的关联URL，其通过$state.href()自动生成和更新href属性。12&lt;a ui-sref=\"blog\" ui-sref-active=\"active\"&gt;博客&lt;/a&gt;&lt;a ui-sref=\"blog(&#123;id: pageId&#125;)\"&gt;博客-2017&lt;/a&gt; ui-sref-active=”active” 该路由激活，则对应增加active样式名称，ui-sref-opts 传递参数。 html5模式 or Hashbang$location服务有两种用来控制地址栏URL格式的配置：Hashbang模式（默认）和HTML5模式（使用HTML5历史API）。应用会使用两种模式中相同的API，并且$location服务会使用需要的URL片段和浏览器API来帮助改变URL或者进行历史管理。 {% image http://upload-images.jianshu.io/upload_images/1945738-78637b3f92e3df9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 'html5模式 or Hashbang' '' %} 对比 Hashbang模式 HTML5模式 配置 默认 { html5Mode: true } URL格式 所有浏览器都支持 hashbang URLs在高级浏览器中使用regular URLs，低级浏览器使用hashbang URLs &lt;a href=&quot;&quot;&gt; 链接重写 否 是 需要服务器端配置 否 是 Hashbang模式(默认mode) 使用这个模式的话，$location会在所有浏览器中使用Hashbang URLs。12$locationProvider.html5mode = false;$locationProvider.hashPrefix = '!'; 支持网络爬虫 你需要添加特别的meta标记在你的文档的头部才能支持对你的AJAX应用的索引。1&lt;meta name=\"fragment\" content=\"!\" /&gt; 这能让网络爬虫请求带有_escapedfragment形式的参数链接，这样你就能识别爬虫并且返回一个HTML的快照了。 HTML5模式 在HTML5模式中，$location服务的读写器和浏览器的URL地址通过HTML5历史API交互，这使你能用regular URL path并且搜索各组成部分，和hashbang是等效的。 如果浏览器不支持HTML5 历史API， $location服务会自动回退成使用hashbang URLs。你就不用担心浏览器的支持性了。$location服务总是会用最好的选择。 在低级浏览器中使用了regular URL -&gt; 重定向成hashbang URL在现代浏览器中打开了一个hashbang URL -&gt; 重写成regular URL1$locationProvider.html5mode = true; 服务器端：使用这种模式需要开启服务器端的URL重写功能，基本上你需要重写所有指向你应用的链接(如index.html)。 相对链接：记住要检查所有的相对连接、图片、脚本等。你必须指定你主页面的base url()，或者你使用绝对路径也行，因为相对路径会结合文档的初始绝对路径转换成绝对路径。文档初始路径通常和应用的根路径不一样。 参考 gulp 技巧集 ui-router wiki UI-Router:为什么开发者都不喜欢Angular.js内置的路由 AngularJs ui-router 路由的简单介绍 AngularJS开发指南27：使用$location","categories":[{"name":"Angular系列学习笔记","slug":"Angular系列学习笔记","permalink":"https://zhaomenghuan.github.io/categories/Angular系列学习笔记/"}],"tags":[{"name":"angular","slug":"angular","permalink":"https://zhaomenghuan.github.io/tags/angular/"},{"name":"gulp","slug":"gulp","permalink":"https://zhaomenghuan.github.io/tags/gulp/"},{"name":"angular-ui-router","slug":"angular-ui-router","permalink":"https://zhaomenghuan.github.io/tags/angular-ui-router/"},{"name":"angular-material","slug":"angular-material","permalink":"https://zhaomenghuan.github.io/tags/angular-material/"}]},{"title":"Angular系列学习笔记（一）—— 聊聊angular的模块化","slug":"Angular系列学习笔记（一）—聊聊angular的模块化","date":"2017-03-05T16:00:00.000Z","updated":"2017-05-03T16:14:05.284Z","comments":true,"path":"2017/03/06/Angular系列学习笔记（一）—聊聊angular的模块化/","link":"","permalink":"https://zhaomenghuan.github.io/2017/03/06/Angular系列学习笔记（一）—聊聊angular的模块化/","excerpt":"","text":"前言近来换工作了，由于团队技术需要，不得不从vue.js迁移到angular.js，不过这也是一个学习angular的机会，顺便也将这两个框架做一些对比，为了方便其他小伙伴，将学习过程中的内容记录下来。由开始的不太习惯到现在也能够习惯angular的写法，着实在思维上有很大的改变，所以这个系列的文章会记录一下自己的学习过程，本文会由浅及深一步步去解读vue.js和angular.js的区别。由于时间关系，这篇文章断断续续耗时几周，不求什么，只希望在这个过程中将angular相关的一些特性去梳理一下，由于是系列开篇，文章并没有深入探讨源码和原理，后续会写更多个人的思考和探索。 vuejs vs angular之初相见对于vue.js我们都需要通过创建一个Vue实例指定作用范围，对于angular只需要ng-app指令就可以。 vue.js的姿势： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;button v-on:click=\"changeView\"&gt;changeView&lt;/button&gt;&lt;/div&gt;&lt;script src=\"//cdn.bootcss.com/vue/2.1.10/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello world!' &#125;, methods: &#123; changeView: function()&#123; this.message = 'hello vuejs!'; // 或 app.$data.message = 'hello vuejs!' &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; angular的姿势： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html ng-app=\"app\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"helloCtrl\"&gt; &#123;&#123;message&#125;&#125; &lt;button ng-click=\"changeView()\"&gt;changeView&lt;/button&gt; &lt;/div&gt; &lt;script src=\"//cdn.bootcss.com/angular.js/1.6.0/angular.js\"&gt;&lt;/script&gt; &lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.controller('helloCtrl', function ($scope) &#123; $scope.message = 'hello world'; $scope.changeView = function () &#123; $scope.message = 'hello angular.js!'; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个例子虽然再简单不过，对于项目开发没有半点用处，但是对于理解vue.js和angular.js的区别有一定的借鉴意义，vue.js中总体的思路是实例化Vue对象，我们通过el属性指定控制的dom范围，data是数据模型，可以通过实例化后的对象app.$data访问数据，在方法中或者生命周期钩子如mounted中可以使用this获取实例上下文，vuejs中没有控制器的概念，属于典型的MVVM架构。然而我们这篇文章不是讲vue.js，因为如果你使用vue.js，那么直接看文档很好理解，无需我多言，这里我们想重点说说angular。 经常听人说vue.js语法优雅，我想应该是由于vue.js结构更加清晰吧，数据模型和操作分得更清晰，就从命名出发更简单吧，$scope是什么鬼。好吧，查了一下：scope（范围），我们姑且先从字面含义这么理解吧，但是从这例子中发现$scope多次使用，另外不能被改名，不然不能用，我们姑且认为是个神奇的玩意。angular中ng-click的指令和vue.js无大的区别，这里不多言，这里重点想谈谈模块化和angular的依赖注入。 vuejs vs angular之数据模型共享在vue.js中是通过组件树实现模块化的，而angular通过作用域$scope实现模块化。对于vue.js中模块化的最佳实践是： .vue单文件组件 + 模块化标准（common.js或者es6 module) + webpack(或Browserify）。 而其中核心部分就是组件，用官方的话说就是，组件（Component）是 Vue.js 最强大的功能之一，组件可以扩展 HTML 元素，封装可重用的代码，在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能，在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 如何构建一个组件，组件之前数据如何共享，这是开发中必须要学习的内容。vue.js组件实例的作用域是孤立的，这意味着不能并且不应该在子组件的模板内直接引用父组件的数据，可以使用 props 把数据传给子组件。另外vue.js中提倡单向数据流：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。当子组件需要更新父组件的状态时，我们可以通过事件触发。下面是一个利用props传递数据和使用事件触发父组件状态的典型例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;button v-on:click=\"parentAtion\"&gt;parentAtion&lt;/button&gt; &lt;child v-bind:param=\"message\" v-on:childfn=\"fromChild\"&gt;&lt;/child&gt; &lt;/div&gt; &lt;script type=\"text/x-template\" id=\"child-tpl\"&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;param&#125;&#125;&lt;/span&gt; &lt;button v-on:click=\"childAtion\"&gt;childAtion&lt;/button&gt; &lt;/div&gt; &lt;/script&gt; &lt;script src=\"//cdn.bootcss.com/vue/2.1.10/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; Vue.component('child', &#123; template: '#child-tpl', props: ['param'], methods: &#123; childAtion: function()&#123; // 触发事件 this.$emit('childfn', 'child component'); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello vuejs!' &#125;, methods: &#123; parentAtion: function()&#123; this.message = 'parent component'; &#125;, fromChild: function(msg)&#123; this.message = msg; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 Vue的事件系统分离自浏览器的EventTarget API。尽管它们的运行类似，但是$on和 $emit 不是addEventListener和 dispatchEvent的别名。 父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。对于非父子组件通信的通信，在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：1234567var bus = new Vue()// 触发组件 A 中的事件bus.$emit('id-selected', 1)// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) &#123; // ...&#125;) 在更多复杂的情况下，你应该考虑使用专门的状态管理。 对于angular 而言，ng-controller指令指定了作用范围，通过$scope对象控制作用域，$scope层层嵌套形成父子关系或者兄弟并列关系，而父子作用域是通过原型继承实现，子作用域可以访问父作用域的数据模型，反过来不行，同理如果父级作用域中的状态改变会影响子作用域，反过来子作用域中的状态改变不会影响父级作用域。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html ng-app=\"app\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"parentCtrl\"&gt; &#123;&#123;message&#125;&#125; &lt;button ng-click=\"parentAtion()\"&gt;parentAtion&lt;/button&gt; &lt;div ng-controller=\"childCtrl\"&gt; &#123;&#123;message&#125;&#125; &lt;button ng-click=\"childAtion()\"&gt;childAtion&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"js/angular.min.js\"&gt;&lt;/script&gt; &lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.controller('parentCtrl', function ($scope) &#123; $scope.message = 'hello angular'; $scope.parentAtion = function () &#123; $scope.message = 'parent scope'; &#125; &#125;) app.controller('childCtrl', function ($scope) &#123; $scope.childAtion = function () &#123; $scope.message = 'child scope'; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 由于原型继承的关系，修改父级对象中的message会同时修改子对象中的值，但反之则不行。如果我们想在子级控制器中改变父对象中的值，则需要通过引用进行共享。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html ng-app=\"app\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"parentCtrl\"&gt; &#123;&#123;dataModal.message&#125;&#125; &lt;button ng-click=\"parentAtion()\"&gt;parentAtion&lt;/button&gt; &lt;div ng-controller=\"childCtrl\"&gt; &#123;&#123;dataModal.message&#125;&#125; &lt;button ng-click=\"childAtion()\"&gt;childAtion&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"js/angular.min.js\"&gt;&lt;/script&gt; &lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.controller('parentCtrl', function ($scope) &#123; $scope.dataModal = &#123; message: 'hello angular' &#125; $scope.parentAtion = function () &#123; $scope.dataModal.message = 'parent scope'; &#125; &#125;) app.controller('childCtrl', function ($scope) &#123; $scope.childAtion = function () &#123; $scope.dataModal.message = 'child scope'; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 问题的本质在于字符串、数字和布尔型变量是值复制，数组、对象和函数则是引用复制，通过引用共享可以在子级作用域内部改变它会影响父级作用域的数据模型状态。 另外我们通过chrome的一个插件AngularJS Batarang可以很清晰的看出$scope对象的继承关系，会发现每个$scope对象都会有个$id，以及对于作用域$scope下的数据模型，如下： AngularJS Batarang插件效果 需要说明的是ng-app对应的作用域是全局的，我们一般使用$rootScope对象表示，对应的$id等于1。 除了通过引用复制实现数据共享，我们也可以使用类似vue.js中的事件机制。 angular事件广播： $broadcast：只能向child controller传递event与data $emit：只能向parent controller传递event与data 12$scope.$broadcast(name, data);$scope.$emit(name, data); angular事件监听： $on：接收event与data 123$scope.$on(eventName, function(event, data)&#123; // 这里写监听逻辑...&#125;) 在$on的方法中的event事件参数，其对象的属性和方法如下： 事件属性 含义 event.targetScope 发出或者传播原始事件的作用域 event.currentScope 目前正在处理的事件的作用域 event.name 事件名称 event.stopPropagation() 一个防止事件进一步传播(冒泡/捕获)的函数(这只适用于使用$emit发出的事件) event.preventDefault() 这个方法实际上不会做什么事，但是会设置defaultPrevented为true。直到事件监听器的实现者采取行动之前它才会检查defaultPrevented的值。 event.defaultPrevented 如果调用了preventDefault则为true 上述的例子可以改写为：12345678910111213141516171819var app = angular.module('app', []);app.controller('parentCtrl', function ($scope) &#123; $scope.message = 'hello angular'; $scope.parentAtion = function () &#123; $scope.message = 'parent scope'; &#125; // 监听事件 $scope.$on('sendMsg', function(event, data)&#123; $scope.message = data; &#125;)&#125;)app.controller('childCtrl', function ($scope) &#123; $scope.childAtion = function () &#123; // 触发事件 $scope.$emit('sendMsg', 'child scope'); &#125;&#125;) angular 依赖注入前面我们对比了angular和vue对于数据模型共享的处理方式，发现两个框架在整体上大致相同，在细微上有所区别。对于一个大型模块化工程而言，除了需要处理数据模型数据流的问题，插件和依赖的处理同样也是实现模块化必不可少的一部分。我们如何将我们的应用分成一个个小模块，互不干扰高度自治，但是却又能够相互依赖。在vue中我们是通过构建工具例如webpack+模块化标准来实现，在angular中是通过依赖注入（Dependency Injection）实现的。 这里我们先来看一下知乎上的一个问题：AngularJS中的依赖注入实际应用场景？依赖注入是一个设计模式,遵循依赖倒转原则(Dependence Inversion Priciple, DIP)。关于依赖注入的实现原理后面再做深入探讨，我们先可以认为angular提供了一套机制可以很好的解决模块之间相互依赖的问题。 angular是用$provider对象来实现自动依赖注入机制，注入机制通过调用一个provide的$get()方法，把得到的对象作为参数进行相关调用。例如：1234567891011121314151617181920&lt;div ng-controller=\"serveCtrl\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); // 使用provider方法创建服务 app.provider('dataServe',&#123; $get: function() &#123; return &#123; message:\"dataServe Provide\" &#125;; &#125; &#125;); app.controller('serveCtrl', function ($scope, dataServe) &#123; // 调用服务 $scope.message = dataServe.message; &#125;)&lt;/script&gt; 这里我们演示了angular中依赖注入的一个简单例子，在serveCtrl控制器中我们通过将dataServe作为函数参数名写入，就可以访问dataServe服务的内容，从而实现模块解耦。 上面是一种实现方法，但不是最佳实践，我们一步步说明其他写法。 首先我们需要知道在angular中声明和引用一个模块的方法：声明模块的写法如下：1234567angular.module(name, [requires], [configFn]);name：字符串类型，代表模块的名称；requires：字符串的数组，代表该模块依赖的其他模块列表，如果不依赖其他模块，用空数组即可；configFn：用来对该模块进行一些配置。函数返回模块的引用 使用模块的方法：1angular.module(name) 上面创建服务，我们可以通过$provide服务实现：12345678910111213141516171819202122232425262728angular.module('app', [], function($provide)&#123; $provide.provider('dataServe', function()&#123; this.$get = function()&#123; return &#123; message:\"dataServe Provide\" &#125; &#125; &#125;)&#125;).controller('serveCtrl', function ($scope, dataServe) &#123; // 调用服务 $scope.message = dataServe.message;&#125;)或var app = angular.module('app', []);app.config(function($provide)&#123; $provide.provider('dataServe', function()&#123; this.$get = function()&#123; return &#123; message:\"dataServe Provide\" &#125; &#125; &#125;)&#125;)app.controller('serveCtrl', function ($scope, dataServe) &#123; $scope.message = dataServe.message;&#125;) 创建服务的几种常用方法上述我们使用provider和$provide.provider两种不同的写法，但是都是需要写$get函数，为了简化创建服务的过程，angualr提供了其他的五种方法： constant：定义常量，定义的值不能被改变，可以被注入到任何地方，但是不能被装饰器(decorator)装饰； 12345678910111213&lt;div ng-controller=\"serveCtrl\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.config(function($provide) &#123; $provide.constant('constantServe', 'constant serve'); &#125;) app.controller('serveCtrl', function($scope, constantServe) &#123; $scope.message = constantServe; &#125;) &lt;/script&gt; 语法糖：1app.constant('constantServe', 'constant serve'); value：可以是string,number甚至function,和constant的不同之处在于，它可以被修改，不能被注入到config中，可以被decorator装饰 12345678910111213&lt;div ng-controller=\"serveCtrl\"&gt; &lt;button ng-click=\"showTips()\"&gt;show tips&lt;/button&gt;&lt;/div&gt;&lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.value('valueServe', function()&#123; alert(\"哈哈\"); &#125;) app.controller('serveCtrl', function ($scope, valueServe) &#123; $scope.showTips = valueServe; &#125;)&lt;/script&gt; factory：factory为自定义工厂，是注册服务的最常规方式，它可返回任何对象，包括基本的数据类型。 1234567891011121314151617&lt;div ng-controller=\"serveCtrl\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.config(function($provide)&#123; $provide.factory('factoryServe', function()&#123; return &#123; message: 'factory serve' &#125; &#125;) &#125;) app.controller('serveCtrl', function ($scope, factoryServe) &#123; $scope.message = factoryServe.message &#125;)&lt;/script&gt; 语法糖：12345app.factory('factoryServe', function()&#123; return &#123; message: 'factory serve' &#125;&#125;) factory就是通过provider第二个参数为对象的方法实现，factory底层通过调用$provide.provider(name, {$get: $getFn})，而$getFn就是自定义factory的参数，即factory所传的方法需返回一个对象，这个对象会绑定到provider的$get属性上。 service：当使用service创建服务的时候，相当于使用new关键词进行了实例化。因此，你只需要在this上添加属性和方法，然后，服务就会自动的返回this。当把这个服务注入控制器的时候，控制器就可以访问在那个对象上的属性了。 123456789101112131415&lt;div ng-controller=\"serveCtrl\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.config(function($provide)&#123; $provide.service('serviceServe', function()&#123; this.message = 'factory serve'; &#125;) &#125;) app.controller('serveCtrl', function ($scope, serviceServe) &#123; $scope.message = serviceServe.message &#125;)&lt;/script&gt; 语法糖：123app.service('serviceServe', function()&#123; this.message = 'factory serve';&#125;) decorator：provider里面的装饰器——锦上添花神器 为什么使用decorator?我们经常在使用某些Service的时候，更希望它能具备一些额外的功能，这时我们难道改这个Service吗？如果是系统自带的呢，改吗？这当然不现实吧。所以我们的装饰器decorator就发挥作用了，它能让已有的功能锦上添花。我们在config里面使用装饰器。12345678910111213141516171819202122&lt;div ng-controller=\"serveController\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"application/javascript\"&gt; var app = angular.module(\"app\", []); app.config(['$provide', function($provide) &#123; $provide.decorator('infoService', function($delegate) &#123; $delegate.email = \"1028317108@qq.com\"; return $delegate; &#125;) &#125;]); app.service('infoService', function() &#123; this.name = 'zhaomenghuan'; &#125;) app.controller('serveController', ['$scope', 'infoService', function($scope, infoService) &#123; $scope.message = 'name：'+infoService.name + '&lt;=&gt;Emil：'+infoService.email; &#125;]);&lt;/script&gt; 我们开始写的infoService没有Emil，我们通过装饰器decorator在不修改infoService代码的情况下添加了email新属性。 源码部分：1234567891011121314151617181920212223242526272829303132333435function provider(name, provider_) &#123; if(isFunction(provider_)) &#123; provider_ = providerInjector.instantiate(provider_); &#125; if(!provider_.$get) &#123; throw Error('Provider ' + name + ' must define $get factory method.'); &#125; return providerCache[name + providerSuffix] = provider_;&#125;function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;);&#125;function service(name, constructor) &#123; return factory(name, ['$injector', function($injector) &#123; return $injector.instantiate(constructor); &#125;]);&#125;function value(name, value) &#123; return factory(name, valueFn(value)); &#125;function constant(name, value) &#123; providerCache[name] = value; instanceCache[name] = value;&#125;function decorator(serviceName, decorFn) &#123; var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get; origProvider.$get = function() &#123; var origInstance = instanceInjector.invoke(orig$get, origProvider); return instanceInjector.invoke(decorFn, null, &#123; $delegate: origInstance &#125;); &#125;;&#125; 注意：所有的供应商都只被实例化一次，也就说他们都是单例的，除了constant，所有的供应商都可以被装饰器(decorator)装饰。模块的config方法只能注入 provider 和 constant；模块的run方法中可被注入的依赖包括服务(service)、值(value)和参量(constant)，不能注入”provider”类型的依赖。 注入依赖的几种方法 通过数组标注在方法的参数中声明依赖（优先考虑） 123app.controller('serveCtrl', ['$scope', 'factoryServe', function ($scope, factoryServe) &#123; $scope.message = factoryServe.message;&#125;]) 定义在控制器构造方法的$inject属性中 1234app.$inject = ['$scope', 'factoryServe']app.controller('serveCtrl', function ($scope, factoryServe) &#123; $scope.message = factoryServe.message;&#125;) 隐式声明依赖 123app.controller('serveCtrl', function ($scope, factoryServe) &#123; $scope.message = factoryServe.message;&#125;) 注入器可以从函数的参数名中推断所依赖的服务。上面的函数中声明了$scope和factoryServe服务作为依赖。 这种方式可是代码更加简洁，但这种方式不能和JavaScript的代码混淆器一起使用。可以通过ng-annotate在minifying之前隐式的添加依赖。 通过在ng-app所在的DOM元素中添加ng-strict-di切换到严格的依赖注入模式，strict模式下使用隐式的标注会报错，如果用angular.bootstrap手动启动angular应用，我们可以通过设置config中的strictDi属性，启动strict模式。123angular.bootstrap(document, ['myApp'], &#123; strictDi: true&#125;); 注入器（$injector）angular注入器（$injector类似于spring容器）负责创建、查找注入依赖, 每个module都会有自己的注入器。注入器负责从我们通过$provide创建的服务中创建注入的实例。只要你编写了一个带有可注入性的参数，你都能看到注入器是如何运行的。每一个AngularJS应用都有唯一一个$injector，当应用启动的时候它被创造出来，你可以通过将$injector注入到任何可注入函数中来得到它（$injector知道如何注入它自己！）。 一旦你拥有了$injector，你可以动过调用get函数来获得任何一个已经被定义过的服务的实例。例如：12345678910111213141516171819&lt;div ng-controller=\"serveController\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script type=\"application/javascript\"&gt; var app = angular.module('app', []); app.factory('factoryServe', function()&#123; return &#123; message: 'factory serve' &#125; &#125;) var injector = angular.injector(['app']); app.controller('serveController', ['$scope', function ($scope) &#123; var factoryServe = injector.get('factoryServe'); $scope.message = factoryServe.message; &#125;])&lt;/script&gt; 这是因为Angular在编译模板阶段为ng-controller指令以及实例化serveController注入相关的依赖。1injector.instantiate(serveController); 总结react，angular，vue这三大框架带给前端变化，远远不只是让我们放弃jQuery这种直接操作dom的方式，也不仅仅是解决数据绑定的问题，我想更多的是改变我们的思维方式，用数据驱动的方式去更新视图，通过划分组件或者作用域，来实现整体的颗粒化，实现模块间分治，同时也改变了前后端协作的工作模式。 参考 vue.js组件 AngularJS的学习–$on、$emit和$broadcast的使用 前端需要知道的 依赖注入(Dependency Injection, DI) 理解AngularJS中的依赖注入 AngularJs中的provide","categories":[{"name":"Angular系列学习笔记","slug":"Angular系列学习笔记","permalink":"https://zhaomenghuan.github.io/categories/Angular系列学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhaomenghuan.github.io/tags/JavaScript/"},{"name":"angular","slug":"angular","permalink":"https://zhaomenghuan.github.io/tags/angular/"},{"name":"vue.js","slug":"vue-js","permalink":"https://zhaomenghuan.github.io/tags/vue-js/"},{"name":"模块化","slug":"模块化","permalink":"https://zhaomenghuan.github.io/tags/模块化/"},{"name":"$scope","slug":"scope","permalink":"https://zhaomenghuan.github.io/tags/scope/"},{"name":"依赖注入","slug":"依赖注入","permalink":"https://zhaomenghuan.github.io/tags/依赖注入/"},{"name":"service","slug":"service","permalink":"https://zhaomenghuan.github.io/tags/service/"}]},{"title":"npm 常用命令详解","slug":"npm 常用命令详解","date":"2016-11-14T16:00:00.000Z","updated":"2017-05-03T16:16:30.034Z","comments":true,"path":"2016/11/15/npm 常用命令详解/","link":"","permalink":"https://zhaomenghuan.github.io/2016/11/15/npm 常用命令详解/","excerpt":"","text":"前言在查看npm 命令参数的时候搜到白树的这篇文章，觉得很详细，自己后续也可能会继续看，干脆整理一下转载到自己博客，只为了方便学习，如需转载用作商业用途，请联系作者本人。本文原始地址: http://www.cnblogs.com/PeunZhang/p/5553574.html。 今年上半年在学习gulp的使用，对npm的掌握是必不可少的，经常到npm官网查询文档让我感到不爽，还不如整理了一些常用的命令到自己博客上，于是根据自己的理解简单翻译过来，终于有点输出，想学习npm这块的朋友不可错过这些基础命令，新手出品，对本文有疑惑之处还请同学们不耻下问。很久没有写文章啦，后续也希望自己在nodejs这方面有多点内容产出。 目录 npm是什么 npm install 安装模块 npm uninstall 卸载模块 npm update 更新模块 npm outdated 检查模块是否已经过时 npm ls 查看安装的模块 npm init 在项目中引导创建一个package.json文件 npm help 查看某条命令的详细帮助 npm root 查看包的安装路径 npm config 管理npm的配置路径 npm cache 管理模块的缓存 npm start 启动模块 npm stop 停止模块 npm restart 重新启动模块 npm test 测试模块 npm version 查看模块版本 npm view 查看模块的注册信息 npm publish 发布模块 npm access 在发布的包上设置访问级别 npm package.json的语法 npm是什么NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包。 npm install 安装模块基础语法:1234567891011npm install (with no args, in package dir)npm install [&lt;@scope&gt;/]&lt;name&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;tag&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version range&gt;npm install &lt;tarball file&gt;npm install &lt;tarball url&gt;npm install &lt;folder&gt;alias: npm icommon options: [-S|--save|-D|--save-dev|-O|--save-optional] [-E|--save-exact] [--dry-run] 安装包，默认会安装最新的版本:1npm install gulp 安装指定版本:1npm install gulp@3.9.1 安装包并将信息保持到项目的package.json文件中 项目对模块的依赖可以使用下面的 3 种方法来表示（假设当前版本号是 1.1.0 ）： 兼容模块新发布的补丁版本：~1.1.0、1.1.x、1.1 兼容模块新发布的小版本、补丁版本：^1.1.0、1.x、1 兼容模块新发布的大版本、小版本、补丁版本：*、x -S, –save 安装包信息将加入到dependencies（生产阶段的依赖）1npm install gulp --save 或 npm install gulp -S package.json 文件的 dependencies 字段：123\"dependencies\": &#123; \"gulp\": \"^3.9.1\"&#125; -D, –save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它1npm install gulp --save-dev 或 npm install gulp -D package.json 文件的 devDependencies字段：123\"devDependencies\": &#123; \"gulp\": \"^3.9.1\"&#125; -O, –save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）1npm install gulp --save-optional 或 npm install gulp -O package.json 文件的optionalDependencies字段：123\"optionalDependencies\": &#123; \"gulp\": \"^3.9.1\"&#125; -E, –save-exact 精确安装指定模块版本1npm install gulp --save-exact 或 npm install gulp -E 输入命令npm install gulp -ES，留意package.json 文件的 dependencies 字段，以看出版本号中的^消失了123\"dependencies\": &#123; \"gulp\": \"3.9.1\"&#125; 模块的依赖都被写入了package.json文件后，他人打开项目的根目录（项目开源、内部团队合作），使用npm install命令可以根据dependencies配置安装所有的依赖包1npm install 本地安装（local）1npm install gulp 全局安装（global）,使用 -g 或 –global1npm install gulp -g npm uninstall 卸载模块基础语法:123npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev|-O|--save-optional]aliases: remove, rm, r, un, unlink 如卸载开发版本的模块:1npm uninstall gulp --save-dev npm update 更新模块基础语法:1npm update [-g] [&lt;pkg&gt;...] npm outdated 检查模块是否已经过时基础语法:1npm outdated [[&lt;@scope&gt;/]&lt;pkg&gt; ...] 此命令会列出所有已经过时的包，可以及时进行包的更新 npm ls 查看安装的模块基础语法:123npm ls [[&lt;@scope&gt;/]&lt;pkg&gt; ...]aliases: list, la, ll 查看全局安装的模块及依赖1npm ls -g npm init 在项目中引导创建一个package.json文件安装包的信息可保持到项目的package.json文件中，以便后续的其它的项目开发或者他人合作使用，也说package.json在项目中是必不可少的。1npm init [-f|--force|-y|--yes] npm help 查看某条命令的详细帮助基础语法:1npm help &lt;term&gt; [&lt;terms..&gt;] 例如输入npm help install，系统在默认的浏览器或者默认的编辑器中打开本地nodejs安装包的文件/nodejs/node_modules/npm/html/doc/cli/npm-install.html1npm help install npm root 查看包的安装路径输出 node_modules的路径1npm root [-g] npm config 管理npm的配置路径基础语法: 1234567npm config set &lt;key&gt; &lt;value&gt; [-g|--global]npm config get &lt;key&gt;npm config delete &lt;key&gt;npm config listnpm config editnpm get &lt;key&gt;npm set &lt;key&gt; &lt;value&gt; [-g|--global] 对于config这块用得最多应该是设置代理，解决npm安装一些模块失败的问题 例如我在公司内网，因为公司的防火墙原因，无法完成任何模块的安装，这个时候设置代理可以解决1npm config set proxy=http://dev-proxy.oa.com:8080 又如国内的网络环境问题，某官方的IP可能被和谐了，幸好国内有好心人，搭建了镜像，此时我们简单设置镜像1npm config set registry=\"http://r.cnpmjs.org\" 也可以临时配置，如安装淘宝镜像1npm install -g cnpm --registry=https://registry.npm.taobao.org npm cache 管理模块的缓存基础语法: 123456npm cache add &lt;tarball file&gt;npm cache add &lt;folder&gt;npm cache add &lt;tarball url&gt;npm cache add &lt;name&gt;@&lt;version&gt;npm cache ls [&lt;path&gt;]npm cache clean [&lt;path&gt;] 最常用命令无非清除npm本地缓存1npm cache clean npm start 启动模块1npm start [-- &lt;args&gt;] 该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序，如123\"scripts\": &#123; \"start\": \"gulp -ws\"&#125; 此时在cmd中输入npm start命令相当于执行gulpfile.js文件自定义的watch和server命令。如果package.json文件没有设置start，则将直接启动node server.js npm stop 停止模块基础语法:1npm stop [-- &lt;args&gt;] npm restart 重新启动模块基础语法: 1npm restart [-- &lt;args&gt;] npm test 测试模块基础语法:12npm test [-- &lt;args&gt;]npm tst [-- &lt;args&gt;] 该命令写在package.json文件scripts的test字段中，可以自定义该命令来执行一些操作，如123\"scripts\": &#123; \"test\": \"gulp release\"&#125;, 此时在cmd中输入npm test命令相当于执行gulpfile.js文件自定义的release命令。 npm version 查看模块版本基础语法: 12345npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]'npm [-v | --version]' to print npm version'npm view &lt;pkg&gt; version' to view a package's published version'npm ls' to inspect current package/dependency versions 查看模块的版本1npm version npm view 查看模块的注册信息基础语法:123npm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...]aliases: info, show, v 查看模块的依赖关系1npm view gulp dependencies 查看模块的源文件地址1npm view gulp repository.url 查看模块的贡献者，包含邮箱地址1npm view npm contributors npm publish 发布模块基础语法:1234npm publish [&lt;tarball&gt;|&lt;folder&gt;] [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;]Publishes '.' if no argument suppliedSets tag 'latest' if no --tag specified npm access 在发布的包上设置访问级别基础语法: 123456789npm access public [&lt;package&gt;]npm access restricted [&lt;package&gt;]npm access grant &lt;read-only|read-write&gt; &lt;scope:team&gt; [&lt;package&gt;]npm access revoke &lt;scope:team&gt; [&lt;package&gt;]npm access ls-packages [&lt;user&gt;|&lt;scope&gt;|&lt;scope:team&gt;]npm access ls-collaborators [&lt;package&gt; [&lt;user&gt;]]npm access edit [&lt;package&gt;] npm package.json的语法英文原版：https://docs.npmjs.com/files/package.json 这块内容好多，国内有好心人整理：《npm的package.json中文文档》，从这份文档拷贝出一些比较常见的，如下： 默认值npm会根据包内容设置一些默认值。1\"scripts\": &#123;\"start\": \"node server.js\"&#125; 如果包的根目录有server.js文件，npm会默认将start命令设置为node server.js。1\"scripts\":&#123;\"preinstall\": \"node-waf clean || true; node-waf configure build\"&#125; 如果包的根目录有wscript文件，npm会默认将preinstall命令用node-waf进行编译。1\"scripts\":&#123;\"preinstall\": \"node-gyp rebuild\"&#125; 如果包的根目录有binding.gyp文件，npm会默认将preinstall命令用node-gyp进行编译。1\"contributors\": [...] 如果包的根目录有AUTHORS文件，npm会默认逐行按Name (url)格式处理，邮箱和url是可选的。#号和空格开头的行会被忽略。 name在package.json中最重要的就是name和version字段。他们都是必须的，如果没有就无法install。name和version一起组成的标识在假设中是唯一的。改变包应该同时改变version。name是这个东西的名字。注意： 不要把node或者js放在名字中。因为你写了package.json它就被假定成为了js，不过你可以用”engine”字段指定一个引擎（见后文）。 这个名字会作为在URL的一部分、命令行的参数或者文件夹的名字。任何non-url-safe的字符都是不能用的。 这个名字可能会作为参数被传入require()，所以它应该比较短，但也要意义清晰。 在你爱上你的名字之前，你可能要去npm registry查看一下这个名字是否已经被使用了。http://registry.npmjs.org/ versionversion必须能被node-semver解析，它被包在npm的依赖中。（要自己用可以执行npm install semver） 可用的“数字”或者“范围”见semver(7). description放简介，字符串，方便在npm search中搜索 keywords关键字，数组、字符串，方便在npm search中搜索 bugs你项目的提交问题的url和（或）邮件地址1234&#123; \"url\" : \"http://github.com/owner/project/issues\", \"email\" : \"project@hostname.com\"&#125; license你应该要指定一个许可证，让人知道使用的权利和限制的。 最简单的方法是，假如你用一个像BSD或者MIT这样通用的许可证，就只需要指定一个许可证的名字，像这样：1&#123; \"license\" : \"BSD\" &#125; 如果你又更复杂的许可条件，或者想要提供给更多地细节，可以这样:12345\"licenses\" : [ &#123; \"type\" : \"MyLicense\" , \"url\" : \"http://github.com/owner/project/path/to/license\" &#125;] repository指定你的代码存放的地方。这个对希望贡献的人有帮助。如果git仓库在github上，那么npm docs命令能找到你。 这样做： 123456789\"repository\" : &#123; \"type\" : \"git\" , \"url\" : \"http://github.com/isaacs/npm.git\" &#125;\"repository\" : &#123; \"type\" : \"svn\" , \"url\" : \"http://v8.googlecode.com/svn/trunk/\" &#125; URL应该是公开的（即便是只读的）能直接被未经过修改的版本控制程序处理的url。不应该是一个html的项目页面。因为它是给计算机看的。 scripts“scripts”是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令。 参考上面的npm start、npm test命令 更多详细请看 npm-scripts(7) config“config” hash可以用来配置用于包脚本中的跨版本参数。在实例中，如果一个包有下面的配置：1234&#123; \"name\" : \"foo\", \"config\" : &#123; \"port\" : \"8080\" &#125; &#125; 然后有一个“start”命令引用了npm_package_config_port环境变量，用户可以通过npm config set foo:port 8001来重写他。 参见 npm-config(7) 和 npm-scripts(7) dependencies依赖是给一组包名指定版本范围的一个hash。这个版本范围是一个由一个或多个空格分隔的字符串。依赖还可以用tarball或者git URL。 请不要将测试或过渡性的依赖放在dependencieshash中。见下文的devDependencies 详见semver(7). version 必须完全和version一致 version 必须比version大 =version 同上 &lt;version 同上 &lt;=version 同上 ~version 大约一样，见semver(7) 1.2.x 1.2.0, 1.2.1, 等，但不包括1.3.0 http://… 见下文’依赖URL’ * 所有 “” 空，同* version1 - version2 同 &gt;=version1 &lt;=version2. range1 || range2 二选一。 git… 见下文’依赖Git URL’ user/repo 见下文’GitHub URLs’ 比如下面都是合法的： 12345678910111213&#123; \"dependencies\" : &#123; \"foo\" : \"1.0.0 - 2.9999.9999\" , \"bar\" : \"&gt;=1.0.2 &lt;2.1.2\" , \"baz\" : \"&gt;1.0.2 &lt;=2.3.4\" , \"boo\" : \"2.0.1\" , \"qux\" : \"&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0\" , \"asd\" : \"http://asdf.com/asdf.tar.gz\" , \"til\" : \"~1.2\" , \"elf\" : \"~1.2.3\" , \"two\" : \"2.x\" , \"thr\" : \"3.3.x\" &#125;&#125; devDependencies如果有人要使用你的模块，那么他们可能不需要你开发使用的外部测试或者文档框架。 在这种情况下，最好将这些附属的项目列在devDependencies中。 这些东西会在执行npm link或者npm install的时候初始化，并可以像其他npm配置参数一样管理。详见npm-config(7)。 对于非特定平台的构建步骤，比如需要编译CoffeeScript，可以用prepublish脚本去实现，并把它依赖的包放在devDependency中。（译者注：prepublish定义了在执行npm publish的时候先行执行的脚本） 比如： 123456789101112&#123; \"name\": \"ethopia-waza\", \"description\": \"a delightfully fruity coffee varietal\", \"version\": \"1.2.3\", \"devDependencies\": &#123; \"coffee-script\": \"~1.6.3\" &#125;, \"scripts\": &#123; \"prepublish\": \"coffee -o lib/ -c src/waza.coffee\" &#125;, \"main\": \"lib/waza.js\"&#125; prepublish脚本会在publishing前运行，这样用户就不用自己去require来编译就能使用。并且在开发模式中（比如本地运行npm install）会运行这个脚本以便更好地测试。 参考资料 https://docs.npmjs.com/#cli https://github.com/ericdum/mujiang.info/issues/6/ https://segmentfault.com/a/1190000004221514","categories":[{"name":"node学习之路","slug":"node学习之路","permalink":"https://zhaomenghuan.github.io/categories/node学习之路/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://zhaomenghuan.github.io/tags/npm/"}]},{"title":"探秘JavaScript中的六个字符","slug":"探秘JavaScript中的六个字符","date":"2016-10-11T16:00:00.000Z","updated":"2017-05-04T06:56:34.531Z","comments":true,"path":"2016/10/12/探秘JavaScript中的六个字符/","link":"","permalink":"https://zhaomenghuan.github.io/2016/10/12/探秘JavaScript中的六个字符/","excerpt":"","text":"本文为译文，原文地址： http://jazcash.com/a-javascript-journey-with-only-six-characters/ JavaScript 是一个奇怪而有趣的语言，我们可以写一些疯狂却仍然有效的代码。它试图帮助我们把事情转换到基于我们如何对待他们的特定类型。 如果我们添加一个字符串,JavaScript会假定我们希望为文本形式表示,所以将它转换为一个字符串。如果我们添加一个正负前缀符号,JavaScript会假定我们希望为数值形式表示,如果可能的话,对我们来说并将字符串转换为一个数字。如果我们添加一个否定符号，JavaScript会将将字符串转换为一个布尔值。 我们可以使用Javascript中[,],(,),! and +这六个符号写一些神奇的代码。如果你现在不是在手机，你可以打开浏览器的控制台，你可以将任何代码示例粘贴到控制台，并且代码值为true。 让我们从最基本的开始，要记住一些黄金规则: !后面跟的字符会被转换成布尔值 +后面跟的字符会被转换成数值 []后面跟的字符会被转换成字符串 来看下面的例子： 123![] === false+[] === 0[]+[] === \"\" 另一件事你应该知道的是,它可以从字符串使用方括号检索特定的字母，像这样： 1\"hello\"[0] === \"h\" 还记得可以使多个数字号码通过添加字符串表示在一起,然后把整个表达式转换成一个数字： 1+(\"1\" + \"1\") === 11 我们们继续把一些东西结合在一起得到字母a 12345![] === false![]+[] === \"false\"+!![] === 1------------------------(![]+[])[+!![]] === \"a\" // same as \"false\"[1] 举一反三！ 我们可以通过true 和 false得到相似的字母a,e,f,l,r,s,t,u，那么我们可以从其他地方得到的字母吗？ 我们可以通过一些特别的式子如[][[]]得到undefined，利用我们上面讲到的黄金法则得到另外的字母d,i 和 n。 1`[][[]] + [] === \"undefined\"` 到目前为止，利用我们已经获得的所有字母,我们可以拼fill, filter 和 find。当然也有一些其他的单词，我们也可以拼写，但这些单词最重要的是,他们都是数组的方法。这意味着他们是数组对象的一部分,可以直接调用数组实例，如：[2,1].sort()。 现在，了解JavaScript的另一件重要的特性是一个对象的属性可以通过点符号.或方括号[]访问。上述数组方法是数组对象本身的属性，我们可以使用方括号代替点符号调用这些方法。 所以[2,1][&quot;sort&quot;]() 等效于 [2,1].sort(). 我们继续看看,当我们试图使用一个数组的方法会发生什么,我们可以使用到目前为止我们拼写的但没有调用的字母。 1[][\"fill\"] 这会得到function fill() { [native code] }，我们可以把这个方法头作为一个字符串再次使用我们的黄金法则： 1[][\"fill\"]+[] === \"function fill() &#123; [native code] &#125;\" 所以现在我们又得到其他的字符：c,o,v,(,),{,[,],}。 随着我们新得到的c和o，我们现在可以形成constructor这个单词。构造函数是一个方法,所有JS对象仅返回自己的构造函数。 到目前为止我们已经处理的对象，我们可以得到它用字符串表示的构造器函数： 12345true[\"constructor\"] + [] === \"function Boolean() &#123; [native code] &#125;\" 0[\"constructor\"] + [] === \"function Number() &#123; [native code] &#125;\" \"\"[\"constructor\"] + [] === \"function String() &#123; [native code] &#125;\"[][\"constructor\"] + [] === \"function Array() &#123; [native code] &#125;\"(&#123;&#125;)[\"constructor\"] + [] === \"function Object() &#123; [native code] &#125;\" 通过这些式子，我们可以将下面的字符加入到我们的库中：B,N,S,A,O,m,b,g,y,j。 现在我们可以构造一个我们可以使用方括号的函数”toString”`,我们可以这样调用： 1(10)[\"toString\"]() === \"10\" 使用我们的黄金法则，我们已经可以将任何我们想要转换成一个字符串，但是上面这个式子怎么用呢？ 好吧，我告诉你，Number类型的toString方法有一个称为radix(“基数”)的秘密的论点。它可以将数值在转换为一个字符串之前先经过基数换算，像这样： 1234(12)[\"toString\"](10) === \"12\" // 十进制(12)[\"toString\"](2) === \"1100\" // 二进制(12)[\"toString\"](8) === \"14\" // 八进制(12)[\"toString\"](16) === \"c\" // 十六进制 但是为什么基数只写到16？最大值是36，包括所有的字符0-9 和 a-z，所以现在我们可以得到任何我们想要的字母数字： 12(10)[\"toString\"](36) === \"a\"(35)[\"toString\"](36) === \"z\" 太棒了!但是其它符号如标点符号和大写字母呢？我们接着深入探索。 这取决于你的JS执行时，它可能会或可能不会访问特定的预定义的对象或数据。如果你在浏览器中运行它,那么你可以访问一些存在的HTML包装器方法。 例如，bold是一个包装在&lt;&gt;标签中的字符串方法。 1\"test\"[\"bold\"]() === \"&lt;b&gt;test&lt;/b&gt;\" 通过这个我们得到&lt;&gt;和/两个字符。 你可能听说过escape方法，它主要将字符串转换为一个URI友好的格式，可以让简单的浏览器解释。如果我们传递一个空格字符，我们得到的”%20”。 这里有一个工具可以自动将每个字符自动转换。工具地址：http://www.jsfuck.com/源代码地址：https://raw.githubusercontent.com/aemkei/jsfuck/master/jsfuck.js 为什么这几个字符有用？它不是易趣网做的一些不好的事情,不久前允许卖家将执行JS在页面中使用只能使用这些字符，但它是一个相当罕见的攻击向量。有些人说混淆，但事实上，有更好的方法混淆。 最后，希望你会喜欢本次探秘之旅。 参考资料 https://en.wikipedia.org/wiki/JSFuck https://esolangs.org/wiki/JSFuck http://patriciopalladino.com/blog/2012/08/09/non-alphanumeric-javascript.html https://raw.githubusercontent.com/aemkei/jsfuck/master/jsfuck.js","categories":[{"name":"JavaScript进阶学习","slug":"JavaScript进阶学习","permalink":"https://zhaomenghuan.github.io/categories/JavaScript进阶学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhaomenghuan.github.io/tags/JavaScript/"}]},{"title":"node学习之路（一）—— 网络请求","slug":"node学习之路（一）—网络请求","date":"2016-09-28T16:00:00.000Z","updated":"2017-05-12T06:47:42.935Z","comments":true,"path":"2016/09/29/node学习之路（一）—网络请求/","link":"","permalink":"https://zhaomenghuan.github.io/2016/09/29/node学习之路（一）—网络请求/","excerpt":"","text":"前言一直以来想深入学习一下node，一来是自己目前也没有什么时间去学习服务器端语言，但是有时候又想自己撸一下服务器端，本着爱折腾的精神开始写一写关于node的文章记录学习心得。本系列文章不会过多去讲解node安装、基本API等内容，而是通过一些实例去总结常用用法。本文主要讲解node网络操作的相关内容，node中的网络操作依赖于http模块，http模块提供了两种使用方式： 作为服务器端使用，创建一个http服务器，监听http客户端请求并返回响应； 作为客户端使用，发起一个http客户端请求，获取服务器端响应。 node http模块创建服务器node 处理 get 请求实例毕竟作为一个前端，我们经常需要自己搭建一个服务器做测试，这里我们先来讲一下node http模块作为服务器端使用。首先我们需要，使用createServer创建一个服务，然后通过listen监听客服端http请求。 我们可以创建一个最简单的服务器，在页面输出hello world，我们可以创建helloworld.js，内容如下：123456var http = require('http');http.createServer(function(request, response)&#123; response.writeHead(200, &#123; 'Content-Type': 'text-plain' &#125;); response.end('hello world!')&#125;).listen(8888); 在命令行输入node helloworld.js即可，我们打开在浏览器打开http://127.0.0.1:8888/就可以看到页面输出hello world!。 下面我们在本地写一个页面，通过jsonp访问我们创建的node服务器：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"output\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 创建script标签 function importScript(src)&#123; var el = document.createElement('script'); el.src = src; el.async = true; el.defer = true; document.body.appendChild(el); &#125; // 响应的方法 function jsonpcallback(rs) &#123; console.log(JSON.stringify(rs)); document.getElementById(\"output\").innerHTML = JSON.stringify(rs); &#125; // 发起get请求 importScript('http://127.0.0.1:8888?userid=xiaoqingnian&amp;callback=jsonpcallback'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们当然需要将上述node服务器中的代码稍作修改：1234567891011121314151617181920212223242526var http = require('http'); // 提供web服务var url = require('url'); // 解析GET请求 var data = &#123; 'name': 'zhaomenghuan', 'age': '22'&#125;; http.createServer(function(req, res)&#123; // 将url字符串转换成Url对象 var params = url.parse(req.url, true); console.log(params); // 查询参数 if(params.query)&#123; // 根据附件条件查询 if(params.query.userid === 'xiaoqingnian')&#123; // 判断是否为jsonp方式请求，若是则使用jsonp方式，否则为普通web方式 if (params.query.callback) &#123; var resurlt = params.query.callback + '(' + JSON.stringify(data) + ')'; res.end(resurlt); &#125; else &#123; res.end(JSON.stringify(data)); &#125; &#125; &#125; &#125;).listen(8888); 我们在命令行可以看到：12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?userid=xiaoqingnian&amp;callback=jsonpcallback', query: &#123; userid: 'xiaoqingnian', callback: 'jsonpcallback' &#125;, pathname: '/', path: '/?userid=xiaoqingnian&amp;callback=jsonpcallback', href: '/?userid=xiaoqingnian&amp;callback=jsonpcallback' &#125; 经过服务器端jsonp处理，然后返回一个函数：1jsonpcallback(&#123;\"name\":\"zhaomenghuan\",\"age\":\"22\"&#125;) 而我们在页面中定义了一个jsonpcallback()的方法，所以当我们在请求页面动态生成script调用服务器地址，这样相当于在页面执行了下我们定义的函数。jsonp的实现原理主要是script标签src可以跨域执行代码，类似于你引用js库，然后调用这个js库里面的方法；这是这里我们可以认为反过来了，你是在本地定义函数，调用的逻辑通过服务器返回的一个函数执行了，所以jsonp并没有什么神奇的，和XMLHttpRequest、ajax半毛钱关系都没有，而且JSONP需要服务器端支持，始终是无状态连接，不能获悉连接状态和错误事件，而且只能走GET的形式。 node 处理 post 请求实例当然这里我们可以直接在后台设置响应头进行跨域（CORS），如：1234567891011121314151617181920212223var http = require(\"http\"); // 提供web服务var query = require(\"querystring\"); // 解析POST请求http.createServer(function(req,res)&#123; // 报头添加Access-Control-Allow-Origin标签，值为特定的URL或\"*\"(表示允许所有域访问当前域) res.setHeader(\"Access-Control-Allow-Origin\",\"*\"); var postdata = ''; // 一旦监听器被添加，可读流会触发 'data' 事件 req.addListener(\"data\",function(chunk)&#123; postdata += chunk; &#125;) // 'end' 事件表明已经得到了完整的 body req.addListener(\"end\",function()&#123; console.log(postdata); // 'appid=xiaoqingnian' // 将接收到参数串转换位为json对象 var params = query.parse(postdata); if(params.userid == 'xiaoqingnian')&#123; res.end('&#123;\"name\":\"zhaomenghuan\",\"age\":\"22\"&#125;'); &#125; &#125;) &#125;).listen(8080); 我们通过流的形式接收前端post传递的参数，通过监听data和end事件，后面在讲解event模块的时候再深入探究。 CORS默认只支持GET/POST这两种http请求类型，如果要开启PUT/DELETE之类的方式，需要在服务端在添加一个”Access-Control-Allow-Methods”报头标签：1234res.setHeader( \"Access-Control-Allow-Methods\", \"PUT, GET, POST, DELETE, HEAD, PATCH\"); 前端访问代码如下：1234567891011var xhr = new XMLHttpRequest();xhr.onload = function () &#123; console.log(this.responseText);&#125;;xhr.onreadystatechange = function() &#123; console.log(this.readyState);&#125;;xhr.open(\"post\", \"http://127.0.0.1:8080\", true);xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");xhr.send(\"userid=xiaoqingnian\"); url 模块API详解url.parse——解析url字符串上述代码中比较关键的是我们通过url.parse方法将url字符串转成Url对象，用法如下：1url.parse(urlStr, [parseQueryString], [slashesDenoteHost]) 接收参数： urlStr：url字符串 parseQueryString：参数为true时，query会被解析为JSON格式，否则为普通字符串格式，默认为false；如： 参数为true：query: { userid: &#39;xiaoqingnian&#39;, callback: &#39;jsonpcallback&#39; } 参数为false：query: &#39;userid=xiaoqingnian&amp;callback=jsonpcallback&#39; slashesDenoteHost：默认为false，当url是 ‘http://’ 或 ‘ftp://’ 等标志的协议前缀打头的，或直接以地址打头，如 ‘127.0.0.1’ 或 ‘localhost’ 时候是没有区别的；当且仅当以2个斜杠打头的时候，比如 ‘//127.0.0.1’ 才有区别。这时候，如果其值为true，则第一个单个 ‘/’ 之前的部分被解析为 ‘host’ 和 ‘hostname’，如 ” host : ‘127.0.0.1’ “，如果为false，包括2个反斜杠在内的所有字符串被解析为pathname。如：12345678910111213141516171819202122232425262728&gt; url.parse('//www.foo/bar',true,true)Url &#123; protocol: null, slashes: true, auth: null, host: 'www.foo', port: null, hostname: 'www.foo', hash: null, search: '', query: &#123;&#125;, pathname: '/bar', path: '/bar', href: '//www.foo/bar' &#125;&gt; url.parse('//www.foo/bar',true,false)Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '', query: &#123;&#125;, pathname: '//www.foo/bar', path: '//www.foo/bar', href: '//www.foo/bar' &#125; 这里的URL对象和浏览器中的location对象类似，location中如果我们需要使用类似的方法，我们需要自己构造。 url.format——格式化URL对象我们可以通过url.format方法将一个解析后的URL对象格式化成url字符串，用法为：1url.format(urlObj) 例子：1234567891011121314151617url.format(&#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/p/a/t/h', path: '/p/a/t/h?query=string', href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' &#125;)结果为：'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' url.resolve——拼接url字符串我们可以通过url.resolve为URL或 href 插入 或 替换原有的标签，接收参数：from源地址，to需要添加或替换的标签。1url.resolve(from, to) 例子为：123456url.resolve('/one/two/three', 'four')=&gt; '/one/two/four'url.resolve('http://example.com/', '/one') =&gt; 'http://example.com/one'url.resolve('http://example.com/one', '/two') =&gt; 'http://example.com/two' Query String 模块Query Stringquerystring.escape——字符串编码12querystring.escape('appkey=123&amp;version=1.0.0+')// 'appkey%3D123%26version%3D1.0.0%2B' querystring.unescape——字符串解码12querystring.unescape('appkey%3D123%26version%3D1.0.0%2B')// 'appkey=123&amp;version=1.0.0+' querystring.stringify(querystring.encode)——序列化对象12querystring.stringify(obj[, sep][, eq][, options])querystring.encode(obj[, sep][, eq][, options]) 接收参数： obj： 欲转换的对象 sep：设置分隔符，默认为 ‘&amp;’ eq：设置赋值符，默认为 ‘=’ 12345querystring.stringify(&#123;foo: 'bar', baz: ['qux', 'quux'], corge: ''&#125;)// 'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='querystring.stringify(&#123;foo: 'bar', baz: ['qux', 'quux'], corge: ''&#125;,',',':')// 'foo:bar,baz:qux,baz:quux,corge:' querystring.parse(querystring.decode)——解析query字符串12querystring.parse(str[, sep][, eq][, options])querystring.decode(str[, sep][, eq][, options]) 接收参数： str：欲转换的字符串 sep：设置分隔符，默认为 ‘&amp;’ eq：设置赋值符，默认为 ‘=’ [options] maxKeys 可接受字符串的最大长度，默认为1000 12345querystring.parse('foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=')// &#123; foo: 'bar', baz: [ 'qux', 'quux' ], corge: '' &#125;querystring.parse('foo:bar,baz:qux,baz:quux,corge:',',',':')&#123; foo: 'bar', baz: [ 'qux', 'quux' ], corge: '' &#125; node http模块发起请求平时喜欢看博客，毕竟买书要钱而且有时候没有耐心读完整本书，所以很喜欢逛一些网站，但是很多时候把所有的站逛一下又没有那么多时间，哈哈，所以就准备把常去的网站的文章爬出来做一个文章列表，一来省去收集的时间，二来借此熟悉熟悉node相关的东西。这里我们首先看一个爬虫的小例子，下面以SF为例加以说明（希望不要被封号）。 http.request与http.get的区别http.request(options, callback)options可以是一个对象或一个字符串。如果options是一个字符串, 它将自动使用url.parse()解析。http.request() 返回一个 http.ClientRequest类的实例。ClientRequest实例是一个可写流对象。如果需要用POST请求上传一个文件的话，就将其写入到ClientRequest对象。使用http.request()方法时都必须总是调用req.end()以表明这个请求已经完成，即使响应body里没有任何数据。如果在请求期间发生错误（DNS解析、TCP级别的错误或实际HTTP解析错误），在返回的请求对象会触发一个’error’事件。 Options配置说明： host：请求发送到的服务器的域名或IP地址。默认为’localhost’。 hostname：用于支持url.parse()。hostname比host更好一些 port：远程服务器的端口。默认值为80。 localAddress：用于绑定网络连接的本地接口。 socketPath：Unix域套接字（使用host:port或socketPath） method：指定HTTP请求方法的字符串。默认为’GET’。 path：请求路径。默认为’/‘。如果有查询字符串，则需要包含。例如’/index.html?page=12’。请求路径包含非法字符时抛出异常。目前，只否决空格，不过在未来可能改变。 headers：包含请求头的对象。 auth：用于计算认证头的基本认证，即’user:password’ agent：控制Agent的行为。当使用了一个Agent的时候，请求将默认为Connection: keep-alive。可能的值为： undefined（默认）：在这个主机和端口上使用[全局Agent][]。 Agent对象：在Agent中显式使用passed。 false：在对Agent进行资源池的时候，选择停用连接，默认请求为：Connection: close。 keepAlive：{Boolean} 保持资源池周围的套接字在未来被用于其它请求。默认值为false keepAliveMsecs：{Integer} 当使用HTTP KeepAlive的时候，通过正在保持活动的套接字发送TCP KeepAlive包的频繁程度。默认值为1000。仅当keepAlive被设置为true时才相关。 http.get(options, callback)因为大部分的请求是没有报文体的GET请求，所以Node提供了这种便捷的方法。该方法与http.request()的唯一区别是它设置的是GET方法并自动调用req.end()。 爬虫实例这里我们使用es6的新特性写：1234567891011121314const https = require('https');https.get('https://segmentfault.com/blogs', (res) =&gt; &#123; console.log('statusCode: ', res.statusCode); console.log('headers: ', res.headers); var data = ''; res.on('data', (chunk) =&gt; &#123; data += chunk; &#125;); res.on('end', () =&gt; &#123; console.log(data); &#125;)&#125;).on('error', (e) =&gt; &#123; console.error(e);&#125;); 这样一小段代码我们就可以拿到segmentfault的博客页面的源码，需要说明的是因为这里请求的网站是https协议，所以我们需要引入https模块，用法同http一致。下面需要做的是解析html代码，下面我们需要做的就是解析源码，这里我们可以引入cheerio，一个node版的类jQuery模块，npm地址：https://www.npmjs.com/package/cheerio。 首先第一步安装：1npm install cheerio 然后就是将html代码load进来，如下：12var cheerio = require('cheerio'),var $ = cheerio.load(html); 最后我们就是分析dom结构咯，通过类似于jQuery的方法获取DOM元素的内容，然后就将数据重新组装成json结构的数据。这里就是分析源码然后，这里我就不详细分析了，直接上代码： 123456789101112131415161718192021222324252627282930313233343536function htmlparser(html)&#123; var baseUrl = 'https://segmentfault.com'; var $ = cheerio.load(html); var bloglist = $('.stream-list__item'); var data = []; bloglist.each(function(item)&#123; var page = $(this); var summary = page.find('.summary'); var blogrank = page.find('.blog-rank'); var title = summary.find('.title a').text(); var href = baseUrl + summary.find('.title a').attr('href'); var author = summary.find('.author li a').first().text().trim(); var origin = summary.find('.author li a').last().text().trim(); var time = summary.find('.author li span')[0].nextSibling.data.trim(); var excerpt = summary.find('p.excerpt').text().trim(); var votes = blogrank.find('.votes').text().trim(); var views = blogrank.find('.views').text().trim(); data.push(&#123; title: title, href: href, author: author, origin: origin, time: time, votes: votes, views: views, excerpt: excerpt &#125;) &#125;) return data;&#125; 结果如下：123456789101112[&#123; title: '转换流', href: 'https://segmentfault.com/a/1190000007036273', author: 'SwiftGG翻译组', origin: 'SwiftGG翻译组', time: '1 小时前', votes: '0推荐', views: '14浏览', excerpt: '作者：Erica Sadun，原文链接，原文日期：2016-08-29译者：Darren；校对：shanks；定稿：千叶知风 我在很多地方都表达了我对流的喜爱。我在 Swift Cookbook 中介绍了一些。现在，我将通过 Pearson 的内容更新计划...' &#125;,......] 这里我们只是抓取了文章列表的一页，如果需要抓取多页，只需要将内容再次封装一下，传入一个地址参数?page=2，如：https://segmentfault.com/blogs?page=2另外我们也没有将详情页进一步爬虫，毕竟文章的目的只是学习，同时方便自己查看列表，这里保留原始地址。 温馨提示：大家不要都拿sf做测试哦，不然玩坏了就不好。 模拟登陆哈哈，写到这里已经很晚了，用node试了试模拟登陆SF，结果404，暂时没有什么思路，等有时间再试试专门开篇讲解咯。这里推荐一篇之前看到的文章：记一次用 NodeJs 实现模拟登录的思路。 参考 nodejs官网API文档 进击Node.js基础（一） Node.js v4.2.4 文档 中文版 文章代码源码下载：http://zhaomenghuan.github.io/resource/blog/demo/20160929.zip","categories":[{"name":"node学习之路","slug":"node学习之路","permalink":"https://zhaomenghuan.github.io/categories/node学习之路/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhaomenghuan.github.io/tags/JavaScript/"},{"name":"node.js","slug":"node-js","permalink":"https://zhaomenghuan.github.io/tags/node-js/"},{"name":"http","slug":"http","permalink":"https://zhaomenghuan.github.io/tags/http/"},{"name":"url","slug":"url","permalink":"https://zhaomenghuan.github.io/tags/url/"},{"name":"Query String","slug":"Query-String","permalink":"https://zhaomenghuan.github.io/tags/Query-String/"},{"name":"爬虫","slug":"爬虫","permalink":"https://zhaomenghuan.github.io/tags/爬虫/"}]},{"title":"录音文件与Base64编码相互转换的方法","slug":"录音文件与Base64编码相互转换的方法","date":"2016-08-16T16:00:00.000Z","updated":"2017-05-03T16:17:28.185Z","comments":true,"path":"2016/08/17/录音文件与Base64编码相互转换的方法/","link":"","permalink":"https://zhaomenghuan.github.io/2016/08/17/录音文件与Base64编码相互转换的方法/","excerpt":"","text":"前言最近有几个朋友一直在问语音文件怎么转base64字符串进行发送上传，base64字符串又如何转成文件，论坛中已经有多篇问题的帖子有介绍，这里只是稍微整理，方便大家可以更加方便的使用，首先看效果： Alt text 录音文件转成base64字符串hello mui 演示app中im-chat.html有演示案例，通过hold和release控制录音的长度，即长按按钮开始录音，释放就停止录音，上拉取消发送录音。 html部分：1&lt;button id=\"recorder\" type=\"button\" class=\"mui-btn mui-btn-blue mui-btn-block\"&gt;录制语音文件转base64字符串&lt;/button&gt; js部分： mui.init中首先需要配置手势事件：1234567891011mui.init(&#123; gestureConfig: &#123; tap: true, //默认为true doubletap: true, //默认为false longtap: true, //默认为false swipe: true, //默认为true drag: true, //默认为true hold: true, //默认为false，不监听 release: true //默认为false，不监听 &#125;&#125;); 录音逻辑控制，按住按钮弹出录音提示框，并且对录音时长进行控制，录音时间太短取消操作，手指上划，取消发送。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var MIN_SOUND_TIME = 800;var recorder = null;var startTimestamp = null;var stopTimestamp = null;var stopTimer = null;var recordCancel = false;var soundAlert = document.getElementById(\"sound-alert\");var audioTips = document.getElementById(\"audio-tips\");// 控制录音弹出框是否播放var setSoundAlertVisable=function(show)&#123; if(show)&#123; soundAlert.style.display = 'block'; soundAlert.style.opacity = 1; &#125;else&#123; soundAlert.style.opacity = 0; // 完成再真正隐藏 setTimeout(function()&#123; soundAlert.style.display = 'none'; &#125;,200); &#125;&#125;;mui.plusReady(function () &#123; /** * 录制语音文件转base64字符串 */ // 按住录音（长按开始录音） document.querySelector('#recorder').addEventListener('hold',function () &#123; recordCancel = false; if(stopTimer)clearTimeout(stopTimer); audioTips.innerHTML = \"手指上划，取消发送\"; soundAlert.classList.remove('rprogress-sigh'); setSoundAlertVisable(true); // 获取当前设备的录音对象 recorder = plus.audio.getRecorder(); startTimestamp = (new Date()).getTime(); recorder.record(&#123; filename:\"_doc/audio/\", format:\"amr\" //iOS平台支持\"wav\"、\"aac\"、\"amr\"格式，默认为\"wav\" &#125;, function (path) &#123; if (recordCancel) return; console.log(\"path:\"+path); Audio2dataURL(path); &#125;, function ( e ) &#123; mui.toast(\"录音出现异常: \" + e.message ); &#125;); &#125;) // 释放保存（松手保存） document.querySelector('#recorder').addEventListener('release',function () &#123; if (audioTips.classList.contains(\"cancel\")) &#123; audioTips.classList.remove(\"cancel\"); audioTips.innerHTML = \"手指上划，取消发送\"; &#125; // 判断录音时间 stopTimestamp = (new Date()).getTime(); if (stopTimestamp - startTimestamp &lt; 800) &#123; audioTips.innerHTML = \"录音时间太短\"; soundAlert.classList.add('rprogress-sigh'); recordCancel = true; stopTimer=setTimeout(function()&#123; setSoundAlertVisable(false); &#125;,800); &#125;else&#123; setSoundAlertVisable(false); &#125; recorder.stop(); &#125;) // 拖动屏幕（手指上划，取消发送） document.body.addEventListener('drag', function(event) &#123; if (Math.abs(event.detail.deltaY) &gt; 50) &#123; if (!recordCancel) &#123; recordCancel = true; if (!audioTips.classList.contains(\"cancel\")) &#123; audioTips.classList.add(\"cancel\"); &#125; audioTips.innerHTML = \"松开手指，取消发送\"; &#125; &#125; else &#123; if (recordCancel) &#123; recordCancel = false; if (audioTips.classList.contains(\"cancel\")) &#123; audioTips.classList.remove(\"cancel\"); &#125; audioTips.innerHTML = \"手指上划，取消发送\"; &#125; &#125; &#125;, false);&#125;) 当录音成功后，我们可以将录音文件转成base64字符串，用于网络传输。1234567891011121314151617/** * 录音语音文件转base64字符串 * @param &#123;Object&#125; path */function Audio2dataURL (path) &#123; plus.io.resolveLocalFileSystemURL(path, function(entry)&#123; entry.file(function(file)&#123; var reader = new plus.io.FileReader(); reader.onloadend = function (e) &#123; console.log(e.target.result); &#125;; reader.readAsDataURL(file); &#125;,function(e)&#123; mui.toast(\"读写出现异常: \" + e.message ); &#125;) &#125;)&#125; 至此我们完成了录音语音文件转base64字符串，反过来我们需要将base64字符串转成语音文件。 base64字符串转成语音文件我们可以封装如下方法： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * base64字符串转成语音文件(参考http://ask.dcloud.net.cn/question/16935) * @param &#123;Object&#125; base64Str * @param &#123;Object&#125; callback */function dataURL2Audio (base64Str, callback) &#123; var base64Str = base64Str.replace('data:audio/amr;base64,',''); var audioName = (new Date()).valueOf() + '.amr'; plus.io.requestFileSystem(plus.io.PRIVATE_DOC,function(fs)&#123; fs.root.getFile(audioName,&#123;create:true&#125;,function(entry)&#123; // 获得平台绝对路径 var fullPath = entry.fullPath; if(mui.os.android)&#123; // 读取音频 var Base64 = plus.android.importClass(\"android.util.Base64\"); var FileOutputStream = plus.android.importClass(\"java.io.FileOutputStream\"); try&#123; var out = new FileOutputStream(fullPath); var bytes = Base64.decode(base64Str, Base64.DEFAULT); out.write(bytes); out.close(); // 回调 callback &amp;&amp; callback(entry); &#125;catch(e)&#123; console.log(e.message); &#125; &#125;else if(mui.os.ios)&#123; var NSData = plus.ios.importClass('NSData'); var nsData = new NSData(); nsData = nsData.initWithBase64EncodedStringoptions(base64Str,0); if (nsData) &#123; nsData.plusCallMethod(&#123;writeToFile: fullPath,atomically:true&#125;); plus.ios.deleteObject(nsData); &#125; // 回调 callback &amp;&amp; callback(entry); &#125; &#125;) &#125;)&#125; 调用方法如下： html部分：1&lt;button id=\"player\" type=\"button\" class=\"mui-btn mui-btn-blue mui-btn-block\"&gt;base64字符串转成语音文件播放&lt;/button&gt; js部分：123456789101112131415161718192021222324252627/** * base64字符串转成语音文件播放 */document.querySelector('#player').addEventListener('tap',function () &#123; // 语音文件Base64编码（由于编码过长影响阅读体验，请查看工程验证） var base64Str = ' ' // 转成.amr文件播放 dataURL2Audio(base64Str, function(entry)&#123; var toURL = entry.toURL(); // 播放音频 playAudio(toURL); &#125;)&#125;)/** * 播放音频 * @param &#123;Object&#125; path */function playAudio (path) &#123; var player = plus.audio.createPlayer(path); player.play(function()&#123; mui.toast(\"播放成功\"); &#125;, function(e) &#123; mui.toast(\"播放失败\"); &#125;); &#125; 写在后面本文以语音文件为例说明5+中语音文件与Base64编码的相互转换，对于图片与Base64编码的转换方法请参考nativeObj Bitmap: 原生图片对象，可以通过loadBase64Data方法加载Base64编码格式图片到Bitmap对象，通过toBase64Data方法获取图片的Base64编码数据。对于一般性文件，建议使用h5 File API，详细可以参考我这篇文章：JavaScript进阶学习（三）—— 基于html5 File API的文件操作 本文详细代码请查看这里：演示工程。","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"html5plus","slug":"html5plus","permalink":"https://zhaomenghuan.github.io/tags/html5plus/"},{"name":"base64","slug":"base64","permalink":"https://zhaomenghuan.github.io/tags/base64/"},{"name":"录音","slug":"录音","permalink":"https://zhaomenghuan.github.io/tags/录音/"}]},{"title":"JavaScript进阶学习（三）—— 基于html5 File API文件操作","slug":"JavaScript进阶学习（三）—基于html5 File API文件操作","date":"2016-08-15T16:00:00.000Z","updated":"2017-05-03T16:15:01.556Z","comments":true,"path":"2016/08/16/JavaScript进阶学习（三）—基于html5 File API文件操作/","link":"","permalink":"https://zhaomenghuan.github.io/2016/08/16/JavaScript进阶学习（三）—基于html5 File API文件操作/","excerpt":"","text":"写在前面这段时间一直有朋友在问文件上传下载的事，搜一下论坛发现相关的问题不少，但是不够系统，本着为人民服务的态度本文试着将一些问题整理一下，争取用初学者可以更明确的去处理相关的问题。文件上传是开发中绕不过的一个坎儿，对于很多没有经验的人来说，简直懵逼，目前我所知道的上传方式有下面这几种： 传统flash上传 隐藏iframe框上传 表单数据提交 HTML5的新工具——File API 本文限于篇幅先介绍最后一种使用html5 File API进行文件上传的相关细节。 历史上，JavaScript无法处理二进制数据。如果一定要处理的话，只能使用charCodeAt()方法，一个个字节地从文字编码转成二进制数据，还有一种办法是将二进制数据转成Base64编码，再进行处理。这两种方法不仅速度慢，而且容易出错。ECMAScript 5引入了Blob对象，允许直接操作二进制数据。Blob对象是一个代表二进制数据的基本对象，在它的基础上，又衍生出一系列相关的API，用来操作文件。 File API File 接口提供了文件的信息，以及文件内容的存取方法。 File对象可以用来获取某个文件的信息，还可以用来读取这个文件的内容。通常情况下，File对象是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以是来自由拖放操作生成的 DataTransfer对象. 通过input file标签选择文件默认的input file标签比较难看，需要自己改造，一般无非是将input file设置宽高，然后使用overflow: hidden;将多余的部分隐藏，在上面再盖一个美化的按钮或者提示语，如下图： 浏览器原生的效果： origin 经过美化的效果： beautify 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0px; padding: 0px; &#125; .filePicker&#123; width: 160px; height: 44px; line-height: 44px; text-align: center; color: #fff; background: #00b7ee; &#125; .filePicker input[type=\"file\"] &#123; position: relative; top: -44px; left: 0px; width: 160px; height: 44px; opacity: 0; cursor: pointer; overflow: hidden; z-index: 0; &#125; .container&#123; width: 160px; margin: 30px auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;input type=\"file\" name=\"\" id=\"\" value=\"\" /&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"filePicker\"&gt; &lt;label&gt;点击选择文件&lt;/label&gt; &lt;input id=\"fileInput\" type=\"file\" name=\"file\" multiple=\"multiple\" accept=\"image/*\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 我们可以通过给input file标签设置accept属性进行文件选择过滤，该属性的值必须为一个逗号分割的列表,包含了多个唯一的内容类型声明： 以 STOP 字符 (U+002E) 开始的文件扩展名。（例如：”.jpg,.png,.doc”） 一个有效的 MIME 类型，但没有扩展名 audio/* 表示音频文件 HTML5 video/* 表示视频文件 HTML5 image/* 表示图片文件 设置multiple属性可以进行设置是单选还是多选。 通过File API,我们可以在用户选取一个或者多个文件之后,访问到代表了所选文件的一个或多个File对象，这些对象被包含在一个FileList对象中。所有type属性(attribute)为file的&lt;input&gt;元素都有一个files属性，用来存储用户所选择的文件。files有一个length属性和item方法，我们可以通过files[index]或者files.item(index)获取我们选择的file对象。可以通过change事件监听input file输入完成事件：123456var fileInput = document.getElementById(\"fileInput\");fileInput.addEventListener('change', function(event) &#123; var file = fileInput.files[0]; // 或file = fileInput.files.item(0); console.log(file);&#125;, false); File API提供File对象，它是FileList对象的成员，包含了文件的一些元信息，比如文件名、上次改动时间、文件大小和文件类型。下图File对象的属性： file lastModifiedDate：文件对象最后修改的日期 name：文件名,只读字符串,不包含任何路径信息. size：文件大小,单位为字节,只读的64位整数. type：MIME类型,只读字符串,如果类型未知,则返回空字符串. 例如：我们可以根据size换算出我们习惯的文件大小表达方式：1234567891011121314/** * 读文件大小 * @param &#123;Object&#125; file */function readFileSize(file)&#123; var size = file.size / 1024; var aMultiples = [\"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"]; var fileSizeString = ''; for(var i = 0; size &gt; 1; size /= 1024, i++) &#123; fileSizeString = size.toFixed(2) + \" \" + aMultiples[i]; &#125; return fileSizeString;&#125; 有时候我们希望限制用户上传的文件大小，可以通过这个方法先做判断。同时我们可以通过type属性判断用户的文件类型，但是这种方法不可靠，因为用户可以通过改变后缀名实现。 很多新手企图通过input file标签获得文件完整路径，由于浏览器安全机制，这个是不被允许的，但是有时候我们希望选择完图片预览一下图片，这个时候我们就可以用FileReader API实现。 通过拖放操作选择文件预览效果： drop 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .dropbox&#123; width: 300px; height: 300px; margin: 20px; border: 3px dashed #e6e6e6; &#125; .area&#123; margin: 100px auto; width: 100px; height: 100px; background-repeat: no-repeat; background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABLCAIAAAB7tddWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1Q0VBNzA0MjEyMDUxMUUzODk2Q0JFM0Q1RjE4QkExQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1Q0VBNzA0MzEyMDUxMUUzODk2Q0JFM0Q1RjE4QkExQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNDA2MkY1MTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAzNDA2MkY2MTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+K6izdgAAAvpJREFUeNrsnFmPqkAQhWmX667gEp9c/v+/MkSDG+4LrvdcSYgRbw/0ALZQ9WBUJOn+uqvqHGCG3e93hUJRUoSAQBAIAkEgCASBIBAE4neRicEcII51Xb/dbnjPGOt0OqlUKok7ApN3jIKwY6DUIBAEgkAQCALho/X47TeXy8U0TcuyrtdrZKPs9/v2m8FgINYgf9QX/gTV+Xw2DCNKBJKmxmKxsAVc0kEcDgfyGq8CNp/Pa5qWy+WiHG6v13v7/XPt6Ha7Al5D3HQ1Go1sNkvtU8lkMsmtESSoCASBSFqEW/DQ0tbr9W63O51OKK6FQkFV1XQ6nSwQ0OOTyQSvjknZbDaA0mq1QCQafSFFasxmM4eCE1Do0+lUQrcSFggsPhzq20NgsVqtkpIax+MxMs+C/aXruvMxaonND75J9W5hUWWxuYAVdRfTg8EplUphGJywQPAFuBd5Dlhw/aDwwgVtCDgCdzph1QisG+dosVjkn44WYxjGC4XnvBuNRtvt9gtA2Hv47SGsZKVS4ef8eDzG4vMVCrpSgEU3xPbZbDar1erLl1AQ7XabU8xAAXvB3XffBnIHwkR2QcUYq9fr5XIZOxkTg6BEkeNLKdQF7AWPFBy1AoUmu8RG/HmE91nxM+J/ORIr07VcLvf7feCt+stAQGIBRNJtOJolDAhdj/hXGj5+u+TzIKAF+MbkK00XFta2BhDRUE0/9gv8Elogbu4TBW8+nyPhHSeuaVqtVuNQC6TzyQUCXsg0TbfyAxfIKogr9ynP1GJyYQZ57qbg7AuIRfclKZwSlDqWBQSmxM9zFALYh+fFBwJJSkNgqeFxSrAPw+EQ9QJew7Is2Sj8FgSW2nu1gylYPkKRMsRTA+4IcjA2fxsnDkLOq/IfACFP54uP1yAQBIJAEIh4gWCPkHk+GJ7AjU/fICJ+qlIghEfoDwQMtRjvyLYDRih4rsDT+bBM9tP5kuhrzN++e6SqqvCdYUb/SIO6BoEgEASCQBAIAkEgCEQg8VeAAQAB1bbO2qoeewAAAABJRU5ErkJggg==\"); &#125; #preview img&#123; width: 100px; height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"dropbox\" class=\"dropbox\"&gt; &lt;div class=\"area\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=\"preview\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var dropbox = document.getElementById(\"dropbox\"); var preview = document.getElementById(\"preview\"); dropbox.addEventListener(\"dragenter\", function(e)&#123; e.stopPropagation(); e.preventDefault(); &#125;, false); dropbox.addEventListener(\"dragover\", function(e)&#123; e.stopPropagation(); e.preventDefault(); &#125;, false); dropbox.addEventListener(\"drop\", function(e)&#123; e.stopPropagation(); e.preventDefault(); var dt = e.dataTransfer; var files = dt.files; for (var i = 0; i &lt; files.length; i++) &#123; var file = files[i]; var imageType = /^image\\//; if ( !imageType.test(file.type) ) &#123; continue; &#125; // 填充选择的图片到展示区 var img = document.createElement(\"img\"); img.classList.add(\"obj\"); img.file = file; preview.appendChild(img); // 读取File对象中的内容 var reader = new FileReader(); reader.onload = (function(aImg) &#123; return function(e) &#123; aImg.src = e.target.result; &#125;; &#125;)(img); reader.readAsDataURL(file); &#125; &#125;, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在这个例子中，ID 为 dropbox 的元素所在的区域是我们的拖放目的区域。我们需要在该元素上绑定 dragenter，dragover，和drop 事件。我们必须阻止dragenter和dragover事件的默认行为，这样才能触发 drop 事件。我们从drop 事件对象中获取到dataTransfer对象，这个对象包含Filelist对象。 FileReader API 使用FileReader对象,web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容,可以使用File对象或者Blob对象来指定所要处理的文件或数据.其中File对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后的返回结果。 DataURI对象在上面通过拖放操作选择文件的例子中，我们使用了”data:image/png;base64,xxxxxxxxxxxxx”这种形式的字符串作为背景，而不是图片，选择的图片展示也是使用这种形式。这种字符串叫做DataURI对象，允许将一个小文件进行编码后嵌入到另外一个文档里，格式为：1data:[&lt;MIME type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt; 整体可以视为三部分，即声明：参数+数据，逗号左边的是各种参数，右边的是数据。 URL是uniform resource locator的缩写，在web中的每一个可访问资源都有一个URL地址，例如图片，HTML文件，js文件以及style sheet文件，我们可以通过这个地址去download这个资源。其实URL是URI的子集，URI是uniform resource identifier的缩写。URI是用于获取资源，包括其附加的信息的一种协议。附加信息可能是地址，也可能不是地址，如果是地址，那么这时URI就变成URL了。注意的是data URI不是URL，因为它并不包含资源的公共地址。 我们可以通过FileReader 的readAsDataURL方法获得：12345var reader = new FileReader();reader.onload = function() &#123; console.log(this.result);&#125;reader.readAsDataURL(file); 有时候我们需要将DataURI对象转blob对象：12345678/** * dataURI 转 blob * @param &#123;Object&#125; dataURI */function dataURItoBlob(dataURI) &#123; var arr = dataURI.split(','), mime = arr[0].match(/:(.*?);/)[1]; return new Blob([atob(arr[1])], &#123;type:mime&#125;);&#125; URL对象我们除了可以使用base64字符串作为内容的DataURI将一个文件嵌入到另外一个文档里，还可以使用URL对象。URL对象用于生成指向File对象或Blob对象的URL。 window.URL.createObjectURL 静态方法会创建一个 DOMString，它的 URL 表示参数中的对象。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示着指定的 File 对象或者 Blob 对象。1var objecturl = window.URL.createObjectURL(file); window.URL.revokeObjectURL 静态方法用来释放一个之前通过调用 window.URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用了。1window.URL.revokeObjectURL(objecturl) 例如：使用对象URL来显示图片：1234567var img = document.createElement(\"img\");img.src = window.URL.createObjectURL(blob);img.height = 60;img.onload = function(e) &#123; window.URL.revokeObjectURL(this.src);&#125;document.body.appendChild(img); FileReader API详解状态常量 EMPTY：值为0，还没有加载任何数据; LOADING：值为0，数据正在被加载; DONE：值为0，已完成全部的读取请求。 属性 error：在读取文件时发生的错误， 只读; readyState：表明FileReader对象的当前状态，值为State constants中的一个，只读； result：取到的文件内容，这个属性只在读取操作完成之后才有效,并且数据的格式取决于读取操作是由哪个方法发起的，只读。 方法 abort()：中止该读取操作.在返回时,readyState属性的值为DONE. readAsArrayBuffer()：开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个ArrayBuffer对象以表示所读取文件的内容. readAsBinaryString()：开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含所读取文件的原始二进制数据. readAsDataURL()：开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容. readAsDataURL()：开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容. readAsText()：开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个字符串以表示所读取的文件内容. 事件处理 onabort：当读取操作被中止时调用. onerror：当读取操作发生错误时调用. onload：当读取操作成功完成时调用. onloadend：当读取操作完成时调用,不管是成功还是失败.该处理程序在onload或者onerror之后调用. onloadstart：当读取操作将要开始之前调用. onprogress：在读取数据过程中周期性调用. 上传实例：以二进制流上传文件1234567891011121314151617181920var fileInput = document.getElementById(\"fileInput\");fileInput.addEventListener('change', function(event) &#123; var file = fileInput.files[0]; if (file) &#123; var reader = new FileReader(); var xhr = new XMLHttpRequest(); xhr.onprogress=function(e)&#123; var percentage = Math.round((e.loaded * 100) / e.total); console.log(\"percentage:\"+percentage); &#125; xhr.onload=function(e)&#123; console.log(\"percentage:100\"); &#125; xhr.open(\"POST\", \"这里填写服务器地址\"); reader.onload = function(evt) &#123; xhr.send(evt.target.result); &#125;; reader.readAsBinaryString(file); &#125;&#125;); blob 二进制大对象BLOB (binary large object)，二进制大对象，是一个可以存储二进制文件的容器。 创建Blob对象的方法有几种，可以调用Blob构造函数，还可以使用一个已有Blob对象上的slice()方法切出另一个Blob对象，还可以调用canvas对象上的toBlob方法。 第一次见到这个词是半年之前，那个时候居然没有听过blob，然后上网查了一下，巴拉巴拉一大堆，当时是不理解的。 看了前面的一系列API和对象，或许很多同学开始晕了，但是在一开始说到的blob对象，我们一直没有提到，如果本文不提及，显然是不合理的。毕竟作为File对象的爸爸，blob劳苦功高。上述的FileReader对象也可以操作blob对象。 Blob对象有两个只读属性： size：二进制数据的大小，单位为字节。 type：二进制数据的MIME类型，全部为小写，如果类型未知，则该值为空字符串。在Ajax操作中，如果xhr.responseType设为blob，接收的就是二进制数据。 Blob 构造函数生成blob对象Blob构造函数，接受两个参数。第一个参数是一个包含实际数据的数组，第二个参数是数据的类型，这两个参数都不是必需的。数组元素可以是任意多个的ArrayBuffer，ArrayBufferView (typed array)， Blob，或者 DOMString对象。例如：123var arr = ['&lt;h1&gt;hello world&lt;/h1&gt;'];var blob = new Blob(arr, &#123; \"type\" : \"text/xml\" &#125;); // the blobconsole.log(blob); 效果如下： blob 用JS在浏览器中创建下载文件前端很多项目中，都有文件下载的需求，特别是JS生成文件内容，然后让浏览器执行下载操作（例如在线图片编辑、在线代码编辑、iPresst等）但受限于浏览器，很多情况下我们都只能给出个链接，让用户点击打开-》另存为。如下面这个链接：1&lt;a href=\"file.js\"&gt;file.js&lt;/a&gt; 用户点击这个链接的时候，浏览器会打开并显示链接指向的文件内容，显然，这并没有实现我们的需求。HTML5中给a标签增加了一个download属性，只要有这个属性，点击这个链接时浏览器就不在打开链接指向的文件，而是改为下载（目前只有chrome、firefox和opera支持）。下载时会直接使用链接的名字来作为文件名，但是是可以改的，只要给download加上想要的文件名即可，如：download=&quot;not-a-file.js&quot;。但是这样还不够，以上的方法只适合用在文件是在服务器上的情况。如果在浏览器端js生成的内容，想让浏览器进行下载要如何办到呢？DataURI可以实现这个效果，但是DataURI的文件类型被限制了，我们这里可以变通一下实现blob对象。123456789101112&lt;a id=\"aLink\"&gt;下载&lt;/a&gt;&lt;script type=\"text/javascript\"&gt; function downloadFile (el, fileName, content) &#123; var aLink = document.querySelector(el); var blob = new Blob([content]); aLink.download = fileName; aLink.href = URL.createObjectURL(blob); &#125; document.querySelector('#aLink').addEventListener('click',function () &#123; downloadFile('#aLink', 'hello.txt', '&lt;h1&gt;hello world&lt;/h1&gt;'); &#125;)&lt;/script&gt; Blob对象的slice方法生成blob对象Blob对象的slice方法，将二进制数据按照字节分块，返回一个新的Blob对象。1var newBlob = oldBlob.slice(startingByte, endindByte); 下面是一个使用XMLHttpRequest对象，将大文件分割上传的例子。1234567891011121314151617181920212223function upload(blobOrFile) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.onload = function(e) &#123; ... &#125;; xhr.send(blobOrFile);&#125;document.querySelector('input[type=\"file\"]').addEventListener('change', function(e) &#123; var blob = this.files[0]; const BYTES_PER_CHUNK = 1024 * 1024; // 1MB chunk sizes. const SIZE = blob.size; var start = 0; var end = BYTES_PER_CHUNK; while(start &lt; SIZE) &#123; upload(blob.slice(start, end)); start = end; end = start + BYTES_PER_CHUNK; &#125;&#125;, false); 参考文档 在web应用中使用文件 DataURI详解 文件和二进制数据的操作 理解DOMString、Document、FormData、Blob、File、ArrayBuffer数据类型 用JS在浏览器中创建下载文件","categories":[{"name":"JavaScript进阶学习","slug":"JavaScript进阶学习","permalink":"https://zhaomenghuan.github.io/categories/JavaScript进阶学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhaomenghuan.github.io/tags/JavaScript/"},{"name":"blob","slug":"blob","permalink":"https://zhaomenghuan.github.io/tags/blob/"},{"name":"File","slug":"File","permalink":"https://zhaomenghuan.github.io/tags/File/"},{"name":"FileReader","slug":"FileReader","permalink":"https://zhaomenghuan.github.io/tags/FileReader/"},{"name":"DataURI","slug":"DataURI","permalink":"https://zhaomenghuan.github.io/tags/DataURI/"},{"name":"URL","slug":"URL","permalink":"https://zhaomenghuan.github.io/tags/URL/"}]},{"title":"mui组件通用CSS类","slug":"mui组件通用CSS类","date":"2016-08-04T16:00:00.000Z","updated":"2017-05-03T16:15:57.991Z","comments":true,"path":"2016/08/05/mui组件通用CSS类/","link":"","permalink":"https://zhaomenghuan.github.io/2016/08/05/mui组件通用CSS类/","excerpt":"","text":"color(颜色)mui中组件以iOS 7为基础，补充部分Android特有控件，颜色值主要有以下五种：12345primary =&gt; #007aff; //蓝色(blue)success =&gt; #4cd964; //绿色(green)warning =&gt; #f0ad4e; //黄色(yellow)danger =&gt; #dd524d; //红色(red)royal =&gt; #8a6de9; //紫色(purple) 注：上述primary等颜色值关键词在引用的时候可以替换成对应的颜色单词，如.mui-btn-primary等效于.mui-btn-blue; badge（数字角标）：默认背景为灰色，另外mui内置了蓝色（primary/blue）、绿色(success/green)、黄色(warning/yellow)、红色(danger/red)、紫色（royal/purple）五种颜色，通过给button或者a标签添加.mui-badge-* 类添加背景颜色。如：123456&lt;span class=\"mui-badge\"&gt;1&lt;/span&gt;&lt;span class=\"mui-badge mui-badge-primary\"&gt;2&lt;/span&gt;&lt;span class=\"mui-badge mui-badge-success\"&gt;3&lt;/span&gt;&lt;span class=\"mui-badge mui-badge-warning\"&gt;4&lt;/span&gt;&lt;span class=\"mui-badge mui-badge-danger\"&gt;5&lt;/span&gt;&lt;span class=\"mui-badge mui-badge-royal\"&gt;6&lt;/span&gt; button（按钮）：默认背景为白色，另外mui内置了蓝色（primary/blue）、绿色(success/green)、黄色(warning/yellow)、红色(danger/red)、紫色（royal/purple）五种颜色，通过给button或者a标签添加.mui-btn-* 类添加背景颜色。123456&lt;button type=\"button\" class=\"mui-btn\"&gt;默认&lt;/button&gt;&lt;button type=\"button\" class=\"mui-btn mui-btn-primary\"&gt;蓝色&lt;/button&gt;&lt;button type=\"button\" class=\"mui-btn mui-btn-success\"&gt;绿色&lt;/button&gt;&lt;button type=\"button\" class=\"mui-btn mui-btn-warning\"&gt;黄色&lt;/button&gt;&lt;button type=\"button\" class=\"mui-btn mui-btn-danger\"&gt;红色&lt;/button&gt;&lt;button type=\"button\" class=\"mui-btn mui-btn-royal\"&gt;紫色&lt;/button&gt; switch(开关)：默认值为绿色，可选颜色为蓝色，添加.mui-switch-blue类即可。123456&lt;div class=\"mui-switch mui-active\"&gt; &lt;div class=\"mui-switch-handle\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"mui-switch mui-switch-blue mui-active\"&gt; &lt;div class=\"mui-switch-handle\"&gt;&lt;/div&gt;&lt;/div&gt; 任意元素：可以给任意元素添加.mui-bg-*类添加背景颜色，可选参数为primary/positive/negative。123&lt;div class=\"mui-bg-primary\"&gt;我是蓝色背景&lt;/div&gt;&lt;div class=\"mui-bg-positive\"&gt;我是绿色背景&lt;/div&gt;&lt;div class=\"mui-bg-negative\"&gt;我是红色背景&lt;/div&gt; 文字(font)文字位置： 可以给文字添加 .mui-text-left、.mui-text-center、.mui-text-right设置文字位置。123&lt;div class=\"mui-text-left\"&gt;我在左边&lt;/div&gt;&lt;div class=\"mui-text-center\"&gt;我在中间&lt;/div&gt;&lt;div class=\"mui-text-right\"&gt;我在右边&lt;/div&gt; 溢出隐藏：当文字内容超过一行或者多行时，溢出文本用省略号代替。 显示单行：1&lt;p class=\"mui-ellipsis\"&gt;我在一行内，当我超出了会显示省略号。我在一行内，当我超出了会显示省略号。我在一行内，当我超出了会显示省略号。我在一行内，当我超出了会显示省略号。&lt;/p&gt; 显示两行：1&lt;p class=\"mui-ellipsis-2\"&gt;我在两行内，当我超出了会显示省略号。我在两行内，当我超出了会显示省略号。我在两行内，当我超出了会显示省略号。我在两行内，当我超出了会显示省略号。我在两行内，当我超出了会显示省略号。&lt;/p&gt; 若需要设置显示多行，通过设置-webkit-line-clamp属性，如显示三行添加style=”-webkit-line-clamp:3”:1&lt;p class=\"mui-ellipsis-2\" style=\"-webkit-line-clamp:3\"&gt;我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。&lt;/p&gt; 布局(layout)基本整体布局mui中提供了几种常见的布局系统，大家可以很方便的构建出一个手机页面，一个最简单的例子为：12345678910&lt;header class=\"mui-bar mui-bar-nav\"&gt; &lt;a class=\"mui-action-back mui-icon mui-icon-left-nav mui-pull-left\"&gt;&lt;/a&gt; &lt;h1 class=\"mui-title\"&gt;标题&lt;/h1&gt;&lt;/header&gt;&lt;footer class=\"mui-bar mui-bar-footer\"&gt; 底部&lt;/footer&gt;&lt;div class=\"mui-content\"&gt; 主体&lt;/div&gt; 当底部内容为选项卡时候，我们会将.mui-bar-footer替换为.mui-bar-tab：123456789101112131415161718&lt;nav class=\"mui-bar mui-bar-tab\"&gt; &lt;a class=\"mui-tab-item mui-active\"&gt; &lt;span class=\"mui-icon mui-icon-home\"&gt;&lt;/span&gt; &lt;span class=\"mui-tab-label\"&gt;首页&lt;/span&gt; &lt;/a&gt; &lt;a class=\"mui-tab-item\"&gt; &lt;span class=\"mui-icon mui-icon-phone\"&gt;&lt;/span&gt; &lt;span class=\"mui-tab-label\"&gt;电话&lt;/span&gt; &lt;/a&gt; &lt;a class=\"mui-tab-item\"&gt; &lt;span class=\"mui-icon mui-icon-email\"&gt;&lt;/span&gt; &lt;span class=\"mui-tab-label\"&gt;邮件&lt;/span&gt; &lt;/a&gt; &lt;a class=\"mui-tab-item\"&gt; &lt;span class=\"mui-icon mui-icon-gear\"&gt;&lt;/span&gt; &lt;span class=\"mui-tab-label\"&gt;设置&lt;/span&gt; &lt;/a&gt;&lt;/nav&gt; 在使用时需要注意一下两个细节： 固定栏靠前：所谓的固定栏，也就是带有.mui-bar属性的节点，都是基于fixed定位的元素；常见组件包括：顶部导航栏（.mui-bar-nav）、底部工具条(.mui-bar-footer)、底部选项卡（.mui-bar-tab）;这些元素使用时需遵循一个规则：放在.mui-content元素之前，即使是底部工具条和底部选项卡，也要放在.mui-content之前，否则固定栏会遮住部分主内容。 一切内容都要包裹在mui-content中：除了固定栏之外，其它内容都要包裹在.mui-content中，否则就有可能被固定栏遮罩，原因：固定栏基于Fixed定位，不受流式布局限制，普通内容依然会从top:0的位置开始布局，这样就会被固定栏遮罩，mui为了解决这个问题，定义了如下css代码：123456789.mui-bar-nav ~ .mui-content &#123; padding-top: 44px;&#125;.mui-bar-footer ~ .mui-content &#123; padding-bottom: 44px;&#125;.mui-bar-tab ~ .mui-content &#123; padding-bottom: 50px;&#125; 你当然可以通过自定义CSS的方式实现如上类似效果，但为了使用简便，建议将除固定栏之外的所有内容，全部放在.mui-content中。 局部元素布局设置边距：可以给块元素设置.mui-content-padded类添加边距，默认为10px外边距。 设置元素为内联块对象：可以给元素设置.mui-inline类，将元素呈递为内联对象，但是对象的内容作为块对象呈递。12345&lt;div class=\"mui-content-padded\"&gt; &lt;div class=\"mui-inline\"&gt;我是A&lt;/div&gt; &lt;div class=\"mui-inline\"&gt;我是B&lt;/div&gt; &lt;div class=\"mui-inline\"&gt;我是C&lt;/div&gt;&lt;/div&gt; 设置元素为块元素对象：可以给元素设置元素.mui-block，将元素设置为块元素。 浮动：可以给元素设置.mui-pull-left或者.mui-pull-right类，从而设置浮动效果，可以使用.mui-clearfix清除浮动。1234&lt;div class=\"mui-clearfix\"&gt; &lt;div class=\"mui-pull-left\"&gt;我在左边&lt;/div&gt; &lt;div class=\"mui-pull-right\"&gt;我在右边&lt;/div&gt;&lt;/div&gt; 块级表格：mui中使用CSS表格的方式定义了.mui-table块级表格布局方式，会作元素为块级表格来显示。1234567891011&lt;div class=\"mui-table\"&gt; &lt;div class=\"mui-table-cell mui-text-center\"&gt; 我是A &lt;/div&gt; &lt;div class=\"mui-table-cell mui-text-center\"&gt; 我是B &lt;/div&gt; &lt;div class=\"mui-table-cell mui-text-center\"&gt; 我是C &lt;/div&gt;&lt;/div&gt; 列表去掉默认样式：可以给ul元素设置.mui-list-unstyled类去掉ul标签在浏览器中默认的原点和内边距。12345&lt;ul class=\"mui-list-unstyled\"&gt; &lt;li&gt;我是第1条&lt;/li&gt; &lt;li&gt;我是第2条&lt;/li&gt; &lt;li&gt;我是第3条&lt;/li&gt;&lt;/ul&gt; 列表显示为内联元素：可以给ul元素设置.mui-list-inline类将li标签元素设置为内联块元素。12345 &lt;ul class=\"mui-list-inline\"&gt; &lt;li&gt;我是第1条&lt;/li&gt; &lt;li&gt;我是第2条&lt;/li&gt; &lt;li&gt;我是第3条&lt;/li&gt;&lt;/ul&gt; 设置元素显示与隐藏：.mui-visibility默认为设置元素可见，.mui-hidden默认为设置元素隐藏。123456789&lt;div id=\"loading\"&gt; loading...&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; setTimeout(function()&#123; document.getElementById(\"loading\").classList.add('mui-hidden'); &#125;,3000)&lt;/script&gt; OS环境判断多平台适配： mui会通过.mui.os.*方法判断环境，将.mui-plus，.mui-plus-stream，.mui-ios，.mui-android，.mui-wechat，.mui-ios-version，.mui-android-version，.mui-wechat-version绑定在document.body.classList中，我们可以通过这些样式类判断当前的运行判断，于是可以做出一些适配，如：12345678&lt;div class=\"mui-input-row mui-plus-visible\"&gt; &lt;label&gt;mui-plus-visible&lt;/label&gt; &lt;input type=\"text\" class=\"mui-input-speech mui-input-clear\" placeholder=\"我在web环境下隐藏5+环境下显示\"&gt;&lt;/div&gt;&lt;div class=\"mui-input-row mui-plus-hidden\"&gt; &lt;label&gt;mui-plus-hidden&lt;/label&gt; &lt;input type=\"text\" class=\"mui-input-clear\" placeholder=\"我在web环境下显示5+环境下隐藏\"&gt;&lt;/div&gt; mui中默认在plus环境下和微信环境下设置了样式几个样式： .mui-plus-visible：在plus环境下显示，非plsu环境下隐藏.mui-wechat-visible：在wechat环境下显示，非wechat环境下隐藏.mui-plus-hidden：在plus环境下隐藏，非plsu环境下显示.mui-wechat-hidden：在wechat环境下隐藏，非wechat环境下显示 栅格系统布局：mui中定义了一个简单适用的栅格系统，将每一行宽度平均分为12份，每一份作为一个子栅格，每一行的内容置于.mui-row行容器中，通过.mui-col-xs-*和.mui-col-sm-*将行分成若干行。使用以下媒体查询（media query）将.mui-row像素宽度400px作为分界，.mui-row像素宽度低于400px的使用.mui-col-xs-*，当.mui-row像素宽度高于400px使用.mui-col-sm-*。.mui-row宽度若不设置，默认为屏幕像素宽度。 通过给每一行中的列设置1~12的数值，相应列的宽度会随着.mui-row像素宽度变化。若一行中列的数值和大于12，多余的列所在元素会作为一个整体另起一行排列。123456789101112131415161718192021&lt;style type=\"text/css\"&gt; .mui-row&#123; height: 50px; line-height: 50px; text-align: center; &#125; .mui-col-sm-3&#123; border: 1px solid #aaa; &#125; .mui-col-sm-9&#123; border: 1px solid #aaa; &#125;&lt;/style&gt;&lt;div class=\"mui-row\"&gt; &lt;div class=\"mui-col-xs-4 mui-col-sm-3\"&gt; .mui-col-sm-3 &lt;/div&gt; &lt;div class=\"mui-col-xs-8 mui-col-sm-9\"&gt; .mui-col-sm-9 &lt;/div&gt;&lt;/div&gt; 这样我们得到了两列元素，当.mui-row像素宽度低于400px时，左侧宽度为4份子栅格宽度，右侧宽度为8份子栅格宽度；当.mui-row像素宽度高于400px时，左侧宽度为4份子栅格宽度，右侧宽度为8份子栅格宽度。 区域滚动布局：mui中封装了一个scroll控件用于实现区域滚动，在使用区域滚动组件时候需要注意几个细节，scroll控件有固定的dom结构，需手动初始化scroll控件，需要手动设置滚动区域的位置（一般设置为top和bottom）。 固定DOM结构：12345&lt;div class=\"mui-scroll-wrapper\"&gt; &lt;div class=\"mui-scroll\"&gt; &lt;!--这里放置真实显示的DOM内容--&gt; &lt;/div&gt;&lt;/div&gt; 初始化scroll控件：123456789101112131415// 常用配置项var options = &#123; scrollY: true, //是否竖向滚动 scrollX: false, //是否横向滚动 startX: 0, //初始化时滚动至x startY: 0, //初始化时滚动至y indicators: true, //是否显示滚动条 deceleration:0.0006 //阻尼系数,系数越小滑动越灵敏 bounce: true, //是否启用回弹&#125;eg：mui('.mui-scroll-wrapper').scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006&#125;); 手动设置高度：一般在scroll控件最外面设置div为绝对定位，设置top,bottom,left,right值，为了方便，mui默认设置有个全屏类.mui-fullscreen。1234567.mui-fullscreen &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125; 我们可以在scroll控件外面添加这个类，然后手动修改top和bottom值。 效果预览：JS Bin on jsbin.com","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"css","slug":"css","permalink":"https://zhaomenghuan.github.io/tags/css/"}]},{"title":"mui初级入门教程（七）— 基于native.js的文件系统管理功能实现","slug":"mui初级入门教程（七）—基于native.js的文件系统管理功能实现","date":"2016-07-31T16:00:00.000Z","updated":"2017-05-03T16:15:18.980Z","comments":true,"path":"2016/08/01/mui初级入门教程（七）—基于native.js的文件系统管理功能实现/","link":"","permalink":"https://zhaomenghuan.github.io/2016/08/01/mui初级入门教程（七）—基于native.js的文件系统管理功能实现/","excerpt":"","text":"前言这段时间以来一直有人问5+ sdk怎么在原生中集成，每次给了文档和没给没啥大区别，这部分人之所以不能根据文档写出想要的结果，无非有两种情况，一种对于原生完全懵逼，毕竟基于mui做APP毕竟前端还是占多数，而前端中熟悉原生的人毕竟是少数，很多人声称会原生哪里还会用h5，这话只能呵呵？就大趋势而言，应用web化是现在的潮流所向，现在即使有资金和技术实力的大厂也在做混合式开发和H5的APP，不然dcloud官方也不会花大力气在流应用上。近来越来越多的原生开发者朋友和我交流h5，他们很多是被逼着转前端，这些人懂原生，但是不懂h5，所以这些朋友从原生转mui过程中可能还是不能够理解如果用5+ sdk，中间的交互怎么解决，这就是第二种人的困境？ 正是基于这种现实窘境，我打算把自己一知半解的android开发经验重新拿起来，试着去写点什么，抛砖引玉，仅此而已。本文作为混合式开发的第一篇，暂时不会介绍离线打包集成5+ sdk的相关内容，先用nativejs练练手。 步骤分解在开始集成5+sdk之前，我们先来用native.js写一个文件管理的功能，以此熟悉native.js的相关API。先来预览一下效果： 文件系统 经常有人问使用5+怎么系统文件，其实用nativejs就可以实现，有人又要问nativejs怎么引用。每次遇到这种问题，真的要喷血而出。 nativejs是集成在5+ app中，默认不需要引入就可以直接引用。nativejs是通过js调用系统原生方法，从而实现5+标准中没有提及的方法，所以说白了你还是要会原生，或者有人用nativejs将原生的方法转成了js，这样你只需要在页面中调用js的方法就可以实现调用原生。nativejs在这里充当一个“语法糖”的作用。 对于这样一个遍历文件系统的功能，用原生方法写，我们会这样写： 1.在AndroidManifest.xml下设置权限12&lt;!-- 允许程序写入外部存储,如SD卡上写文件 --&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; 5+ APP中这一步默认设置了，我们不要管。 2.导入Java类对象1import android.os.Environment; Native.js中使用plus.android.importClass方法：1var environment = plus.android.importClass(\"android.os.Environment\"); 3.判断SD卡是否插入(涉及到SDK的读取，最好先判断SDK是否插入)1Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED) nativejs这样写：1environment.getExternalStorageState() === environment.MEDIA_MOUNTED 4.获得sd卡根目录1File skRoot = Environment.getExternalStorageDirectory(); nativejs这样写：1var sdRoot = environment.getExternalStorageDirectory(); 5.遍历sd卡根目录下的所有文件和文件夹（返回值为数组）1File[] files = sdRoot.listFiles(); nativejs中使plus.android.invoke调用对象（类对象/实例对象）的方法：1var files = plus.android.invoke(sdRoot,\"listFiles\"); 6.过滤系统隐藏文件123456789import java.io.File;import java.io.FileFilter;FileFilter ff = new FileFilter() &#123; public boolean accept(File pathname) &#123; return !pathname.isHidden();//过滤隐藏文件 &#125;&#125;;File[] files = sdRoot.listFiles(ff); nativejs中可以这样写：1234567891011// 遍历sd卡根目录下的所有文件和文件夹var files = plus.android.invoke(sdRoot,\"listFiles\");var len = files.length;for(var i=0; i&lt;len; i++)&#123; var file = files[i]; // 过滤隐藏文件 if(!plus.android.invoke(file,\"isHidden\"))&#123; // 非隐藏文件执行操作 &#125;&#125; 上面的预览效果可以看出我们对文件夹和文件进行了不同的操作，接着需要在遍历中判断。 7.文件及文件夹类型判断1234567for(File file : files)&#123; if(file.isDirectory())&#123; // 文件夹 &#125;else&#123; // 文件 &#125;&#125; nativejs写法：1234567for(var i=0;i&lt;len;i++)&#123; if(plus.android.invoke(file,\"isDirectory\"))&#123; // 文件夹 &#125;else&#123; // 文件 &#125;&#125; 8.文件大小及单位转换(这里直接上nativejs版本)1234567891011121314151617// 读文件大小var FileInputStream = plus.android.importClass(\"java.io.FileInputStream\");var fileSize = new FileInputStream(file);var size = fileSize.available();// 单位转换var fileSizeString;if(size == 0)&#123; fileSizeString = \"0B\";&#125;else if(size &lt; 1024)&#123; fileSizeString = size + \"B\";&#125;else if(size &lt; 1048576)&#123; fileSizeString = (size/1024).toFixed(2) + \"KB\";&#125;else if (size &lt; 1073741824)&#123; fileSizeString = (size/1048576).toFixed(2) + \"MB\";&#125;else&#123; fileSizeString = (size/1073741824).toFixed(2) + \"GB\";&#125; 9.创建文件夹与删除文件(文件夹)12345678910111213141516171819202122232425/** * 创建文件夹 * @param &#123;Object&#125; path */function creatFolder(path)&#123; var File = plus.android.importClass(\"java.io.File\"); var fd = new File(path); if(!fd.exists())&#123; fd.mkdirs(); plus.nativeUI.toast(\"创建成功\"); &#125;&#125; /** * 删除文件(文件夹) * @param &#123;Object&#125; path */function deleteFile(path)&#123; var File = plus.android.importClass(\"java.io.File\"); var fd = new File(path); if (fd != null &amp;&amp; fd.exists())&#123; fd.delete(); plus.nativeUI.toast(\"删除成功\"); &#125; &#125; 10.打开目录和打开文件我们在打开目录的时候，会遍历该目录下的文件夹和文件，实现方法同上面，打开文件我们可以使用5+ runtime openFile调用第三方程序打开指定的文件。1void plus.runtime.openFile( filepath, options, errorCB ); 参数： filepath: ( String ) 必选 打开文件的路径字符串类型，文件路径必须是本地路径，否则会导致打开文件失败。 options: ( OpenFileOptions ) 可选 打开文件参数 errorCB: ( OpenErrorCallback ) 必选 打开文件失败的回调打开文件操作失败时回调，返回失败信息。 本文完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/mui.min.css\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/circles.css\"/&gt; &lt;style type=\"text/css\"&gt; .loading &#123; position: absolute; top: 50%; left: 50%; width: 200px; height: 200px; margin-top: -100px; margin-left: -100px; z-index: 9999; &#125; .loading .card &#123; display: table-cell; text-align: center; vertical-align: middle; width: 200px; height: 200px; &#125; .mui-backdrop &#123; background-color: #15b5e9; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"loading\"&gt; &lt;div class=\"card\"&gt; &lt;span class=\"circles-loader\"&gt;Loading&amp;#8230;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;header class=\"mui-bar mui-bar-nav\"&gt; &lt;h1 class=\"mui-title\"&gt;文件系统&lt;/h1&gt; &lt;a id=\"add\" class=\"mui-icon mui-icon-plus mui-pull-right\"&gt;&lt;/a&gt; &lt;/header&gt; &lt;div class=\"mui-content\"&gt; &lt;ul id=\"list\" class=\"mui-table-view mui-table-view-chevron\"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script src=\"js/mui.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"js/njs-io.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; mui.init(&#123; gestureConfig:&#123; longtap: true //默认为false &#125; &#125;); var mask; mui.ready(function () &#123; mask = mui.createMask();//callback为用户点击蒙版时自动执行的回调； mask.show();//显示遮罩 &#125;) var sdRoot = null; document.addEventListener(\"plusready\", function()&#123; init(); &#125;, false); // 渲染列表 function init()&#123; // 获得sd卡根目录 sdRoot = getSDRoot(); // 遍历sd卡根目录下的所有文件和文件夹 var files = plus.android.invoke(sdRoot,\"listFiles\"); var len = files.length; var list = document.getElementById(\"list\"); var fragmentFolder = document.createDocumentFragment(); var fragmentFile = document.createDocumentFragment(); var li; for(var i=0;i&lt;len;i++)&#123; var file = files[i]; // 过滤隐藏文件 if(!plus.android.invoke(file,\"isHidden\"))&#123; var name = plus.android.invoke(file,\"getName\"); li= document.createElement('li'); li.className = 'mui-table-view-cell mui-media'; li.setAttribute('name',name); // 判断是文件还是文件夹 if(plus.android.invoke(file,\"isDirectory\"))&#123; // 设置标志为文件夹，供后面使用 li.setAttribute('data-type', 'Folder'); // 读取文件夹下子文件夹及子文件数目 var obj = readSonFilenum(file); li.innerHTML = '&lt;a class=\"mui-navigate-right\"&gt;'+ '&lt;img class=\"mui-media-object mui-pull-left\" src=\"img/folder.png\"&gt;'+ '&lt;div class=\"mui-media-body\"&gt;'+ name + '&lt;p class=\"mui-ellipsis\"&gt;文件夹数量：'+ obj.subFolderNum + ' 文件数量：'+ obj.subFileNum +'&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;'; fragmentFolder.appendChild(li); &#125;else&#123; li.setAttribute('data-type', 'File'); // 读文件大小 var fileSizeString = readFileSize(file); li.innerHTML = '&lt;a class=\"mui-navigate-right\"&gt;'+ '&lt;img class=\"mui-media-object mui-pull-left\" src=\"img/file.png\"&gt;'+ '&lt;div class=\"mui-media-body mui-ellipsis\"&gt;'+ name + '&lt;p class=\"mui-ellipsis\"&gt;'+ fileSizeString +'&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;'; fragmentFile.appendChild(li); &#125; &#125;; &#125; list.appendChild(fragmentFolder); list.appendChild(fragmentFile); // 关闭遮罩 mask.close(); document.querySelector('.loading').style.display = 'none'; &#125; // 点击打开文件 mui('.mui-table-view').on('tap','li',function()&#123; var name = this.getAttribute('name'); var fileType = this.getAttribute('data-type'); var filepath = sdRoot + '/' + name; if(fileType === 'Folder')&#123; // 打开目录详细页面 mui.openWindow(&#123; url: 'sub.html', id: 'sub', extras:&#123; name: name, filepath: filepath &#125; &#125;) &#125;else&#123; // 打开文件 plus.runtime.openFile(filepath); &#125; &#125;) // 创建文件夹 document.querySelector('#add').addEventListener('tap',function (e) &#123; e.detail.gesture.preventDefault(); //修复iOS 8.x平台存在的bug，使用plus.nativeUI.prompt会造成输入法闪一下又没了 var btnArray = ['取消', '确定']; mui.prompt('请输入要创建的文件夹名:', '文件夹名', '创建文件夹', btnArray, function(e) &#123; if (e.index == 1) &#123; creatFolder(sdRoot+\"/\"+e.value); &#125; else &#123; plus.nativeUI.toast('你点了取消按钮'); &#125; &#125;) &#125;) // 长按删除文件 mui('.mui-table-view').on('longtap','li',function()&#123; var name = this.getAttribute('name'); var btnArray = ['取消', '确定']; mui.confirm('你确定要删除这个文件夹？', '删除文件夹', btnArray, function(e) &#123; if (e.index == 1) &#123; deleteFile(sdRoot+\"/\"+name); &#125; else &#123; plus.nativeUI.toast('你点了取消按钮'); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原生文件操作判断SD卡是否插入12Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED); 获得sd卡根目录1File skRoot = Environment.getExternalStorageDirectory(); 获得私有根目录1File fileRoot = Context.getFilesDir()+\"\\\"; 文件夹或文件夹操作获得文件夹和文件路径 获得文件或文件夹的绝对路径和相对路径。区别: 12String path = File.getPath();//相对String path = File.getAbsoultePath();//绝对 获得文件或文件夹的父目录 1String parentPath = File.getParent(); 获得文件或文件夹的名称： 1String Name = File.getName(); 建立文件或文件夹12File.mkDir(); //建立文件夹File.createNewFile();//建立文件 判断是文件或文件夹12File.isDirectory()File.isDirectory() 列出文件夹下的所有文件和文件夹名1File[] files = File.listFiles(); 修改文件夹和文件名1File.renameTo(dest); 删除文件夹或文件1File.delete(); 这里列出原生的常用方法，大家可以根据需要进行实现。 后记写到这里，本篇本应该继续讲讲5+ sdk集成中的各种细节，但是想想本篇作为nativejs的开篇，先简单介绍这个实例，让大家根据需要自己实现或许更好，本文仅供参考。 文章最后还是要放上文档和本文详细工程： Native.js android API文档 5+ App开发Native.js入门指南 Native.js示例汇总 本文详细工程 njs-io","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"nativejs","slug":"nativejs","permalink":"https://zhaomenghuan.github.io/tags/nativejs/"},{"name":"android","slug":"android","permalink":"https://zhaomenghuan.github.io/tags/android/"}]},{"title":"HTML5+ APP页面传参详解","slug":"HTML5+APP页面传参详解","date":"2016-07-27T16:00:00.000Z","updated":"2017-05-03T16:14:50.702Z","comments":true,"path":"2016/07/28/HTML5+APP页面传参详解/","link":"","permalink":"https://zhaomenghuan.github.io/2016/07/28/HTML5+APP页面传参详解/","excerpt":"","text":"前言页面传参数是一种比较常见的业务需求，在html5+ app中，根据实现原理及适用环境可以分为两大类。 在普通浏览器端常用的方法有如下几种：1.利用URL传参在页面跳转的时候通过设置window.location.href添加参数，在接收参数的页面通过window.location.search获取参数字符串。 发送参数的页面：1window.location.href = 'new.html?targetId=123' 接收参数的页面：12345678910111213// 获取url中的参数function getUrlParam (name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (r!= null) &#123; return unescape(r[2]); &#125;else&#123; return null; &#125;&#125; //获取url中的targetId参数var targetId = getUrlParam('targetId');console.log(targetId); 2.利用本地存储传参可以使用本地存储的方式，可以使用cookie、sessionStorage和localStorage。发送参数的页面：1localStorage.setItem(\"targetId\",\"123\"); 接收参数的页面：1localStorage.getItem(\"targetId\"); mui框架根据业务场景不同，提供了两种传值模式：1.页面初始化时，通过扩展参数传值html5+ webview中在创建新窗口的时候有一个extras参数，用于创建Webview窗口的额外扩展参数。123456var w = plus.webview.create(\"new.html\",\"new\",&#123;&#125;,&#123; targetId: '123'&#125;);w.show(); // 显示窗口// 获取扩展参数属性值console.log(\"extras:\" + w.targetId); 注意：id是WebviewObject的一个属性，所以extras不能使用id作为参数名。 mui在初始化页面时，提供了extras配置参数，通过该参数可以设置页面参数，从而实现页面间传值。mui框架在如下几种场景下，会执行页面初始化操作： 通过mui.openWindow()打开新页面（若目标页面为已预加载成功的页面，则在openWindow方法中传递的extras参数无效）； 通过mui.init()方法创建子页面； 通过mui.init()方法预加载页面； 通过mui.preload()方法预加载页面 以打开新页面为例说明浏览器和基于5+的APP的兼容写法：12345678910var targetId = '123';var baseUrl = 'new.html';var url = mui.os.plus?baseUrl:baseUrl+'?targetId=' + targetId; mui.openWindow(&#123; url: url, extras: &#123; targetId: targetId &#125;&#125;) 想获取某个webview页面的拓展参数，可以通过webview对象获取。例如在new.html页面可以通过下面的方法获取拓展参数：12345mui.plusReady(function () &#123; var self = plus.webview.currentWebview(); // 或 var self = plus.webview.getWebviewById('new'); console.log(\"extras:\" + self.targetId);&#125;) 至于浏览器和APP兼容的写法自己根据上面的方法和这个方法结合一下就OK了。 2.页面已创建，通过自定义事件传值Webview窗口对象窗口对象WebviewObject有一个evalJS方法，可以将JS脚本发送到Webview窗口中运行，可用于实现Webview窗口间的数据通讯。1mui.fire(target, event, data) 参数说明： target： Type: WebviewObject 需传值的目标webview event：Type: String 自定义事件名称 data：Type: JSON json格式的数据 发送参数的页面：12345678910111213&lt;button id=\"send\" type=\"button\" class=\"mui-btn mui-btn-blue mui-btn-block\"&gt;按钮&lt;/button&gt;&lt;script src=\"js/mui.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var ws = null; mui.plusReady(function () &#123; ws = plus.webview.create(\"new.html\",\"new\",&#123;top:\"0px\",bottom:\"0px\"&#125;); &#125;) document.querySelector('#send').addEventListener('tap',function () &#123; var targetId = '123'; ws.evalJS('send('+targetId+')'); ws.show(); &#125;)&lt;/script&gt; 接收参数的页面：12345678910111213141516&lt;div class=\"mui-content\"&gt; &lt;div id=\"text\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"js/mui.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; mui.init(); // 接收参数的函数 function send(param)&#123; document.getElementById(\"text\").innerHTML = param; &#125; mui.back = function()&#123; var self = plus.webview.currentWebview(); self.hide(); &#125;&lt;/script&gt; 注：这里要重写back,不然默认为close，当我们返回的时候再次打开show的时候需要重新创建。 显然这样写有点复杂，为此mui将evalJS传值的机制进行了封装，通过自定义事件实现页面传值，可以使用mui.fire()方法可触发目标窗口的自定义事件。 发送参数的页面：1234567891011121314&lt;button id=\"send\" type=\"button\" class=\"mui-btn mui-btn-blue mui-btn-block\"&gt;按钮&lt;/button&gt;&lt;script src=\"js/mui.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var ws = null; mui.plusReady(function () &#123; ws = plus.webview.create(\"new.html\",\"new\",&#123;top:\"0px\",bottom:\"0px\"&#125;); &#125;) document.querySelector('#send').addEventListener('tap',function () &#123; mui.fire(ws,'send',&#123; targetId: '123' &#125;) ws.show(); &#125;)&lt;/script&gt; 接收参数的页面：123456// 添加send自定义事件监听window.addEventListener('send',function(event)&#123; //获得事件参数 var targetId = event.detail.targetId; document.getElementById(\"text\").innerHTML = targetId;&#125;); 这里需要特别说明一下的是，很多人在使用mui.fire传参数的时候会提前预加载接收参数的页面，结果发现接收不到传的参数，这是一种非常常见的错误，这里需要说明的是当预加载了页面后，页面上的代码都已经执行，如果在loaded事件未完成就执行webview.evalJS或mui.fire，此时页面接收参数失效。此时应该将接受参数的逻辑写在webview loaded或者show监听事件中: 验证一个webview的loaded事件是否完成的方法：1234var ws = plus.webview.getWebviewById(id)ws.addEventListener( \"loaded\", function(e)&#123; console.log( \"Loaded: \"+e.target.getURL() );&#125;, false ); 验证一个webview的show事件是否完成的方法：1234var ws=plus.webview.currentWebview();ws.addEventListener(\"show\", function(e)&#123; console.log( \"Webview Showed\" );&#125;, false );","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"html5plus","slug":"html5plus","permalink":"https://zhaomenghuan.github.io/tags/html5plus/"},{"name":"页面传参","slug":"页面传参","permalink":"https://zhaomenghuan.github.io/tags/页面传参/"}]},{"title":"mui初级入门教程（六）— 模板页面实现原理及多端适配指南","slug":"mui初级入门教程（六）—模板页面实现原理及多端适配指南","date":"2016-07-25T16:00:00.000Z","updated":"2017-05-03T16:15:37.347Z","comments":true,"path":"2016/07/26/mui初级入门教程（六）—模板页面实现原理及多端适配指南/","link":"","permalink":"https://zhaomenghuan.github.io/2016/07/26/mui初级入门教程（六）—模板页面实现原理及多端适配指南/","excerpt":"","text":"写在前面自从来公司实习，每天都淹没在问题中，一直没有抽出空写写文章，今天轮到我完善文档和总结，就想着抽空把文档中的内容写写，但是文档限于篇幅，而且不能话唠，自然博客是最好的方式去分享。哈哈，废话不多说，将整理的内容贴出来，稍作解释，方便大家查阅。 template(模板页面)hello mui示例App中无等待窗体切换的实现是基于模板页面，点击一个链接，不显示雪花等待框，立即打开一个“正在加载…”的页面，之后真实内容快速填充“正在加载…”区域。这种模板页面适用了通用性较强的页面，我们不必要为每个页面创建父子webview，而是将公用的父页面提取出来作为模板页面，同时在页面为加载前可以显示个性化加载页面，可以极大的提升用户体验。模板父页面预加载，点击后立即显示，不用展示雪花等待框，也不会出现白屏现象；共用子页面，有效控制webview数量，避免切页时频繁创建、销毁webview。 实现思路这里我们以列表到详情页的情况为例说明，详情页html结构：1234567891011121314151617&lt;ul class=\"mui-table-view\"&gt; &lt;li class=\"mui-table-view-cell\"&gt; &lt;a class=\"mui-navigate-right\" href=\"list1.html\"&gt; Item 1 &lt;/a&gt; &lt;/li&gt; &lt;li class=\"mui-table-view-cell\"&gt; &lt;a class=\"mui-navigate-right\" href=\"list2.html\"&gt; Item 2 &lt;/a&gt; &lt;/li&gt; &lt;li class=\"mui-table-view-cell\"&gt; &lt;a class=\"mui-navigate-right\" href=\"list3.html\"&gt; Item 3 &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 1.预加载一个模板父页面，用以当页面还没有加载出来的时候展示加载动画，以及作为公用子页面的头部，原理相当于tabbar webview模式的父页面；预加载或者创建一个公用子页面，同时将这个子页面填充到模板父页面;12345678910111213141516171819// 预加载模板父页面var template = mui.preload(&#123; url:'template.html', id:'template', styles:&#123; popGesture:\"hide\" &#125;&#125;);// 预加载公用子页面var subWebview = mui.preload(&#123; url:'', id:'sub_template', styles:&#123; top: '45px', bottom: '0px' &#125;&#125;);// 将子页面填充到父页面template.append(subWebview); 2.点击列表链接时，直接显示模板父页面，并动态修改模板父页面的标题；共用子页面通过loadURL方法加载对应目标页面；12345678910111213141516171819202122mui('.mui-table-view').on('tap','li a',function()&#123; var self = this; // 修改共用父模板的标题 mui.fire(template, 'updateHeader', &#123; title: self.innerText, href: self.href &#125;); // 加载子页面地址 if(subWebview.getURL()==self.href)&#123; subWebview.show(); &#125;else&#123; subWebview.loadURL(self.href); // 子页面加载完成显示 subWebview.addEventListener('loaded', function() &#123; setTimeout(function()&#123; subWebview.show(); &#125;,50); &#125;); &#125; // 显示模板父页面 template.show('slide-in-right', 150); &#125;) 3.模板父页面接收参数和返回列表页的处理方法12345678910111213141516171819202122232425262728293031323334353637383940414243var titleElem = document.getElementById(\"title\");var contentWebview = null,self = null;mui.plusReady(function () &#123; self = plus.webview.currentWebview();&#125;);// 自定义事件接收参数修改模板父页面头部window.addEventListener(\"updateHeader\", function(e) &#123; var title = e.detail.title; var href = e.detail.target; var aniShow = e.detail.aniShow; titleElem.innerHTML = title; titleElem.className = \"mui-title mui-fadein\"; if(mui.os.android&amp;&amp;aniShow&amp;&amp;parseFloat(mui.os.version)&gt;=4.4)&#123; if(contentWebview==null)&#123; contentWebview = self.children()[0]; &#125; if (contentWebview.getURL() != href) &#123; contentWebview.loadURL(href); &#125; else &#123; contentWebview.show(); &#125; setTimeout(function () &#123; self.show(aniShow); &#125;,10); &#125;&#125;);// 返回事件（隐藏模板父页面，并在窗体动画结束后，隐藏共用子页面）mui.back = function() &#123; self.hide('auto'); setTimeout(function() &#123; titleElem.className = 'mui-title mui-fadeout'; titleElem.innerText = ''; if(contentWebview==null)&#123; contentWebview = self.children()[0]; &#125; contentWebview.hide(\"none\"); &#125;, 350);&#125; 另外需要说明的是，我们这种方式是创建两个webview作为视图容器实现，在web环境下webview的方法不能执行，hello mui里面为每个详情页面创建一个头部，但是我们会发现在app环境下执行并没有出现这个头部，这是以为在hello mui演示demo中的app.css中有这么一段代码：123456.mui-plus.mui-android header.mui-bar&#123; display: none;&#125;.mui-plus.mui-android .mui-bar-nav~.mui-content&#123; padding: 0;&#125; 由于iOS系统性能已经足够好，转场切换不会白屏，hello mui演示demo中iOS没有使用模板页面。当我们引入mui.js文件，在5+环境执行，mui.js会自动将.mui-plus及.mui-plus-android类添加到body上，我们可以通过这个方法进行环境判断，是否显示某些内容。 运行环境判断如果是写文档，写到上面自然就戛然而止，但是写文章，希望把这个相关的问题顺便多聊几句，因为一旦有人遇到相关的问题，多说了几句就说不定解决的。 说到系统判断，这里不得不说一下mui.os这个工具方法，mui通过封装html5中的navigator.userAgentAPI进行判断系统和版本号： 5+环境下判断方法： mui.os.plus 返回是否在5+基座中运行等效于：navigator.userAgent.indexOf(&quot;Html5Plus&quot;)&gt;-1 mui.os.stream 返回是否为流应用等效于：navigator.userAgent.indexOf(&quot;StreamApp&quot;)&gt;-1 Android环境下判断方法： mui.os.android 返回是否为安卓手机等效于：navigator.userAgent.indexOf(&quot;Android&quot;)&gt;-1 mui.os.isBadAndroid android非Chrome环境等效于：!(/Chrome\\/\\d/.test(window.navigator.appVersion)) mui.os.version 安卓版本等效于：navigator.userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/)[2] IOS环境下判断方法： mui.os.ios 返回是否为苹果设备等效于：navigator.userAgent.indexOf(&quot;iPhone&quot;)&gt;-1&amp;&amp;navigator.userAgent.indexOf(&quot;iPad&quot;)&gt;-1 mui.os.iphone 返回是否为苹果手机等效于：navigator.userAgent.indexOf(&quot;iPhone&quot;)&gt;-1 mui.os.ipad 返回是否为ipad等效于：navigator.userAgent.indexOf(&quot;iPad&quot;)&gt;-1 mui.os.version 返回手机版本号等效于：navigator.userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/).[2].replace(/_/g, &#39;.&#39;)||navigator.userAgent.match(/(iPad\\sOS)\\s([\\d_]+)/).[2].replace(/_/g, &#39;.&#39;) 微信环境下判断方法： mui.os.wechat 返回是否为微信端等效于：navigator.userAgent.indexOf(&quot;MicroMessenger&quot;)&gt;-1 mui.os.wechat.version 返回微信版本等效于：navigator.userAgent.match(/(MicroMessenger)\\/([\\d\\.]+)/i)[2].replace(/_/g, &#39;.&#39;) 这里我们可以通过mui.os.*方法进行判断，但是很多时候我们需要更简单的方法去判断，比如我们希望某一部分内容只在5+环境下显示，有些内容只在非5+环境下执行，或者有些内容只在微信环境下使用，使用mui.os.*有时候显得还是不够方便，那这里就说一个更简单的方法，就是我们上面讲到的通过设置class类的CSS方法。 读mui源码我们能够知道，mui中定义mui.os.*系列方法，同时通过mui.os.*方法判断环境，将.mui-plus，.mui-plus-stream，.mui-ios，.mui-android，.mui-wechat，mui-ios-version，mui-android-version，mui-wechat-version绑定在document.body.classList中，我们可以通过这些样式类判断当前的运行判断，于是可以做出一些适配。 1234567891011121314151617181920.mui-plus-visible,.mui-wechat-visible&#123; display: none!important;&#125;.mui-plus-hidden,.mui-wechat-hidden&#123; display: block!important;&#125;.mui-plus .mui-plus-visible,.mui-wechat .mui-wechat-visible&#123; display: block!important;&#125;.mui-plus .mui-tab-item.mui-plus-visible,.mui-wechat .mui-tab-item.mui-wechat-visible&#123; display: table-cell!important;&#125;.mui-plus .mui-plus-hidden,.mui-wechat .mui-wechat-hidden&#123; display: none!important;&#125; 当我们知道这些类的时候，在做适配的时候可以解决很多小问题，如下面这个例子：12345678&lt;div class=\"mui-input-row mui-plus-visible\"&gt; &lt;label&gt;mui-plus-visible&lt;/label&gt; &lt;input type=\"text\" class=\"mui-input-speech mui-input-clear\" placeholder=\"我在web环境下隐藏5+环境下显示\"&gt;&lt;/div&gt;&lt;div class=\"mui-input-row mui-plus-hidden\"&gt; &lt;label&gt;mui-plus-hidden&lt;/label&gt; &lt;input type=\"text\" class=\"mui-input-clear\" placeholder=\"我在web环境下显示5+环境下隐藏\"&gt;&lt;/div&gt; 我们可以使用.mui-plus-visible将只能在5+环境下正常使用的内容在web环境下隐藏，反过来我们可以使用 .mui-plus-hidden将在web中正常显示的内容在5+环境下隐藏。在5+环境下我们使用增强版的语音输入，在普通web环境下使用h5的普通输入框。 开发一次，多端发布，我想这种很多人希望看到的，目前mui中很多组件已经实现在多平台自动切换到合适的模式，使用最合适的姿势，但是对于业务要求各不相同的开发者，想要实现多端发布，不是简单的一两句的问题，还是得熟悉各个平台的差异化，同时对于h5，mui，html5+中的实现方法的差异要所有了解的前提下，才能够做到真正的多端发布。 多端发布注意事项上面讲解了多端发布的时候系统及版本判断的方法，但是依然没有说明区别所在，估计很多人看了依然是懵逼状态。为解决HTML5在低端Android机上的性能缺陷，mui引入了原生加速，在普通浏览器端5+的一些方法不再适用，所以做多端发布的时候必须先明白哪一些方法可以使用，哪一些不能使用。因此如果不是APP端，需要将5+的方法全部替换成h5的方法。 mui中最关键的5+模块是webview控件，因此mui若要发挥其全部能力，凡是涉及到webview窗体的内容在非5+环境不能使用，涉及功能点包括： webview模式窗体动画 创建子窗口（除了为解决区域滚动的常见双webview场景，还涉及webview模式的选项卡等多webview场景） webview模式的侧滑菜单（也有div方式侧滑菜单） webview模式的tab选项卡（也有div方式选项卡） nativeUI，如原生的警告框、确认框、popover、actionsheet、toast。这些也有HTML5的实现。 预加载 页面传值（拓展参数及自定义事件） 对于这部分的内容，解决方法也有很多，如果mui提供了iframe模式的父子页面（主要兼容上拉加载下拉刷新），div模式的、侧滑菜单、选项卡、弹出框，页面传值也可以使用url传参或localStorage等本地存储的方法。在mui初级入门教程（二）— html5+ webview 底部栏用法详解一文中我也给出了iframe兼容webview模式tabbar的解决方法。 对于第三方插件，html5+中的方法可以优雅降级处理，采用h5的相关标准去实现，比如dcloud官方给出了一个定位的例子，查看这里plusto，plusto是为实现多端发布的一个开源JS库，该库可以根据平台实现API的自动转换，比如在5+ App环境下，将浏览器默认定位升级为5+原生定位，实现一套代码平滑迁移至多个平台。在微信中有jssdk同样可以调用系统的一些功能，大家可以自行判断。 或许有些人喜欢使用一些构建工具，对于多端发布使用构建工具确实会很方便，但是对于小白用户来说，可能会遇到更多问题，DCloud的mui及Hello mui示例是使用grunt构建的，grunt相关配置也都开源，感兴趣的朋友可以自行构建，后面有时间再整理一篇相关的文章加以说明。 参考文章 hello mui中的无等待窗体切换是如何实现的 mui适用场景说明，能不能在普通浏览器里使用，能否用于wap网站 多端发布开发指南 后记这篇文章基本都是copy相关的文档，加以增删，乃成此文。好久不写文，大神勿喷！ 最后放上demo地址： mui-demo：https://github.com/zhaomenghuan/mui-demo","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"webview","slug":"webview","permalink":"https://zhaomenghuan.github.io/tags/webview/"},{"name":"template","slug":"template","permalink":"https://zhaomenghuan.github.io/tags/template/"},{"name":"os","slug":"os","permalink":"https://zhaomenghuan.github.io/tags/os/"},{"name":"多端适配","slug":"多端适配","permalink":"https://zhaomenghuan.github.io/tags/多端适配/"}]},{"title":"JavaScript进阶学习（二）—— 基于原型链继承的js工具库的实现方法","slug":"JavaScript进阶学习（二）—基于原型链继承的js工具库的实现方法","date":"2016-07-02T16:00:00.000Z","updated":"2017-05-03T16:15:08.000Z","comments":true,"path":"2016/07/03/JavaScript进阶学习（二）—基于原型链继承的js工具库的实现方法/","link":"","permalink":"https://zhaomenghuan.github.io/2016/07/03/JavaScript进阶学习（二）—基于原型链继承的js工具库的实现方法/","excerpt":"","text":"前言写这篇文章的目的很简单，就是想把之前一些不太清晰的概念梳理一下，网上这类教程很多，但是本文尽可能还原问题本质，注意知识点之间的联系。相信看过我前面的博客的朋友一定知道我写文章的风格了，尽可能详尽，而且不是只是为了解决某一个小问题而写，方便大家知识点更体系，一篇内容其实相当于一章节的内容，容量有点大，我也不是一天完成的，一般是一周时间左右，所以大家阅读的话可能也需要一些时间才能有所收获。作为进阶教程，本文将简要讲述JavaScript面向对象编程的内容，但是不会介绍什么是接口，什么是对象，什么是对象属性，什么是对象方法，但是相信你看完了后自然理所当然的理解了这些基本概念。 重新认识window对象Window与window的区别在开始学习之前我们首先用一个工具，就是浏览器自带的开发者工具控制台。我这里用hbuider直接打开这个工具，在【web浏览器】预览工具栏右键单击会弹出一个框框，在这个框框中选择【Console】，然后在命令行输入js代码我们就可以看到执行结果，这里我们先输入一个window，然后会发现有json结构的内容。 我们如果不用控制台，直接用document.write(window);，页面上写出：[object Window],很显然内容不及这里直观，所以我们后面的很多内容会在控制台演示。熟练使用这个工具会给我们的开发带来很多好处，我想很多新手吐槽JavaScript不易调试，其实很多时候是他们不会调试。 很多博客在文章一开始讲一大堆理论，为了避免落入俗套，我们这里先做几个有趣的实验，我们在控制台继续输入window.top,window.window甚至window.window.window，…，我们会发现得到的结果居然一模一样。 1234&gt; window === window.window // true&gt; window === window.top // true&gt; window.top === window.window // true&gt; window.window === window.window.window // true 是不是有点晕了，这是什么鬼。。。不要急，我们接着看，我们来个更晕的，哈哈！12345678&gt; window // Window &#123;top: Window, window: Window, location: Location, chrome: Object, document: document…&#125;&gt; Window // function Window() &#123; [native code] &#125;&gt; window.Window // function Window() &#123; [native code] &#125;&gt; Window.window// undefined 这到底是什么鬼？window和Window到底是什么关系？ 我们下面来接着看看他们各自的类型：123&gt; typeof Window // \"function\"&gt; typeof window // \"object\"&gt; window instanceof Window // true 查阅资料发现： window 对象表示一个包含DOM文档的窗口，其 document 属性指向窗口中载入的 DOM文档 。window 对象实现了 Window 接口，此接口继承自 AbstractView 接口。一些额外的全局函数、命名空间、对象、接口和构造函数与 window 没有典型的关联，但却是有效的。这个接口从 EventTarget 接口继承属性，通过 WindowTimers 、WindowBase64 和 WindowEventHandlers 实现属性。 这么说相信新手应该没啥感觉，最好还是举个例子说说，比如我们去吃饭要点菜，Window说白了一个菜单，window是端上桌子的那道菜，至于这道菜色香味以及制作方法和Window无关，只和window有关。 Window规定了对象的类型，所以我们不难理解window instanceof Window的值为啥是true，Window是function。那么这里我们就清楚了window是Window的具体方法实现，而Window对象没有Window属性，所以Window.window为undefined，所以我们需要关注的是Window的属性方法。 我们在前面可以看出来window对象自身有top和window属性，类型为 Window，并且值是window本身；另外有个Window属性，值是Window对象，自然至此前面的内容也解释清楚了。 window 对象document属性（ 指向当前窗口内的文档节点）window.document指向document对象的引用，document对象是Document 接口接口的具体实现。Document 接口代表在浏览器及服务器中加载任意 web 页面，也作为 web 页面内容（DOM tree， 包含如 &lt;body&gt; 和 &lt;table&lt; 等 element）的入口。其它为文档（document）提供了全局性的函数，例如获取页面的URL、在文档中创建新的 element 的函数。Document 接口描述了支持所有文档类型的属性和方法。根据文档的类型（如 HTML、XML、SVG等等 ），对文档对象操作的API也会不一样：HTML 文档（text/html 类型的内容）实现了 HTMLDocument 接口，而SVG 文档实现了 SVGDocument 接口。 虽然这段话看起来，但是实际上意思很简单：如果我们要想获取一个document的内容，我们可以使用document对象下的方法属性和方法去获取，比如获取标题：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hello world&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 方法1 alert(document.title); // 方法2 // alert(window.document.title); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们这里的document为啥不加window也可以弹出结果呢，因为window为顶层对象，这里可以忽略不写，比如alert()方法其实是window.alert()下的方法，我们这里不写window，一样可以得到结果。另外，我们这里只是获取了title，至于其他的内容，那就要学习document的属性和方法。 __proto__属性（原型指针） 和 prototype属性（原型对象）说到这两个属性，我们真的很纠结，这两者到底有什么联系和区别呢？我们先看下面的例子： 1234&gt; window.prototype === window.__proto__ // false&gt; Window.prototype === window.__proto__ // true&gt; window.constructor === Window // true&gt; Window.__proto__.__proto__.__proto__.__proto__ // null 卧槽，这是什么鬼？prototype 和__proto__到底分别各自指什么，Window链式调用__proto__怎么最后会变成null? 似乎说到这里谜团越来越多了，我们这里就要跳出window对象举个简单例子说说，不然大家真的是晕的。1234567891011121314151617function person(name) &#123; this.name = name; this.getName = function() &#123; alert(this.name) &#125;&#125;var zhangsan = new person('zhangsan');var lisi = new person('lisi');console.log(zhangsan.name)console.log(lisi.name)zhangsan.getName();lisi.getName();结果：\"zhangsan\"\"lisi\" 注：可以使用关键字 this调用类中的属性, this是对当前对象的引用。 这样一个例子我们似乎看到了面向对象中继承的特性，在其他面向对象语言中，这里的person函数被设计为“类”，但是在JavaScript中这里设计得有点畸形的感觉，为啥这么说呢，因为这里的person是一个构造函数（constructor），用new实例化的也不是其他面向对象语言中的类，而是构造函数，这种设计导致一个问题是啥呢？无法共享属性和方法，每一个实例对象，都有自己的属性和方法的副本！！！ 比如：每一个实例对象都有getName（），都是从父亲构造器中继承得到，这样就产生多个副本，但是我们希望这个方法是公用的，避免多个副本的资源浪费，我们希望能够把公用的属性方法提取出来，然后实例化的对象也可以引用，但是不会直接拷贝一份作为副本。这个时候构造函数（constructor）显得有点力不从心了，JavaScript的设计者引入了一个重要的属性prototype，这个属性包含一个对象（通常称为“prototype对象”）。我们把这个例子改成用prototype写试试：123456789function person(name) &#123; this.name = name;&#125;person.prototype.getName = function() &#123; alert(this.name)&#125;var zhangsan = new person('zhangsan');var lisi = new person('lisi'); 这样我们多个实例化对象可以公用同一个方法，换句话说所有的实例对象共享同一个prototype对象，通常称为原型。一层层的继承实现了链条式的”原型链”（prototype chain），JavaScript因此通过这个原型链实现继承。至于为啥最开始怎么设计，都是为了开发者简单，但是也因此给大家的感觉是特别，而且特别难理解，但是事实上其实并没有那么神奇！！！ prototype属性很特殊，它还有一个隐式的constructor，指向了构造函数本身。123&gt; person.prototype.constructor === person // true&gt; zhangsan.constructor === person // true&gt; zhangsan.constructor === person.prototype.constructor // true 说了这个多，我们一直没有解释__proto__属性，我们上面讲了可以通过构造函数的prototype属性实现继承共用公用的属性方法，但是我们没有说明实例化对象如何访问到它所继承的对象的原型对象，这里的__proto__属性就是这个作用。我们再回过头去看之前的问题：因为window是通过实例化Window得到，自然我们访问Window原型对象有两种方法：1.直接通过Window的prototype属性；2.通过实例化子对象的__proto__访问父对象的原型对象。这两种方法实现的结果一模一样。1Window.prototype === window.__proto__ // true 另外在JavaScript中有一个很特别的地方：万物皆对象，万物皆为空。怎么理解呢，在JavaScript中的一切都源于对象，而且最顶层的对象是null对象，这会让人很费解的。所以当我们通过__proto__不断的寻找最顶层的原型对象时会发现为null。 基于原型的编程不是面向对象编程中体现的风格，且行为重用（在基于类的语言中也称为继承）是通过装饰它作为原型的现有对象的过程实现的。这种模式也被称为弱类化，原型化，或基于实例的编程。 最后有几点需要说明的是： 每个构造函数都有一个原型对象(prototype)，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。 除了使用__proto__方式访问对象的原型，还可以通过Object.getPrototypeOf方法来获取对象的原型，以及通过Object.setPrototypeOf方法来重写对象的原型。__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。 instanceof和Object.isPrototypeOf()可以判断两个对象是否是继承关系。如上面那个例子： 123456// instanceof 运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。&gt; zhangsan instanceof person=&gt; true// Object.isPrototypeOf()只要某个对象处在原型链上，都返回true。&gt; person.prototype.isPrototypeOf(zhangsan)=&gt; true 这里推荐大家看看下面几篇文章： JavaScript面向对象简介 JavaScript 原型中的哲学思想 Javascript继承机制的设计思想 如何打造一个自己的类jQuery的js工具库？文章写到本来是准备重新开篇的，刚刚上面在window下将原型链继承不知道会不会有点误导一些朋友，因为最开始是准备以window对象入手将面向对象的内容整理一下，发现写着写着有点零散了，因为window对象有很多其他内容值得将，但是篇幅和本文主题影响，只能先停下后面再开篇补充，讲了原型链继承的理论知识，我们自然要实际动手做点项目才能说明问题。 基本概念讲解如果我们去查看一些js库的写法，我们会发现经常有这样一种结构：123(function(w,undefined) &#123; //...&#125;)(window); 在理解为什么要这样写之前我们首先要明白什么JavaScript的作用域，什么是匿名函数，什么是闭包？ 作用域 在es6之前，JavaScript是遵循函数作用域，不支持块级作用域。 12345var i=0;if(i&lt;2)&#123; var i = 2;&#125;alert(i); // 2 在es6中支持使用let声明了一个块级域的本地变量，并且可以同时初始化该变量。 12345var i=0;if(i&lt;2)&#123; let i = 2;&#125;alert(i); // 0 函数内部可以直接读取函数全局变量。函数内的变量如果是使用var 申明，则是局部变量，作用域范围为函数体内部，不可读取；但是需要注意的是未经过var申明，就变成了全局变量，在函数外部也可以调用。 12345678910111213141516171819// 局部变量类型：var i=0;var fn = function () &#123; if(i&lt;2)&#123; var i = 2; &#125;&#125;fn();alert(i); // 0// 全局变量类型var i=0;var fn = function () &#123; if(i&lt;2)&#123; i = 2; &#125;&#125;fn();alert(i); // 2 变量提升：一个变量或函数可以在它被引用之后声明。 123456789101112【变量】foo = 2var foo;// 被隐式地解释为:var foo;foo = 2;【函数】hoisted(); // logs \"foo\"function hoisted() &#123; console.log(\"foo\");&#125; 匿名函数：没有函数名称的函数匿名函数是这样的：123function(arg1,arg2)&#123; // code&#125; 但是通常我们会把匿名函数写成自执行的匿名函数：123456789(function(arg1,arg2)&#123; // code&#125;)(a1,a2);等价于：var fn = function(arg1,arg2)&#123; // code&#125;fn(a1,a2); 其实这里就是实参与形参的关系，arg1，arg2在函数体内作为形参被引用，a1,a2作为实参在调用的时候传入到函数体中被调用，至于变量内部存储原理这里不做深入探究，毕竟学过编程的人应该都清楚。 我们现在回过头来看看本小节开头说的那个例子，为啥要那样写呢？123(function(w,undefined) &#123; //...&#125;)(window); 为什么要传入 window？通过传入 window变量，使得 window由全局变量变为局部变量，当在我们封装的代码块中访问 window时，不需要将作用域链回退到顶层作用域，这样可以更快的访问 window；同时将 window作为参数传入，可以在压缩代码时进行优化。 为什么要传入 undefined？在只执行匿名函数的作用域内，确保 undefined 是真的未定义。因为 undefined 能够被重写，赋予新的值。 闭包我们前面说了在函数外可以调用函数内未经过var声明的全局变量，但是如何从外部读取函数局部变量呢？我们可以在函数内部再定义一个函数。12345678910111213var fn = function()&#123; var name = 'local'; var f = function()&#123; alert(name); &#125; return f&#125;// 调用var resurlt = fn();resurlt();// orfn()(); 闭包主要有两个作用：一是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 读取函数内部变量我们很好理解，但是至于内部变量的值保存在存储中这个就有点难理解，我们看个例子：123456789101112131415var fn = function()&#123; var i = 0; add = function()&#123; i++; &#125; var f = function()&#123; alert(i); &#125; return f&#125;var result = fn();result(); // 0add();result(); // 1 add未加var 声明是全局变量，如果变量i不在内存中存储，那么我们第一次和第二次调用result()值都应该为0。原因在于我们将fn()的返回值f()数赋值给一个全局变量，由于这个全局变量一直处于内存中，f函数同样也在内存中，f()函数依赖于fn()函数，因此fn()中的局部变量i一直处于内存之中。如果上面的例子在调用的时候使用fn()()则不会出现这种情况。 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。—— 学习Javascript闭包（Closure） 这里简要讲解了一下闭包的一些作用，主要是为了帮助我们理解为啥一些js库采用闭包。 jQuery中链式调用的实现原理首先我们怎么实现私有命名空间？通过定义一个匿名函数，创建了一个”私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间，我们只暴漏出一个顶层的对象供外部调用即可。 前面我们讲到window对象的时候有个知识点没有说的是，我们在页面定义一个全局变量的时候，这个全局变量最终是会在window对象下，对于调用window对象下的属性和方法我们一般无需通过window.的形式就可以调用。同理当我们引用jQuery这种库的时候，jQuery对象会在引用页面的window对象下，这是因为jQuery库最后会将jQuery或者$对象挂在window对象下，这样就实现了顶层对象的暴漏。 下面我们实现一个适用于现代浏览器的极小DOM操作库，主要解决移动端，所以我们这里取名为mjs。1234567891011121314151617(function(w,undefined) &#123; // 构造函数 var mjs = function(selector, context) &#123; return new mjs.fn.init(selector, context); &#125; // 构造函数mjs的原型对象 mjs.fn = mjs.prototype = &#123; constructor: mjs, init: function (selector, context) &#123; //... &#125; &#125; mjs.fn.init.prototype = mjs.fn; // 为window全局变量添加mjs对象 w.mjs = w.m = mjs;&#125;)(window); 这样我们就可以无需new mjs()，直接使用 mjs.* 或者 m.* 链式调用相关方法。 selector（选择器）下面我们实现一个最简的选择器，这里我不考虑兼容低级版本浏览器，使用querySelectorAll实现。我们接着上面的完善mjs.prototype.init方法。我们如果不考虑链式调用，我们最简单的选择器甚至可以长这样：123456var $ = function (selector) &#123; return document.querySelector(selector);&#125;调用：$(\".content\") 如果想给选择器加一个上下文，我们进一步可以这样：1234567891011121314/** * 选择器 * @param &#123;Object&#125; selector * @param &#123;Object&#125; context */var $ = function (selector, context) &#123; var context = context || document; var el = context.querySelectorAll(selector); return Array.prototype.slice.call(el);&#125;;// 调用 var divObj = $('.div',$(\".content\")[0]);console.log(divObj[0].innerHTML) 当然我们这里补充完整就是这样了：1234567891011121314151617181920212223242526272829// 构造函数mjs的原型对象mjs.prototype = &#123; constructor: mjs, init: function (selector, context) &#123; if(!selector) &#123; return mjs; &#125;else if(typeof selector === 'object')&#123; var selector = [selector]; for (var i = 0; i &lt; selector.length; i++) &#123; this[i] = selector[i]; &#125; this.length = selector.length; return mjs; &#125;else if(typeof selector === 'string')&#123; var selector = selector.trim(); var context = context || document; var el = context.querySelectorAll(selector); var dom = Array.prototype.slice.call(el); var length = dom.length; for (var i = 0; i &lt; length; i++) &#123; this[i] = dom[i]; &#125; this.context = context; this.selector = selector; this.length = length; return this; &#125; &#125;&#125; 这里我们先只完成最简单的选择器功能，还有当selector是function类型的我们没有进行判断，这里不贴出来，大家具体可以看看源代码。我们可以验证一下我们封装的这个选择器：1234567891011121314&lt;div class=\"divBox\"&gt; div1 &lt;span&gt;span1&lt;/span&gt;&lt;/div&gt;console.log(mjs('.divBox')[0].innerHTML) // \"div1&lt;span&gt;span1&lt;/span&gt;\"console.log(mjs('.divBox span')[0].innerHTML)// \"span1\"var divBox = mjs('.divBox')[0];console.log(mjs('span',divBox)[0].innerHTML)// \"span1\" 因为innerHTML是原生DOM操作的方法，我们mjs对象没有这个方法，所以我们这里是将mjs对象转成了原生DOM对象，转换方法：mjs(selector)[0]。 html()、text()、attr()为了简单起见我们继续封装，先完成一个html()方法。1234567891011121314151617181920212223...html: function (content) &#123; if (content === undefined &amp;&amp; this[0].nodeType === 1) &#123; return this[0].innerHTML.trim(); &#125;else&#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; this[i].innerHTML = content; &#125; return this; &#125;&#125;,text: function (val) &#123; if (!arguments.length) &#123; return this[0].textContent.trim(); &#125; else &#123; for (var i = 0; i &lt; this.length; i++) &#123; this[i].innerText = val; &#125; return this; &#125;&#125;... 上面的例子我们可以这样调用：12345678910111213// 直接获取内容，默认获取第一个匹配项console.log(mjs('.divBox').html())console.log(mjs('.divBox span').html())console.log(mjs('.divBox span').text())// 更新内容，默认更新所有匹配项mjs('.divBox span').html('我是新的内容')mjs('.divBox span').text('我是新的内容')// 支持上下文查找方法console.log(mjs('span',mjs('.divBox')[0]).html())// 设置属性mjs('.divBox').attr('name','divBox');// 获取属性console.log(mjs('.divBox').attr('name')) prepend()、append()、before()、after()、remove()1234567891011121314151617181920212223242526272829303132333435prepend: function(str) &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; this[i].insertAdjacentHTML('afterbegin', str); &#125; return this;&#125;,append: function (str) &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; this[i].insertAdjacentHTML('beforeend', str); &#125; return this;&#125;,before: function (str) &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; this[i].insertAdjacentHTML('beforebegin', str); &#125; return this;&#125;,after: function (str) &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; this[i].insertAdjacentHTML('afterend', str); &#125; return this;&#125;,remove: function () &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; this[i].parentNode.removeChild(this[i]); &#125; return this;&#125; 调用：1234567// 添加元素mjs('.divBox').prepend('&lt;ul&gt;&lt;li&gt;prepend&lt;/li&gt;&lt;/ul&gt;')mjs('.divBox').append('&lt;ul&gt;&lt;li&gt;append&lt;/li&gt;&lt;/ul&gt;')mjs('.divBox').before('&lt;ul&gt;&lt;li&gt;before&lt;/li&gt;&lt;/ul&gt;')mjs('.divBox').after('&lt;ul&gt;&lt;li&gt;after&lt;/li&gt;&lt;/ul&gt;')// 删除元素mjs('.divBox').remove(); insertAdjacentHTML() 将指定的文本解析为 HTML 或 XML，然后将结果节点插入到 DOM 树中的指定位置处。该方法不会重新解析调用该方法的元素，因此不会影响到元素内已存在的元素节点。从而可以避免额外的解析操作，比直接使用 innerHTML 方法要快。——MDN insertAdjacentHTML 语法：element.insertAdjacentHTML(position, text);position 是相对于 element 元素的位置，并且只能是以下的字符串之一： beforebegin： 在 element 元素的前面。 afterbegin：在 element 元素的第一个子节点前面。 beforeend：在 element 元素的最后一个子节点后面。 afterend：在 element 元素的后面。 hasClass()、addClass()、removeClass()、toggleClass()1234567891011121314151617181920212223242526...hasClass: function (cls) &#123; return this[0].classList.contains(cls);&#125;,addClass: function (cls) &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; if(!this[i].classList.contains(cls))&#123; this[i].classList.add(cls); &#125; &#125; return this;&#125;,removeClass: function (cls) &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; if(this[i].classList.contains(cls))&#123; this[i].classList.remove(cls); &#125; &#125; return this;&#125;,toggleClass: function (cls) &#123; return this[0].classList.toggle(cls);&#125;... 调用方法：12345678// hasClass(返回值为布尔值)console.log(mjs(\".divBox\").hasClass('divBox'))// addClassmjs(\".divBox\").addClass('red')// removeClassmjs(\".divBox\").removeClass('red')// toggleClassmjs(\".divBox\").toggleClass('red') css()12345678910111213141516171819202122css: function (attr,val) &#123; var len = this.length; for(var i = 0;i &lt; len; i++) &#123; if(arguments.length === 1)&#123; var obj = arguments[0]; if(typeof obj === 'string')&#123; return getComputedStyle(this[i],null)[attr]; &#125;else if(typeof obj === 'object')&#123; for(var attr in obj)&#123; this[i].style[attr] = obj[attr]; &#125; &#125; &#125; else &#123; if(typeof val === 'function')&#123; this[i].style[attr] = val(); &#125;else&#123; this[i].style[attr] = val; &#125; &#125; &#125; return this;&#125; 调用方法：1234567891011121314151617181920// 获取样式属性值console.log(mjs(\".divBox\").css(\"color\"));// 设置样式属性值// 方法1mjs(\".divBox\").css(\"color\",\"red\");// 方法2mjs(\".divBox\").css(&#123; \"width\":\"100px\", \"color\":\"white\", \"background-color\":\"#98bf21\", \"font-family\":\"Arial\", \"font-size\":\"20px\", \"padding\":\"5px\"&#125;);// 方法3mjs('.divBox').css( 'background-color',function()&#123; return '#F00' &#125;) find()、first()、last()、eq(index)、parent()123456789101112131415find: function(selector)&#123; return this.init(selector,this[0])&#125;,first: function()&#123; return this.init(this[0])&#125;,last: function()&#123; return this.init(this[this.length-1])&#125;,eq: function(index)&#123; return this.init(this[index])&#125;,parent: function()&#123; return this.init(this[0].parentNode);&#125; 我们前面想通过上下文查找内容：1console.log(mjs('span',mjs('.divBox')[0]).html()) 我们可以通过find方法这样写：1234console.log(mjs('.divBox').find('span').html()) console.log(mjs('.divBox span').first().html())console.log(mjs('.divBox span').last().html())console.log(mjs('.divBox span').eq(1).html())console.log(mjs('.divBox span').eq(1).parent().html()) 关键在于mjs对象和原生dom的区别和相互转换。 至此我们封装了一个简单的类jQuery的工具库，当然对于一个完整的工具库，比如jQuery、zepto等，它们功能肯定是更为完善，封装了更多的方法，在异常处理及性能、可拓展性方法做得更好，由于本文的重点不是为了完成一个完整的库，在此只是抛砖引玉，只是学习一下常用的思想，有兴趣的朋友可以继续完善这个库。 参考文章MDN javascript可想造一个属于你自己的jQuery库?","categories":[{"name":"JavaScript进阶学习","slug":"JavaScript进阶学习","permalink":"https://zhaomenghuan.github.io/categories/JavaScript进阶学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhaomenghuan.github.io/tags/JavaScript/"},{"name":"原型链","slug":"原型链","permalink":"https://zhaomenghuan.github.io/tags/原型链/"},{"name":"jQuery","slug":"jQuery","permalink":"https://zhaomenghuan.github.io/tags/jQuery/"}]},{"title":"mui初级入门教程（五）—  聊聊即时通讯（IM），基于环信 web im SDK","slug":"mui初级入门教程（五）—聊聊即时通讯（IM），基于环信 web im SDK","date":"2016-06-14T16:00:00.000Z","updated":"2017-05-03T16:15:32.882Z","comments":true,"path":"2016/06/15/mui初级入门教程（五）—聊聊即时通讯（IM），基于环信 web im SDK/","link":"","permalink":"https://zhaomenghuan.github.io/2016/06/15/mui初级入门教程（五）—聊聊即时通讯（IM），基于环信 web im SDK/","excerpt":"","text":"写在前面感觉自从qq、微信这种APP用多了，现在都没啥人发短信了，现在什么APP都想加入IM的功能，曾经有段时间在折腾自己撸一个聊天的东西，也尝试过很多平台，今天这里给大家介绍一下从零开始自己做一个聊天的app功能。因为之前帮朋友做过一个基于环信的聊天功能，这里就以环信的平台为例举个例子说明。这篇文章注意想讲解一下集成这种第三方的一般实现方法，不会一下子就把所有的功能都集成，因为之前做环信主要是在微信上用，所以用的是环信的Web IM，遇到了蛮多坑，这次打算用dcloud这边的mui重新集成，所以在没有完全做完之前，所以也不知道有些坑具体能够在有限的时间内解决，本文仅供参考，欢迎大家去实践检验。在写这篇文章之前先贴一个Dcloud论坛中的资源帖，【即时通信、im问题汇总】 准备工作1.注册账号我们要先去环信官网注册一个账号，然后在后台创建一个应用，因为我们后面在做功能的时候可以用后面发送消息及图片来测试收消息，用户管理在后台也可以看得一清二楚。 {% image http://oo1uw74rb.bkt.clouddn.com/20160615001.png '环信官网' '' %} 创建成功后找到应用标识(AppKey)，这个在后期配置中会用到。 2.下载SDKhttp://www.easemob.com/download/im这里我们使用的是Web IM，所以下载的SDK是Web IM版本，下载之后我们会看到一个演示demo,由于这个是pc版本，和我们需求不一致，所以我们只需要关心sdk目录下的文件和sdk集成需要修改的配置文件easemob.im.config.js。1234567891011121314|---README.MD：|---index.html：demo首页，包含sdk基础功能和浏览器兼容性的解决方案|---static/： js/： easemob.im.config.js：sdk集成需要修改的配置文件 css/： img/： sdk/：/*sdk相关文件*/ release.txt：各版本更新细节 quickstart.md：环信WebIM快速入门文档 easemob.im-1.1.js：js sdk easemob.im-1.1.shim.js：支持老版本sdk api strophe.js：sdk依赖脚本 3.开发文档Web IM 介绍 http://docs.easemob.com/im/400webimintegration/10webimintro 项目实战由于这篇重在在于如何使用第三方开发IM，感觉说再多也诶有意义，直接上代码说明。不讲解过多的原理、细节，只讲究开发流程。 1.用户注册功能首先我们在hbuilder中先新建一个项目easemobIM,然后把环信sdk文件夹和配置文件拷贝到我们的工程中。为了节约时间，下面的功能演示我是根据官方登录模板改的。html/reg.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=\"../css/mui.min.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"../css/style.css\" rel=\"stylesheet\" /&gt; &lt;style&gt; .mui-input-group:first-child &#123; margin-top: 20px; &#125; .mui-input-group label &#123; width: 22%; &#125; .mui-input-row label~input, .mui-input-row label~select, .mui-input-row label~textarea &#123; width: 78%; &#125; .mui-checkbox input[type=checkbox], .mui-radio input[type=radio] &#123; top: 6px; &#125; .mui-content-padded &#123; margin-top: 25px; &#125; .mui-btn &#123; padding: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header class=\"mui-bar mui-bar-nav\"&gt; &lt;a class=\"mui-action-back mui-icon mui-icon-left-nav mui-pull-left\"&gt;&lt;/a&gt; &lt;h1 class=\"mui-title\"&gt;注册&lt;/h1&gt; &lt;/header&gt; &lt;div class=\"mui-content\"&gt; &lt;form class=\"mui-input-group\"&gt; &lt;div class=\"mui-input-row\"&gt; &lt;label&gt;手机&lt;/label&gt; &lt;input id='username' type=\"text\" class=\"mui-input-clear mui-input\" placeholder=\"请输入手机号码\"&gt; &lt;/div&gt; &lt;div class=\"mui-input-row\"&gt; &lt;label&gt;昵称&lt;/label&gt; &lt;input id='nickname' type=\"text\" class=\"mui-input-clear mui-input\" placeholder=\"请输入昵称\"&gt; &lt;/div&gt; &lt;div class=\"mui-input-row\"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input id='password' type=\"password\" class=\"mui-input-clear mui-input\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;div class=\"mui-input-row\"&gt; &lt;label&gt;确认&lt;/label&gt; &lt;input id='password_confirm' type=\"password\" class=\"mui-input-clear mui-input\" placeholder=\"请确认密码\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=\"mui-content-padded\"&gt; &lt;button id='reg' class=\"mui-btn mui-btn-block mui-btn-primary\"&gt;注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"../js/mui.min.js\"&gt;&lt;/script&gt; &lt;!--sdk--&gt; &lt;script src=\"../sdk/strophe.js\"&gt;&lt;/script&gt; &lt;script src=\"../sdk/easemob.im-1.1.js\"&gt;&lt;/script&gt; &lt;script src=\"../sdk/easemob.im-1.1.shim.js\"&gt;&lt;/script&gt;&lt;!--兼容老版本sdk需引入此文件--&gt; &lt;!--config--&gt; &lt;script src=\"../js/easemob.im.config.js\"&gt;&lt;/script&gt; &lt;script&gt; mui.init(); // 输入参数 var regConfig = &#123; username: mui(\"#username\")[0], nickname: mui(\"#nickname\")[0], password: mui(\"#password\")[0], passwordConfirm: mui(\"#password_confirm\")[0] &#125;; // 注册事件监听 mui(\"#reg\")[0].addEventListener('tap',function()&#123; var username = regConfig.username.value; var nickname = regConfig.nickname.value; var password = regConfig.password.value; var passwordConfirm = regConfig.passwordConfirm.value; // 电话号码校验 if (!isMobile(username))&#123; mui.toast(\"电话号码格式不正确\"); return; &#125; // 昵称非空校验 if (!isEmpty(nickname))&#123; mui.toast('昵称不能为空'); return; &#125; // 密码非空校验 if (!isEmpty(password))&#123; mui.toast('密码不能为空'); return; &#125; // 密码重复校验 if (passwordConfirm != password) &#123; mui.toast('密码两次输入不一致'); return; &#125; // 环信SDK注册 var options = &#123; username : username, password : password, nickname : nickname, appKey : Easemob.im.config.appkey, success : function(result) &#123; //注册成功; console.log(JSON.stringify(result)) mui.toast('注册成功'); &#125;, error : function(e) &#123; //注册失败; console.log(JSON.stringify(e)); mui.toast('注册失败：'+e.error); &#125; &#125;; Easemob.im.Helper.registerUser(options); &#125;); // 是否为电话号码 function isMobile(value) &#123; var validateReg = /0?(13|14|15|18)[0-9]&#123;9&#125;/; return validateReg.test(value); &#125; // 是否为空 function isEmpty(value)&#123; var validateReg = /^\\S+$/; return validateReg.test(value); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这是注册页面的代码，我们首先要引入环信的sdk和easemob.im.config.js，并且将easemob.im.config.js中的appkey换成自己的，然后根据用户名/密码/昵称注册环信 Web IM，提交注册的代码为:1234567891011121314151617var options = &#123; username : username, password : password, nickname : nickname, appKey : Easemob.im.config.appkey, success : function(result) &#123; //注册成功; console.log(JSON.stringify(result)) mui.toast('注册成功'); &#125;, error : function(e) &#123; //注册失败; console.log(JSON.stringify(e)); mui.toast('注册失败：'+e.error); &#125;&#125;;Easemob.im.Helper.registerUser(options); 我们注册完了后可以在环信后台【IM用户】查看用户注册信息，我们我们用其他平台，只需要把这块的内容改成相应的内容就OK。 2.用户登录功能有了注册页面的经验，我们写登录页面也很简单，页面布局脚本和其他与登录逻辑无关的代码我这里不贴了，大家在我最后给的地址上下载完整代码，这里只讲解基本基本思路。环信登录优两种方法，一种是通过实例化new Easemob.im.Connection()建立连接，一种是使用工具类Easemob.im.Helper.login2UserGrid(options)，我们刚刚注册就是使用了工具类，为了便于大家后面的学习，我们在这里把两种方法都说一下： 实例化new Easemob.im.Connection()建立连接1.创建连接1var conn = new Easemob.im.Connection(); 2.初始化连接123456conn.init(&#123; onOpened : function() &#123; alert(\"成功登录\"); conn.setPresence(); &#125;&#125;); 3.初始化连接123456// 打开连接conn.open(&#123; user : username, pwd : password, appKey : Easemob.im.config.appkey&#125;); 这里我们需要注意的是open()方法中需要配置的属性是user和pwd，这和我们注册时的有区别，要注意哦！ 这里需要说明的是init()是环信提供的一个通用的方法，比如后面我们要用到的接收文本消息、图片消息等一系列的回调方法都写在这个里面，onOpened()方法主要是用于当执行conn.open()方法时需要执行的方法，我们一般会把页面需要初始化的逻辑写在onOpened()中，比如查询好友。 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142// 输入参数var loginConfig = &#123; username: mui(\"#username\")[0], password: mui(\"#password\")[0]&#125;; // 创建一个新的连接var conn = new Easemob.im.Connection();// 初始化连接conn.init(&#123; onOpened : function() &#123; mui.toast(\"成功登录\"); conn.setPresence(); mui.openWindow(&#123; url: 'html/tab-webview-main.html', extras:&#123; username:loginConfig.username.value, password:loginConfig.password.value &#125; &#125;) &#125;&#125;);// 登录事件监听mui(\"#login\")[0].addEventListener('tap',function()&#123; var username = loginConfig.username.value; var password = loginConfig.password.value; // 电话号码校验 if (!isMobile(username))&#123; mui.toast(\"电话号码格式不正确\"); return; &#125; // 密码非空校验 if (!isEmpty(password))&#123; mui.toast('密码不能为空'); return; &#125; // 打开连接 conn.open(&#123; user : username, pwd : password, appKey : Easemob.im.config.appkey &#125;);&#125;); 工具类Easemob.im.Helper.login2UserGrid(options)建立连接12345678910111213141516171819202122// 登录var options = &#123; user : username, pwd : password, appKey : Easemob.im.config.appkey, success:function(data)&#123; console.log(JSON.stringify(data)) mui.toast(\"成功登录\"); mui.openWindow(&#123; url: 'html/tab-webview-main.html', extras:&#123; username:loginConfig.username.value, password:loginConfig.password.value &#125; &#125;) &#125;, error: function(e)&#123; console.log(JSON.stringify(e)) mui.toast(\"成功失败:\"+e); &#125;&#125;;Easemob.im.Helper.login2UserGrid(options); 上面我们用了两种方法讲解了登录的方法，各有优劣，第二种只做登录的工作，代码也比较简洁，但是当我们的页面是多个页面时我们的登录状态是不能检测到的，这个时候我们还是需要在每个页面通过创建连接初始化，所以我们在页面跳转过程加入了拓展参数extras传递参数，然后在登陆后的页面接收就可以。 3.页面传参深入探究为了尽可能简单的演示我们的功能，我这里不使用个性化的设计，就用官方模板组中的【mui底部选项卡（webview模式）】进行展示。新建模板文件如下： {% image http://i.imgur.com/JvDZUCk.png '' '' %} 我们去掉第一个选项卡，只保留消息tab-webview-subpage-chat.html、通讯录tab-webview-subpage-contact.html、设置tab-webview-subpage-setting.html三个选项卡。 拓展参数extras传值上一小节中，我们在登陆页面通过拓展参数extras传值，在主页面接收数据的方法为：123456mui.plusReady(function()&#123; var self = plus.webview.currentWebview(); var username = self.username; var password = self.password; mui.toast(\"username:\"+username+\"&lt;br /&gt;\"+\"password:\"+password);&#125;); 在主界面mui.plusReady方法里面拿到值，然后可以在创建子webview时候用拓展参数传值，然后在子页用下面的方法用同样的方法可以拿到值。但是其实我们不需要父页面向子页面发消息，直接在子页面通过这个找到父页面对象就OK了，如下：子页面代码：123456mui.plusReady(function()&#123; var self = plus.webview.currentWebview().parent(); var username = self.username; var password = self.password; console.log(\"username:\"+username+\"password:\"+password);&#125;); 预加载时使用mui.fire()传值这里需要特别说明一下的是我们有时候想要预加载我们的主页面，这里我们有个地方我需要特别注意的是，我们需要用mui.fire()传递参数： mui.fire(target,event,data) 特别提醒一下：target是需要接受参数的webview对象，而不是id，在这个地方我出过错误，当时一直没有察觉，如果是id，需要使用plus.webview.getWebviewById(id)进行转换。 比如我们在登陆页面使用preload预加载，代码如下：123456789...var mainPage = null;mui.plusReady(function()&#123; mainPage = mui.preload(&#123; \"url\": 'html/tab-webview-main.html', \"id\": 'main' &#125;);&#125;)... 登陆按钮监听事件中的success方法：123456789101112131415mui.fire(mainPage,'show',&#123; username:loginConfig.username.value, password:loginConfig.password.value&#125;);setTimeout(function() &#123; mui.openWindow(&#123; id: 'main', show: &#123; aniShow: 'pop-in' &#125;, waiting: &#123; autoShow: false &#125; &#125;);&#125;, 0); 在主页面中通过自定义show事件获得参数：12345678var username=null,password=null;// 页面传参数事件监听window.addEventListener('show',function(event)&#123; // 获得事件参数 username = event.detail.username; password = event.detail.password; console.log(\"username:\"+username+\"password:\"+password);&#125;); 我们需要注意的是我们刚刚在登录页面的账号密码传递到了tab-webview-main.html主页面，但是我们的每个子页面没有拿到账号密码。这里就有个容易犯错的地方，我们可能会直接在创建子webview时候通过拓展参数extras传值。 经过试验发现经过预加载的主界面tab-webview-main.html的mui.plusReady方法比页面的自定义事件监听先执行，这是因为我们通过预加载的时候其实已经就执行了mui.plusReady方法，而自定义事件是在webview打开的时候执行。当主界面被预加载时，子页面的loaded事件也随着完成，创建子页面的时候我们根本就没有拿到数据怎么传，自然在子页得到的是undefined。我们这个时候如果想在主界面生成子页面的时候通过拓展参数extras传递给子页面根本行不通！ 当需要接受参数的webview已经完成loaded事件，我们就不能使用拓展参数extras传参数，这个时候我们可以使用webview.evalJS()或者mui.fire();另外我们使用webview.evalJS()或者mui.fire()时，接收参数的页面的loaded事件也必须发生才能使用。 mui传参数只能相互关联的两个webview之间传，比如A页面打开B页面，B页面打开C页面，A页面可以传值给B页面，但是A页面不能传值给C页面，我们可以通过B页面传给C页面。 验证一个webview的loaded事件是否完成的方法：1234var ws = plus.webview.getWebviewById(id)ws.addEventListener( \"loaded\", function(e)&#123; console.log( \"Loaded: \"+e.target.getURL() );&#125;, false ); 验证一个webview的show事件是否完成的方法：1234var ws=plus.webview.currentWebview();ws.addEventListener(\"show\", function(e)&#123; console.log( \"Webview Showed\" );&#125;, false ); 说这两个监听事件有啥用处呢，我们在预加载webview的时候，预加载完成的过程，loaded事件也随之完成，但是只有页面被打开时，show事件才完成，我们可以选择合适的时机发送或者接受参数。 这里需要说明的是如果你想localstorage、Storage等本地存储传值，完全可以不用extras或者mui.fire()，当然还可以用url传参数。 因为当初就是为了一个想法，预加载试试，然后试着试着各种问题，不过也因此明白了很多规则和调试方法，在这里提出来顺便总结一下页面传参需要注意的问题，免得新手在此花了很多冤枉时间，搞得现在都快忘了前面写了啥。其实这一部分可以独立出来，但是总感觉这种东西不是啥难事，脱离实际去讲总觉得不合适。 4.获取好友列表及添加好友获取好友列表我们在登陆页面与环信的服务器建立了联系，但是由于我们执行跳转了，我们依然还需要在需要请求数据时候在当前页面再次建立连接，前面我们讲到可以通过实例化new Easemob.im.Connection()建立连接，我们这里可以在当前页面实例化建立连接，而不是使用登录时的登陆工具类。实例化new Easemob.im.Connection()的三个步骤大家可以查看前面的内容，这里需要说明的是我们获取好友列表是在conn.init方法的onOpened : function(){}; 中添加 getRoster 回调方法，从而获取好友列表。 1234567891011121314151617181920212223242526272829303132// 创建连接var conn = new Easemob.im.Connection();// 初始化连接conn.init(&#123; onOpened : function()&#123; // mui.toast(\"成功登录\"); conn.setPresence(); //设置在线状态 conn.getRoster(&#123; success : function(roster) &#123; console.log(JSON.stringify(roster)) // 获取当前登录人的好友列表 for ( var i in roster) &#123; var ros = roster[i]; //好友的对象 //ros.name为好友名称 &#125; &#125; &#125;); &#125;&#125;); mui.plusReady(function()&#123; var self = plus.webview.currentWebview().parent(); var username = self.username; var password = self.password; console.log(\"username:\"+username+\"password:\"+password); // 打开连接 conn.open(&#123; user : username, pwd : password, appKey : Easemob.im.config.appkey &#125;);&#125;); 很显然我们在执行后是空的，因为从开始到现在我们都是自己和自己玩，都没有找朋友，那下面我们就去找朋友，之所以先要把这个先写出来，因为这个我觉得是基本逻辑，你待会儿加了好友，怎么看，就通过这里查询，然后才能说后面的聊天。 添加好友首先我们得去邀请对方吧，那么我们得知道对方的号码吧，上面我们用的是手机号码作为用户名，为的就是保证用户ID唯一性。 邀请发起方： 我们通过执行conn.subscribe可以发起邀请，添加发起方，获取要添加好友名称，参数为：1234&#123; to: user, //对方用户名 message:\"加个好友呗\" //对方收到的消息&#125; 这里我们在头部右上角叫一个添加好友按钮：1&lt;button id=\"addfriend\" class=\"mui-btn mui-btn-blue mui-btn-link mui-pull-right\"&gt;添加&lt;/button&gt; 为了简单演示，我们直接弹出一个输入对话框：1234567891011121314151617// 添加好友mui(\"#addfriend\")[0].addEventListener('tap',function(e)&#123; e.detail.gesture.preventDefault(); var btnArray = ['确定','取消']; mui.prompt('请输入你要添加的好友的用户名：', '手机号', '邀请好友', btnArray, function(e) &#123; if (e.index == 0) &#123; var user = e.value; conn.subscribe(&#123; to : user, message : \"加个好友呗\" &#125;); mui.toast('邀请发送成功！'); &#125; else &#123; mui.toast('你取消了发送！'); &#125; &#125;);&#125;) 需要说明的是如果添加好友是一个单独的页面，或者说所在页面没有和环信建立连接，依然还有进行前面说的三步连接。 邀请接受方：被添加方，在 con.init 方法中调用 handlePresence 回调方法。1234567891011121314151617181920212223242526272829303132conn.init(&#123; //收到联系人订阅请求的回调方法 onPresence : function(message) &#123; handlePresence(message); &#125;&#125;); //easemobwebim-sdk中收到联系人订阅请求的处理方法，具体的type值所对应的值请参考xmpp协议规范var handlePresence = function(e) &#123; mui.toast(JSON.stringify(e)); var user = e.from; //（发送者希望订阅接收者的出席信息） if (e.type == 'subscribe') &#123; mui.confirm('有人要添加你为好友', '添加好友', ['确定','取消'], function(e)&#123; if (e.index == 0) &#123; //同意添加好友操作的实现方法 conn.subscribed(&#123; to : user, message : \"[resp:true]\" &#125;); mui.toast('你同意添加好友请求'); &#125; else &#123; //拒绝添加好友的方法处理 conn.unsubscribed(&#123; to : user, message : \"rejectAddFriend\" &#125;); mui.toast('你拒绝了添加好友'); &#125; &#125;) &#125;&#125;; 前面登陆注册一直很顺利，没啥问题，但是做这个请求好友的时候就出问题了，我们在发送好友请求的时候，然后切换账号登陆的时候接受不到消息。调了好久才发现一些问题： 我们发送好友的消息在主界面，所以我初始化了连接，接受消息的在子页面也初始化了连接，居然有时候会有提示onflict，有两种方法：第一，主界面不做任何请求的事，点击添加好友时候，父页面给子页面发消息，然后子页面执行请求添加好友；第二，所有的初始化请求放在主界面，然后收到消息给对应的子页面发消息，为了减少请求，个人采用第二种方法。 当解决上面的冲突问题，为什么登录后收不到消息？这里有个略坑的是环信文档中查询好友时候把onOpened中的这句conn.setPresence();屏蔽了，然后就收不到消息。查文档 常见问题 中说：登录之后需要设置在线状态，才能收到消息。请检查登录成功后是否调用过 conn.setPresence();。加上果然没问题了。。。 剩下的功能我们主要看这个文档 初始化连接，主要是说明了初始化时候的一些回调函数的基本用法，我们这里先来看看onPresence，这个是收到联系人订阅请求的回调方法，基本数据类型如下：12345678910&#123; \"from\":\"xxxxxxxxxxx\", \"to\":\"yyyyyyyyyyy\", \"fromJid\":\"jszblog#musicbox_xxxxxxxxxxx@easemob.com\", \"toJid\":\"jszblog#musicbox_yyyyyyyyyyy@easemob.com\", \"type\":\"subscribe\", \"chatroom\":false, \"destroy\":false, \"status\":\"加个好友呗\"&#125; 这里的xxxxxxxxxxx和yyyyyyyyyyy是电话号码，以为我是用电话作为用户名的，出于隐私保护用字母代替。 当我们切换账号会发现查询好友的地方可以查到好友，下面我们就进行好友列表展示，然后就是和好友聊天咯。 5.数据绑定和本地缓存处理机制当我们重新登录的时候打印roster时会得到下面的json对象：123456[&#123; \"subscription\":\"from\", \"jid\":\"jszblog#musicbox_xxxxxxxxxxx@easemob.com\", \"name\":\"xxxxxxxxxxx\", \"groups\":[]&#125;] 为了考虑如果用户没有联网或者数据不能及时更新也能够正常看到历史记录，这里我们考虑做缓存，由于环信web im不具备缓存功能，所以我们这里采用本地存储作为缓存的方案，本地存储可以使用5+中的storage模块，也可以使用localStorage、sessionStorage，由于storage模块中的数据有效域不同，可在应用内跨域操作，数据存储期是持久化的，并且没有容量限制，这里我们采用这个方案，至于如果想把本案例中的例子用于浏览器端的同志，可以采用localStorage作缓存功能。 html5+中的storage模块比较简单，文档中介绍了几个基本方法，具体看看文档就可以学会使用，文档见 【storage】。 plus.storage.setItem(key, value); plus.storage.setItem在存储时是以key-value的形式存储，我们可以在查询到好友信息时候，将对象转换成字符串存储在本地，JSON.stringify()将json对象转换成json字符串。1plus.storage.setItem(\"roster\",JSON.stringify(roster)); plus.storage.getItem(key); 我们在子页面通过plus.storage.getItem获取存储的字符串，然后通过JSON.parse()将字符串转化成对象获取相关信息。12345var roster = plus.storage.getItem(\"roster\");var obj = JSON.parse(roster);for(var i in obj)&#123; console.log(obj[i].name);&#125; 我们现在要做的无非是将信息展示出来，但是这里有用的信息目前只有name，毕竟没有上传文件，所以也不存在头像、昵称、签名这种个性化信息。如何把json信息展示出来前面的文章中我们是使用直接生成dom节点或者拼接html字符串，但是这种过于繁琐，当然也有人使用【js模板引擎】，本来准备早点在文章中给一些新手介绍一下vue.js这种MV-*框架，但是考虑本文中实例的性能，暂且还是用之前用过的一个js模板引擎artTemplate，文档戳这里：https://github.com/aui/artTemplate。artTemplate有简洁语法版和原生语法版，就是使用语法不一样而已，这里我使用简洁语法版，戳这里下载—— 下载地址 为了简单，我们采用模板中通讯录的html结构，文档中有这样的一个例子： 编写模板：使用一个type=”text/html”的script标签存放模板： &lt;script id=\"test\" type=\"text/html\"&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;ul&gt; {{each list as value i}} &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt; {{/each}} &lt;/ul&gt; &lt;/script&gt; 渲染模板：123456var data = &#123; title: '标签', list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']&#125;;var html = template('test', data);document.getElementById('content').innerHTML = html; 具体语法参考这里：artTemplate 简洁版语法 我们可以这样写：1234&lt;div class=\"mui-content\"&gt; &lt;!--内容--&gt; &lt;ul id=\"roster-cnt\" class=\"mui-table-view mui-table-view-striped mui-table-view-condensed\"&gt;&lt;/ul&gt;&lt;/div&gt; &lt;script id=\"roster-tpl\" type=\"text/template\"&gt; {{each roster as value index}} &lt;li class=\"mui-table-view-cell\" data-chatname=\"{{value.name}}\"&gt; &lt;div class=\"mui-slider-cell\"&gt; &lt;div class=\"oa-contact-cell mui-table\"&gt; &lt;div class=\"oa-contact-avatar mui-table-cell\"&gt; &lt;img src=\"http://placehold.it/60x60\" /&gt; &lt;/div&gt; &lt;div class=\"oa-contact-content mui-table-cell\"&gt; &lt;div class=\"mui-clearfix\"&gt; &lt;h4 class=\"oa-contact-name\"&gt;小青年&lt;/h4&gt; &lt;span class=\"oa-contact-position mui-h6\"&gt;湖北&lt;/span&gt; &lt;/div&gt; &lt;p class=\"oa-contact-email mui-h6\"&gt; {{value.name}} &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; {{/each}} &lt;/script&gt; 123456789mui.plusReady(function()&#123; var roster = plus.storage.getItem(\"roster\"); // console.log(roster); var data = &#123; roster: JSON.parse(roster) &#125; var html = template('roster-tpl', data); document.getElementById('roster-cnt').innerHTML = html;&#125;) 我们其实可以直接先遍历找到name然后填充就ok，这为了后续方便添加昵称、地址、头像等个性化地址，直接使用artTemplate的each方法。 6.聊天消息封装当我们完成了前面登陆、注册、添加好友等功能，我们就进行最重要的内容了，既然是聊天功能，当然要聊起来，不然就不叫IM，但是很多人一开始就太过于关注聊天这个功能，而忽略了前面的基础过程，导致对api不熟悉，自然些聊天过程也是漏洞百出，代码逻辑混乱，所以也就放弃了。本文为即时通讯第一篇，没有介绍过多原理，也没有介绍聊天过程的高级功能，仅作为新手入门的基础篇介绍，后面会再深入探究更多内容。废话不多说，我们继续看文档写下面的内容。 我们先新建一个single-chat.html，本文不打算基于html mui中的页面去构建聊天页面，打算从零开始写。 首先我们需要在刚刚那个通讯录页面里面点击进入聊天页面，将用户名的值传到聊天页面，我们可以直接在创建的时候用拓展参数传，或者预加载打开时用mui.fire(),不多说，自己参考第三小节。 我们先说说布局的问题，先上图 clipboard.png 对应的布局详细代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;style&gt;.chat-history-date&#123; display: block; padding-top: 5px; text-align: center; font-size: 12px;&#125;.chat-receiver,.chat-sender&#123; margin: 5px; clear:both; &#125;.chat-avatar img&#123; width: 40px; height: 40px; border-radius: 50%;&#125;.chat-receiver .chat-avatar&#123; float: left;&#125;.chat-sender .chat-avatar&#123; float: right;&#125;.chat-content&#123; position: relative; max-width: 60%; min-height: 20px; margin: 0 10px 10px 10px; padding: 10px; font-size:15px; border-radius:7px; &#125;.chat-content img&#123; width: 100%;&#125;.chat-receiver .chat-content&#123; float: left; color: #383838; background-color: #f5f5f5;&#125;.chat-sender .chat-content&#123; float:right; color: #ffffff; background-color: #15b5e9; &#125;.chat-triangle&#123; position: absolute; top:6px; width:0px; height:0px; border-width:8px; border-style:solid; &#125;.chat-receiver .chat-triangle&#123; left:-16px; border-color:transparent #f5f5f5 transparent transparent; &#125;.chat-sender .chat-triangle&#123; right:-16px; border-color:transparent transparent transparent #15b5e9; &#125;&lt;/style&gt;&lt;!--消息最后历史时间--&gt;&lt;p class=\"chat-history-date\"&gt;01:59&lt;/p&gt;&lt;!--接收文本消息--&gt;&lt;div class=\"chat-receiver\"&gt; &lt;div class=\"chat-avatar\"&gt; &lt;img src=\"../img/chat-1.png\"&gt; &lt;/div&gt; &lt;div class=\"chat-content\"&gt; &lt;div class=\"chat-triangle\"&gt;&lt;/div&gt; &lt;span&gt;如果是接受消息，请使用.chat-receiver类，如果是发送消息，请使用.chat-sender，头像是.chat-avatar类，内容是.chat-content类。.chat-content下如果是span标签则为文本消息，若为img标签则为图片消息。&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--发送文本消息--&gt;&lt;div class=\"chat-sender\"&gt; &lt;div class=\"chat-avatar\"&gt; &lt;img src=\"../img/chat-2.png\"&gt; &lt;/div&gt; &lt;div class=\"chat-content\"&gt; &lt;div class=\"chat-triangle\"&gt;&lt;/div&gt; &lt;span&gt;如果你要修改聊天气泡的背景颜色，请修改.chat-content的background-color和.chat-triangle的border-color&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--发送图片消息--&gt;&lt;div class=\"chat-sender\"&gt; &lt;div class=\"chat-avatar\"&gt; &lt;img src=\"../img/chat-2.png\"&gt; &lt;/div&gt; &lt;div class=\"chat-content\"&gt; &lt;div class=\"chat-triangle\"&gt;&lt;/div&gt; &lt;img src=\"../img/test.jpg\"/&gt; &lt;/div&gt;&lt;/div&gt; 我们的消息分为发送和收到两种情况，上面是静态效果，我们下面需要做的事获取数据然后动态展示，现在我们先封装一下页面展示效果的代码。这里我们使用两种方法，一种是直接用js生成dom节点，这种使用于结构固定后面不需要改动的，直接用一个js function封装，每次调用一行代码就可以直接显示内容，这样想想都觉得很棒。 老司机，别说话，快看代码！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @description 显示消息 * @param &#123;String&#125; who 消息来源,可选参数: &#123;params&#125; 'sender','receiver' * @param &#123;Object&#125; type 消息类型,可选参数: &#123;params&#125; 'text','url','img' * @param &#123;JSON&#125; data 消息数据,可选参数: &#123;params&#125; * ('text'和'url'类型的msg是文字，img类型的msg是img地址) */var appendMsg = function(who,type,data) &#123; // 生成节点 var domCreat = function(node)&#123; return document.createElement(node) &#125;; // 基本节点 var msgItem = domCreat(\"div\"), avatarBox = domCreat(\"div\"), contentBox = domCreat(\"div\"), avatar = domCreat(\"img\"), triangle = domCreat(\"div\"); // 头像节点 avatarBox.className=\"chat-avatar\"; avatar.src = (who==\"sender\")?data.senderAvatar:data.receiverAvatar; avatarBox.appendChild(avatar); // 内容节点 contentBox.className=\"chat-content\"; triangle.className=\"chat-triangle\"; contentBox.appendChild(triangle); // 消息类型 switch (type)&#123; case \"text\": var msgTextNode = domCreat(\"span\"); var textnode=document.createTextNode(data.msg); msgTextNode.appendChild(textnode); contentBox.appendChild(msgTextNode); break; case \"url\": var msgUrlNode = domCreat(\"a\"); var textnode=document.createTextNode(data.msg); if(data.indexOf('http://') &lt; 0)&#123; data.msg = \"http://\" + data.msg; &#125; msgUrlNode.setAttribute(\"href\",data.msg); msgUrlNode.appendChild(textnode); contentBox.appendChild(msgUrlNode); break; case \"img\": var msgImgNode = domCreat(\"img\"); msgImgNode.src = data.msg; contentBox.appendChild(msgImgNode); break; default: break; &#125; // 节点连接 msgItem.className=\"chat-\"+who; msgItem.appendChild(avatarBox); msgItem.appendChild(contentBox); document.querySelector(data.el).appendChild(msgItem);&#125; 其实后面我们拓展也很容易的，只需要不断加type类型就ok，这些都是dom操作的基本方法，如果对一些方法不熟悉，建议看看相关的内容。这里遵照JSDoc+规范还加上了使用参数提示，在hbuilder使用可以查看参数含义，再也不用担心写代码时忘记了参数含义。 这里我们也可以用模板引擎的办法去封装，代码如下： 模板内容： &lt;script id=\"msg-tpl\" type=\"text/html\"&gt; &lt;div class=\"chat-{{who}}\"&gt; &lt;div class=\"chat-avatar\"&gt; &lt;img src=\"{{avatar}}\"&gt; &lt;/div&gt; &lt;div class=\"chat-content\"&gt; &lt;div class=\"chat-triangle\"&gt;&lt;/div&gt; {{if type==\"text\"}} &lt;span&gt;{{msg}}&lt;/span&gt; {{else if type==\"url\"}} &lt;a href=\"{{msg}}\"&gt;{{msg}}&lt;/a&gt; {{else if type==\"img\"}} &lt;img src=\"{{msg}}\"/&gt; {{/if}} &lt;/div&gt; &lt;/div&gt; &lt;/script&gt; 模板渲染：12345678910111213141516/** * @description 显示消息 * @param &#123;String&#125; who 消息来源,可选参数: &#123;params&#125; 'sender','receiver' * @param &#123;Object&#125; type 消息类型,可选参数: &#123;params&#125; 'text','url','img' * @param &#123;JSON&#125; data 消息数据,可选参数: &#123;params&#125; * ('text'和'url'类型的msg是文字，img类型的msg是img地址) */var appendMsg = function(who,type,data)&#123; var html = template('msg-tpl', &#123; who: who, type: type, avatar: who=='sender'?data.senderAvatar:data.receiverAvatar, msg: data.msg &#125;); document.querySelector(data.el).innerHTML += html;&#125; 大家使用也很简单，调用方法如下：123456appendMsg('sender','text',&#123; el: '#msg-list', //消息容器 senderAvatar: '../img/chat-1.png', //发送者头像 receiverAvatar: '../img/chat-2.png', //接收者头像 msg: '你好' //消息内容&#125;) 如果大家觉得每次调用还要填写容器id，头像地址这种基本固定的内容很麻烦，大家也可以继续封装：1234567891011121314151617181920212223/** * 消息初始化 */var msgInit = &#123; el: '#msg-list', //消息容器 senderAvatar: '../img/chat-1.png', //发送者头像 receiverAvatar: '../img/chat-2.png' //接收者头像&#125;/** * @description 展示消息精简版 * @param &#123;String&#125; who 消息来源,可选参数: &#123;params&#125; 'sender','receiver' * @param &#123;Object&#125; type 消息类型,可选参数: &#123;params&#125; 'text','url','img' * @param &#123;Object&#125; msg ('text'和'url'类型的msg是文字，img类型的msg是img地址) */var msgShow = function(who,type,msg)&#123; appendMsg(who,type,&#123; el: msgInit.el, senderAvatar: msgInit.senderAvatar, receiverAvatar: msgInit.receiverAvatar, msg: msg &#125;);&#125; 调用方法很简单：1msgShow('sender','text','你好'); 两种方法实现封装的函数一样，这里只是给大家演示一下对于这种动态结构的html的一些方法，当然只要你愿意，你可以直接用字符串拼接，或者用&lt;template&gt;&lt;/template&gt;标签自己做一个这样的模板引擎，或者使用使用更加方便的mvc或mvvm框架。 之所以要花大篇幅内容将这些基础内容，是因为看到很多人代码写得那叫一个混乱，如果接口啥的一改，我相信这些人会疯掉，因为代码缺乏一定的通用性，没有把变与不变的内容分别拿出来。当然我们上面其实有些东西没有封装进去，比如用户名或者昵称，这在群聊中是有必要的，这里只是以最简单的例子来说明，大家可以根据自己的业务需求自由发挥。 7.单聊之文本消息基本思路其实写到这里本篇基本也算告一段落，但是考虑到很多新手对于收发消息很多还是有一些问题，我们这里就还是把文本消息发送接收写完了再收篇。 上面我们我们讲了怎么把消息展示出来，但是毕竟聊起来数据是动态的，那么发送接收数据是很重要的一步，先来写发送消息。我们先定义一个底部的输入框加按钮，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style type=\"text/css\"&gt;footer &#123; position: fixed; width: 100%; height: 50px; min-height: 50px; border-top: solid 1px #bbb; left: 0px; bottom: 0px; overflow: hidden; padding: 0px 50px; background-color: #fafafa;&#125;.footer-left &#123; position: absolute; width: 50px; height: 50px; left: 0px; bottom: 0px; text-align: center; vertical-align: middle; line-height: 100%; padding: 12px 4px;&#125;.footer-right &#123; position: absolute; width: 50px; height: 50px; right: 0px; bottom: 0px; text-align: center; vertical-align: middle; line-height: 100%; padding: 12px 5px; display: inline-block;&#125;.footer-center &#123; height: 100%; padding: 5px 0px;&#125;.footer-center [class*=input] &#123; width: 100%; height: 100%; border-radius: 5px;&#125;.footer-center .input-text &#123; background: #fff; border: solid 1px #ddd; padding: 10px !important; font-size: 16px !important; line-height: 18px !important; font-family: verdana !important; overflow: hidden;&#125;footer .mui-icon &#123; color: #000;&#125;footer .mui-icon:active &#123; color: #007AFF !important;&#125;.footer-right span&#123; color: #0062CC; line-height: 30px;&#125;&lt;/style&gt;&lt;div class=\"mui-content\"&gt; &lt;div id=\"msg-list\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;footer&gt; &lt;div class=\"footer-left\"&gt; &lt;i id='msg-choose-img' class=\"mui-icon mui-icon-camera\" style=\"font-size: 28px;\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=\"footer-center\"&gt; &lt;textarea id='msg-text' type=\"text\" class='input-text'&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"footer-right\"&gt; &lt;span id='msg-send-text'&gt;发送&lt;/span&gt; &lt;/div&gt;&lt;/footer&gt; 为了代码整洁规范，方便后期封装，参考hello mui中im-chat.html的写法，我们先定义一下ui控件对象：123456789// UI控件对象var ui = &#123; content: mui('.mui-content'[0]), msgList: mui('#msg-list')[0], footer: mui('footer')[0], msgChooseImg: mui(\"#msg-choose-img\")[0], msgText: mui('#msg-text')[0], msgSendText: mui('#msg-send-text')[0]&#125; 发送文本消息很简单：123456789101112131415161718192021222324252627282930313233// 发送文本消息ui.msgSendText.addEventListener('tap',function()&#123; sendText();&#125;)// 发送文本var sendText = function()&#123; var msg = ui.msgText.value.replace(new RegExp('\\n', 'gm'), '&lt;br/&gt;'); var validateReg = /^\\S+$/; // 获得键盘焦点 msgTextFocus(); if(validateReg.test(msg))&#123; // 消息展示出来 msgShow('sender','text',msg); // 发送文本消息到环信服务器 conn.sendTextMessage(&#123; to: chatName, //用户登录名，SDK根据AppKey和domain组织jid，如easemob-demo#chatdemoui_**TEST**@easemob.com，中\"to:TEST\",下同 msg: msg, //文本消息 type: \"chat\" //ext :&#123;\"extmsg\":\"extends messages\"&#125;//用户自扩展的消息内容（群聊用法相同） &#125;); // 清空文本框 ui.msgText.value = ''; // 恢复输入框高度(因为我们这里是50px，你可以写一个全局变量) ui.footer.style.height = '50px'; // 保持输入状态 mui.trigger(ui.msgText, 'input', null); // 这一句让内容滚动起来 msgScrollTop(); &#125;else&#123; mui.toast(\"文本消息不能为空\"); &#125;&#125; 这里的msgTextFocus();和msgScrollTop();是封装的两个方法，具体的且看下文。 再来说说收消息，我们需要在conn.init()配置设置收到消息的回调函数onTextMessage:123456789101112131415161718192021// 初始化连接conn.init(&#123; onOpened : function()&#123; //mui.toast(\"成功登录\"); conn.setPresence(); &#125;, // 收到文本消息时的回调函数 onTextMessage : function(message) &#123; // console.log(JSON.stringify(message)); var from = message.from;//消息的发送者 var msg = message.data;//文本消息体 //mui.toast(msg); // 收到文本消息在页面展示 msgShow('receiver','text',msg); msgScrollTop(); &#125;, // 收到图片消息时的回调函数 onPictureMessage : function(message) &#123; handlePictureMessage(message); &#125;&#125;); 至此我们完成了基本的文本消息收发功能，但是有几个细节是需要处理的，比如我们上面说的两个函数啥意思，我们没有解释。 获得输入框焦点事件和强制弹出软键盘我们如果不做处理，在输入框失去焦点时软键盘会自动收回软键盘，这样很影响聊天时候的用户体验。这个时候我们可以在输入完内容，准备发送时，保持输入状态mui.trigger(ui.msgText, &#39;input&#39;, null);。 让输入框获得焦点的方法：1234567// 获得输入框键盘焦点var msgTextFocus = function()&#123; ui.msgText.focus(); setTimeout(function() &#123; ui.msgText.focus(); &#125;, 150);&#125; 强制弹出软键盘的方法：123456789101112131415// 强制弹出软键盘var showKeyboard = function() &#123; if (mui.os.ios) &#123; var webView = plus.webview.currentWebview().nativeInstanceObject(); webView.plusCallMethod(&#123; \"setKeyboardDisplayRequiresUserAction\": false &#125;); &#125; else if(mui.os.android) &#123; var Context = plus.android.importClass(\"android.content.Context\"); var InputMethodManager = plus.android.importClass(\"android.view.inputmethod.InputMethodManager\"); var main = plus.android.runtimeMainActivity(); var imm = main.getSystemService(Context.INPUT_METHOD_SERVICE); imm.toggleSoftInput(0,InputMethodManager.SHOW_FORCED); &#125;&#125;; 聊天消息高度调整聊天消息如何发送或者收到一条自己往上滚动呢？我们看qq消息就是最后一条消息就会自动出现在输入框之上，调整方法是使用scrollTop方法，通过计算scrollHeight和`offsetHeight的高度，实现调整。对这些高度不理解？看这里： HTML 获取屏幕、浏览器、页面的高度宽度 深入理解高度。获取屏幕、webview、软键盘高度 其实这个地方有很多技术细节，比如消息高度虽然可以获取，但是要实现局部滚动，那么必须禁止浏览器默认的滚动模式，具体可以看看这篇文章的实现原理浅议内滚动布局 具体css样式设置方法：1234567891011121314151617181920html,body &#123; height: 100%; margin: 0px; padding: 0px; overflow: hidden; -webkit-touch-callout: none; -webkit-user-select: none;&#125;.mui-content&#123; height: 100%; padding: 44px 0px 50px 0px; overflow: auto; background-color: #eaeaea;&#125;#msg-list &#123; height: 100%; overflow: auto; -webkit-overflow-scrolling: touch;&#125; 调用的函数封装如下：1234// 消息滚动var msgScrollTop = function()&#123; ui.msgList.scrollTop = ui.msgList.scrollHeight + ui.msgList.offsetHeight;&#125; 输入框高度如何自适应不多说直接上代码：12345// 输入框监听事件ui.msgText.addEventListener('input', function(event) &#123; msgTextFocus(); ui.footer.style.height = this.scrollHeight + 'px';&#125;); 解决长按导致致键盘关闭的问题123456789// 解决长按“发送”按钮，导致键盘关闭的问题；ui.msgSendText.addEventListener('touchstart', function(event) &#123; msgTextFocus(); event.preventDefault();&#125;);ui.msgSendText.addEventListener('touchmove', function(event) &#123; msgTextFocus(); event.preventDefault();&#125;); 当做到这里我们基本要讲解的够新手去理解了，但是对于项目功能实现来说，远远不够，毕竟只是文字发送接收，那么图片、语音、地址等等高级功能呢，我们这篇文章限于篇幅不可能一一道来，只能后面再做补充。这里希望更多人参与到其中进行贡献。这里可以放出地址了，详情代码请关注这里：https://github.com/zhaomenghuan/mui-demo/tree/master/easemobIM。后期功能拓展和bug修复都贵提交到这里，欢迎大家贡献。 写在后面由于这段时间确实有点忙，这篇文章也花了很多时间去码字，去修改，改了很多次，才有这篇文章，希望能够给新手一些启示和帮助吧！本文不是着重讲环信sdk怎么用，而是讲解这个过程中可能会遇到的一些问题和实现思路，所以不建议新手直接拿最后的代码改之类的，还是看懂了思路再说，所以至于这个IM更多的功能后期会不会继续开发，暂时是未知数，所以大家不要等待，欢迎大神多多贡献分享相关代码，这样方便更多人学习使用。 这里想和大家简单说下，不要所有的问题直接私聊我，我时间精力有限，个人觉得不回复不好，所以我不会看到消息装着没看到，但是也不可能一一去回复，毕竟时间精力上也有限，我也需要不断学习，所以不希望过多的被打扰。大家有问题建议去论坛先搜搜答案，看看官方文档自己解决，大家确实有解决不了的问题，可以在群里寻求帮助或者给我发消息。提问前建议把问题描述清楚，想要实现什么，然后现在的实现思路，最好附上代码说明或者发测试文件，这样也方便解决问题。很多人说直接是直接是根据官方demo改的，说啥bug，很多时候聊到最后发现是他自己的原因，这种情况真的很浪费彼此时间。在此声明以后一上来直接要帮忙写代码的，或者让我发一遍文档地址的等等这种可以自己可以解决的问题，请原谅我直接果断拒绝，我理解新手理解小白初入门的盲目，但是建议不要去依赖，要自己去尝试，不懂再问，不要还没有去了解去查资料，直接一上来求带这种要求。 clipboard.png 如果有项目需求，欢迎私聊。承接各种前端项目，同时如果有功能定制，代码优化等需求也可以商量，算发个小广告吧，毕竟我也要生活，要挣钱娶媳妇养家糊口。 写文章不容易，也许写这些代码就几十分钟的事，写一篇大家好接受的文章或许需要几天的酝酿，然后加上几天的码字，累并快乐着。如果文章对您有帮助请我喝杯咖啡吧！进行赞助的同学私信留下你们的联系方式，后期发文章会单独邮件通知，有开发的问题也可以私聊，有相关功能需求，可以考虑优先写文分享。在此特别感谢之前给予赞助的同学，名单有保存，后期在博客会有公示。","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"html5plus","slug":"html5plus","permalink":"https://zhaomenghuan.github.io/tags/html5plus/"},{"name":"环信","slug":"环信","permalink":"https://zhaomenghuan.github.io/tags/环信/"},{"name":"im","slug":"im","permalink":"https://zhaomenghuan.github.io/tags/im/"},{"name":"页面传值","slug":"页面传值","permalink":"https://zhaomenghuan.github.io/tags/页面传值/"},{"name":"缓存","slug":"缓存","permalink":"https://zhaomenghuan.github.io/tags/缓存/"}]},{"title":"mui初级入门教程（四）—  再谈webview，从小白变“大神”！","slug":"mui初级入门教程（四）—再谈webview，从小白变“大神”！","date":"2016-06-04T16:00:00.000Z","updated":"2017-05-03T16:15:41.336Z","comments":true,"path":"2016/06/05/mui初级入门教程（四）—再谈webview，从小白变“大神”！/","link":"","permalink":"https://zhaomenghuan.github.io/2016/06/05/mui初级入门教程（四）—再谈webview，从小白变“大神”！/","excerpt":"","text":"写在前面前段时间群里某网友的问题，弹出菜单被子页面挡住了这个老生常谈的问题，其实只要明白webview常见的层级问题，这个问题很容易解释，那么解决方案自然很容易想到，如果没有理解错，html5+里面webview的创建规则是后来居上原则，所以如果想解决那个问题，有两种解决办法： 将弹出菜单放在子页面里面，然后父子页面之间传值，这种方法实用于单个子页面的情况，对于多页面可能并不方便。 第二个方法是将弹出菜单放在一个webview里面，设置为透明背景，这样就可以在保证在最上面同时可以盖住底部的内容，在android上创建菜单webview的时候设置background为&quot;transparent&quot;可以实现，但是html5+ webview .WebviewStyles中说iOS平台不支持“transparent”背景透明样式，默认背景使用白色背景。由于没有用苹果测试过，我真的信了，昨天在群里有人再次问这个问题时，我以为苹果不支持所以说这种方法存在兼容性，然而有人说可以，囧。。。被人呵呵了，实话说有点小受伤，不过也是因为自己没有测就下了结论，这样确实也不好。 可是这个问题还是会有人去问，所以想想也没什么，就把webview的其他内容再补充一下，这篇文章不会再贴文档，纯粹做实验，我们重新认识一下5+中的webview，如果对于文章中提到的一些方法不熟悉的可以看看html5+ webview 文档。 WebviewObject 对象详解今天我们先来重新认识一下webview,实践是检验真理的唯一标准，我们通过做实验来试试，其中WebviewObject对象是很特别的一个对象，我相信对于这个对象的理解，可以帮助我们理解webview的一些细节，我们就详细看看这个对象。 id属性首先谈谈WebviewObject对象的id属性，相信大家一定熟悉id选择器，id选择器是最常用的选择器之一，我们通过document.getElementById(id)就可以可返回对拥有指定 ID 的第一个对象的引用，做过android开发的一定知道findViewById通过这个方法可以得到控件对象的引用，相信5+中的plus.webview.getWebviewById(id)应该是将原生中的方法进行了封装以便于使用JavaScript调用。在打开或创建Webview窗口时设置，如果没有设置窗口标识，此属性值为当前应用的APPID，字符串类型。注意，如果是在HBuilder真机运行获取的是固定值“HBuilder”，需要提交App云端打包后运行才能获取真实的APPID值。 获取当前窗口id：12var ws=plus.webview.currentWebview();console.log( \"窗口标识: \"+ws.id ); 我们首先由id这个概念才能更加灵活管理webview，比如通过id获取对象关闭窗口:12var ws = plus.webview.getWebviewById(id);plus.webview.close(ws); 等效于：1plus.webview.getWebviewById(id).close(); 其他的方法类似，具体的可以参考文档 → 5+ webview 窗口层叠关系我们应该注意到每创建一个webview相当于在当前屏幕创建多个重叠的页面层，所以这里的层叠关系是怎么样的呢？我们不妨做一个实验：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; // H5 plus事件处理 function plusReady()&#123; var ws1=null,ws2=null,ws3=null; // 获取当前所有Webview窗口 var ws1=plus.webview.currentWebview(); console.log(\"webview\"+plus.webview.all().length+\":\"+ws1.id); setTimeout(function()&#123; ws2=plus.webview.create(\"http://weibo.com/dhnetwork\"); ws2.show(); console.log(\"webview\"+plus.webview.all().length+\":\"+ws2.id); &#125;,100); setTimeout(function()&#123; ws3=plus.webview.create(\"http://zhaomenghuan.github.io/\"); ws3.show(); console.log(\"webview\"+plus.webview.all().length+\":\"+ws3.id); &#125;,3000); setTimeout(function()&#123; ws3.close(); console.log(\"剩余窗口数量：\"+plus.webview.all().length) &#125;,6000); setTimeout(function()&#123; ws2.close(); console.log(\"剩余窗口数量：\"+plus.webview.all().length) &#125;,9000); &#125; if(window.plus)&#123; plusReady(); &#125;else&#123; document.addEventListener(\"plusready\",plusReady,false); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在控制台会打印这个：12345webview1:HBuilder at index.html:16webview2:http://weibo.com/dhnetwork at index.html:21webview3:http://zhaomenghuan.github.io/ at index.html:27剩余窗口数量：2 at index.html:32剩余窗口数量：1 at index.html:37 其实执行完这个大家就明显可以看出点结论，在层级关系上你可以认为webview是后来居上原则，我们可以通过控制webview创建销毁、显示隐藏实现页面切换。我们创建的多个webview其实是在原生android中的一个activity上，webview之间的页面切换有别于原生android中的activity间的跳转。很多人没有搞清楚webview这个后来居上原则就会乱用一些方法也会有一些搞不清楚的问题：比如： 如果父webview上的弹出菜单被子webview挡住了怎么解决？ 把mui中的openWindow()当成href`跳转使用，造成多次重复创建页面出现闪屏。 如何实现按下返回键不会退到上一个页面（常用于注册登录这一个场景的） 。。。 这里我无法一一列举，但是可以说说通用的一些东西，当我们对于html5+ webview的基本方法很熟悉了,我们可以再看看mui中的back()和openWindow()方法的实现思路，自然对于这些问题就会理解了。 那我们现在再做一个系列实验，刚刚我们是通过一层层的注销对象，而且是用的网络地址，现在我们在本地创建两个页面。 我们新建一个项目，创建一个index.html文件：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; // H5 plus事件处理 function plusReady()&#123; var ws = plus.webview.create(\"ws1.html\"); ws.show(); &#125; if(window.plus)&#123; plusReady(); &#125;else&#123; document.addEventListener(\"plusready\",plusReady,false); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 再新建ws1.html文件：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是第二个webview &lt;script type=\"text/javascript\"&gt; // H5 plus事件处理 function plusReady()&#123; setTimeout(function()&#123; var ws = plus.webview.create(\"ws2.html\"); ws.show(); &#125;,3000) &#125; if(window.plus)&#123; plusReady(); &#125;else&#123; document.addEventListener(\"plusready\",plusReady,false); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 再新建ws2.html文件：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是第三个webview &lt;script type=\"text/javascript\"&gt; function plusReady()&#123; plus.webview.getWebviewById(\"ws1.html\").close(); // 获取所有Webview窗口 var wvs=plus.webview.all(); for(var i=0;i&lt;wvs.length;i++)&#123; console.log(\"webview\"+i+\": \"+wvs[i].id); &#125; for(var i=0;i&lt;wvs.length;i++)&#123; console.log(\"webview\"+i+\": \"+wvs[i].opener()); &#125; &#125; if(window.plus)&#123; plusReady(); &#125;else&#123; document.addEventListener(\"plusready\",plusReady,false); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果：1234webview0: HBuilder at ws2.html:16webview1: ws2.html at ws2.html:16webview0: undefined at ws2.html:19webview1: null at ws2.html:19 我们在第三个webview里面通过id把第二个webview正常关闭了，这说明我们的webview是可以控制的，通过plus.webview.all()方法可以获取当前所有的webview对象，发现被关闭的webview被销毁了。 这里我们需要说明的是被我们关闭的webview，我们无法通过opener()获取当前Webview窗口的创建者，返回值为null，这有别于undefined。 有个问题我们一直都没有去探索，就是这些webview对象之间有没有什么关系呢？我们在第二篇说到了父子webview，那么这里的几个webview之间是不是父子结构呢，我们不妨试试看，我们通过WebviewObject的parent()获取父窗口，这里我们把ws2.html中修改如下：123for(var i=0;i&lt;wvs.length;i++)&#123; console.log(\"webview\"+i+\": \"+wvs[i].parent());&#125; 结果如下：12webview0: undefined at ws2.html:16webview1: undefined at ws2.html:16 这说明我们创建的这几个对象是平行关系，不存在父子关系，文档中提到：Webview窗口作为子窗口添加（Webview.append）到其它Webview窗口中时有效，这时其它Webview窗口为父窗口。 那我们将第三个webview填充到第二个webview中试试，我们将ws1.html修改如下：1234function plusReady()&#123; var ws = plus.webview.create(\"ws2.html\",\"\",&#123;top:\"46px\",bottom:\"0px\"&#125;); plus.webview.currentWebview().append(ws);&#125; ws2.html修改如下： 1234567function plusReady()&#123; // 获取所有Webview窗口 var wvs=plus.webview.all(); for(var i=0;i&lt;wvs.length;i++)&#123; console.log(\"webview\"+i+\": \"+wvs[i].parent()); &#125;&#125; 输入如下：123webview0: undefined at ws2.html:16webview1: undefined at ws2.html:16webview2: [object Object] at ws2.html:16 很明显我们发现第三个webview具有父对象，这里也说明了父子对象的应用场景，将另一个Webview窗口作为子窗口添加到当前Webview窗口中，添加后其所有权归父Webview窗口，父窗口显示时子窗口会自动显示，父窗口隐藏时子窗口自动隐藏，当父窗口关闭时子窗口也自动关闭。 我们不妨在子webview关闭父webview试试，结果发现子webview也被关闭了，如果不对子webview进行close()方法操作，可知子webview的生命周期是由父webview决定的。我们可以通过对子webview进行show()、hide()操作，甚至可以使用remove移除子Webview窗口，从而实现动态子webview。这种场景最常用的是webview选项卡。 页面历史记录操作很多人有将wap站点打包成APP需求，官方也提供了一些教程，只是很多人没有搞清楚思路，没有明白改造的基本方法，其中有个最常见的问题是如何通过返回键控制网页内容的回退，论坛上有些回答说通过setJsFile引入mui.js，然后重写mui.back()，其实这个回答本来没有错，但是这个答案依然会有很多细节问题，说直接就是mui.back()怎么去重写的问题，在搞懂这些问题之前我们不妨看看我们html5+有什么解决办法，由于mui并没有给出前端路由的相关解决方法，使用前端技术写app，总觉得在页面管理上会有点混乱，前几天一直在构思基于html5+和mui的前端路由解决方案。感觉这个问题如果深入探究需要另开篇再谈，这里先给出一个最简单的将一个网址打包成app的方案，这个在应用商店估计是通不过的，只是一个基本思路，大家需要的可以拿去看看。 可以通过plus.key.addEventListener来注册监听返回按键backbutton事件：123plus.key.addEventListener(\"backbutton\",function()&#123; alert( \"BackButton Key pressed!\" );&#125;); 通过WebviewObject对象的canBack和canForward方法可以查询Webview窗口的状态，通过back和forward控制页面加载。 canBack: 查询Webview窗口是否可后退 canForward: 查询Webview窗口是否可前进 back: 后退到上次加载的页面 forward: 前进到上次加载的页面 clear清除原生窗口的内容，用于重置原生窗口加载的内容，清除其加载的历史记录等内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; var ws=null,nw=null; function plusReady()&#123; ws=plus.webview.currentWebview(); nw=plus.webview.create(\"http://weibo.com/dhnetwork\"); ws.append(nw); plus.key.addEventListener(\"backbutton\",function()&#123; //查询Webview窗口是否可后退 nw.canBack( function(e)&#123; var canback=e.canBack; if(canback)&#123; nw.back(); &#125;else&#123; back(); &#125; &#125;); &#125;); &#125; var first = null; var back = function() &#123; if (!first) &#123; first = (new Date()).getTime(); plus.nativeUI.toast('再按一次退出应用'); setTimeout(function() &#123; first = null; &#125;, 1000); &#125; else &#123; if ((new Date()).getTime() - first &lt; 1000) &#123; plus.runtime.quit(); &#125; &#125; &#125; if(window.plus)&#123; plusReady(); &#125;else&#123; document.addEventListener(\"plusready\",plusReady,false); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果是使用mui,我们可以这样写：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"js/mui.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; mui.init(); var ws=null,nw=null; mui.plusReady(function () &#123; ws=plus.webview.currentWebview(); nw=plus.webview.create(\"https://www.baidu.com/\"); ws.append(nw); &#125;); var _back = mui.back; mui.back = function()&#123; //查询Webview窗口是否可后退 nw.canBack( function(e)&#123; var canback=e.canBack; if(canback)&#123; nw.back(); &#125;else&#123; _back(); &#125; &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当然WebviewObject对象的内容不止这些，这里我只列举了其中大家容易出问题的一些内容，详细的讲解再后面的其他模块的讲解中会再做补充，大家也可以自己学习。 WebviewStyles对象举例WebviewStyles是JSON对象，原生窗口设置参数的对象，设置方法有两种： 在plus.webview.create()或者plus.webview.open()中作为参数设置，如： 12345plus.webview.create(url,id,&#123; top: '0px', bottom: '0px', mask: 'rgba(0,0,0,0.5)'&#125;) 使用setStyle()动态设置，如： 123var ws=plus.webview.currentWebview();// 显示遮罩层ws.setStyle(&#123;mask:\"rgba(0,0,0,0.5)\"&#125;); WebviewStyles常用属性 zindex: (Number 类型 )窗口的堆叠顺序值拥有更高堆叠顺序的窗口总是会处于堆叠顺序较低的窗口的上面，拥有相同堆叠顺序的窗口后调用show方法则在前面。 设置方法如：123&#123; zindex: 999&#125; 前面我们讲到了webview的层叠关系是后来居上原则，有一个前提是默认层级，没有使用zindex改变默认的层级关系值，大家知道在web中我们使用z-index可以改变控件的层叠关系，说直观点就好是可以定义有重叠的两个部分，谁在上面谁在下面的问题。 那么在必要的时候我们可以使用这个WebviewStyles的zindex属性去改变层叠关系。 {% image https://segmentfault.com/img/bVxSjN 'clipboard.png' '' %} 如上图这种情况，我们的底部菜单中间有个突出的部分，如果直接用我们之前将到的那个方法，我们知道要么是那个突起的一小块被挡住了，要么是中间的内容与底部非得保持一定的距离，这就尴尬了，而且目前官方的demo没有给这种特殊的需求，那么是不是不能自己做呢？ 肯定不是的，不然html5plus也不至于要做为一个标准去提，肯定是有通用方法解决不同的个性化需求的。 我们很好想到的就是在上次的基础上进行改进就可以满足这个需求：我们首先思考一个问题，我们是将父webview的堆叠顺序改成比子页高还是说将tabbar作为一个层独立出来呢？ 首先我们思考一下简单粗暴的提高父webview会怎么样？首先我们会发现子webview会被父webview盖住，有人可能会说把父webview搞成透明的，OK，那么问题来了怎么设置透明呢？ background: (String 类型 )窗口的背景颜色窗口空白区域的背景模式，设置background为颜色值(参考CSS Color Names，可取值/十六进制值/rgb值/rgba值)，窗口为独占模式显示（占整个屏幕区域）； 设置background为“transparent”，则表示窗口背景透明，为非独占模式。 设置方法如：123&#123; background: 'transparent'&#125; 这个就是我开篇说到的那个问题，当时犯了错误，误以为ios不支持，后来得到果汁的确认后来支持了，文档没有更新而已。 虽然我们可以通过设置父webview透明不至于看不到子页面，但是有个更严重的问题就是子webview被盖住了我们不能操作，这是多么的坑，所以这个方法走不通。我们想一下把tabbar抽离出来作为一个子webview,只要设置tabbar的范围，也就是说不全屏幕铺开，设置高度属性限制高度，设置bottom将tabbar固定在底部，然后设置tabbar的zindex属性比其他子webview高就ok了。1234567891011121314151617// 子页参数var Index = 0;var subpages = ['html/home.html','html/message.html','html/find.html','html/setting.html'];var subpage_style = &#123; top: '45px', bottom: '50px', zindex:99&#125;;// 底部导航栏var tabbar = \"html/tabbar.html\";var tabbar_style = &#123; height:\"60px\", bottom:\"0px\", background: \"transparent\", zindex:999&#125; 我们只需要给tabbar设置background和zindex就可以实现上面那个图那种效果，但是也因此带了一个问题就是，我们之前点击底部栏直接就可以获取相关的参数进行切换，但是我们现在把tabbar单独拿出来了，那么久涉及一个父子webview通信的问题，我们前面一篇文章讲到页面初始化时候通过扩展参数extras传值，这里我们需要用到自定义事件，通过自定义事件，用户可以轻松实现多webview间数据传递。 我们这里先贴出tabbar的局部代码便于讲解，大家可以在【mui demo】仓库下载完整代码，或者在这里c查看【预览效果】。 在此感谢群友们提出demo中的bug，就是在苹果手机中切换tabbar，tabbar依然会被挡住的问题，开篇讲到由于本人没有苹果手机，所以demo难免在苹果手机上有一些小问题，但是问题还是可以解决的，其实看了文章多思考一下自己没啥问题的，不建议新手直接一上来来demo，不然出现小问题自己都不知道什么原因，那么这篇文章也没啥意义。再来说说群友提的问题，我觉得有两种可能性，没有用苹果做实验测试，只是猜想：1.zindex在ios无效；2.优先级的问题，可能是选项卡切换过程执行show方法，我们前面说到后来居上原则，这个时候zindx的层级关系优先级低于后来居上原则。大家可以去实验验证，这里无法给出肯定答案。不过解决思路，我觉得可以试试两种：1.在子页面show后马上用setStyle设置zindex；2.直接在子页面show后重新执行tabbar show方法。 tabbar.htmlhtml部分：123456789101112131415161718192021&lt;nav class=\"mui-bar mui-bar-tab mui-botton-bar\"&gt; &lt;a class=\"mui-tab-item mui-active\" href=\"html/home.html\"&gt; &lt;img class=\"mui-icon\" src=\"../img/i-home-active.png\"/&gt; &lt;span class=\"mui-tab-label\"&gt;首页&lt;/span&gt; &lt;/a&gt; &lt;a class=\"mui-tab-item\" href=\"html/message.html\"&gt; &lt;img class=\"mui-icon\" src=\"../img/i-star.png\"/&gt; &lt;span class=\"mui-tab-label\"&gt;消息&lt;/span&gt; &lt;/a&gt; &lt;a class=\"mui-tabbar-center\" href=\"popover.html\"&gt; &lt;img src=\"../img/i-pop-active.png\"/&gt; &lt;/a&gt; &lt;a class=\"mui-tab-item\" href=\"html/find.html\"&gt; &lt;img class=\"mui-icon\" src=\"../img/i-find.png\"/&gt; &lt;span class=\"mui-tab-label\"&gt;发现&lt;/span&gt; &lt;/a&gt; &lt;a class=\"mui-tab-item\" href=\"html/setting.html\"&gt; &lt;img class=\"mui-icon\" src=\"../img/i-person.png\"/&gt; &lt;span class=\"mui-tab-label\"&gt;个人&lt;/span&gt; &lt;/a&gt;&lt;/nav&gt; js部分：1234567891011121314151617181920212223242526272829303132333435363738394041//选项卡点击事件mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; // 获取当前点击的选项 var targetTab = this.getAttribute('href'); // 如果点击中间的菜单栏弹出菜单 if(targetTab == popTab)&#123; // 创建mask遮罩 plus.webview.create(\"\",\"mask\",&#123; mask:\"rgba(0,0,0,0.4)\", background: \"transparent\" &#125;).show(); // 打开弹出层 plus.webview.show(popWebview,\"slide-in-bottom\",300); return; &#125; //当前选项值传到父webview var currWs = plus.webview.currentWebview(); var targetTitle = this.querySelector('.mui-tab-label').innerHTML; //触发详情页面的newsId事件 mui.fire(currWs.parent(),'targetTab',&#123; targetTitle:targetTitle, targetTab:targetTab &#125;); /** * 下面这部分非每个项目必须的，因为这里为了给 * 大家演示怎么用图片作为图标而不用字体图标。 */ // 获取图标对象 var targetIcon=mui(this.children[0])[0]; //初始化 mui('.mui-bar-tab .mui-tab-item img').each(function (index,item) &#123; var itemSrc = item.getAttribute('src'); if(itemSrc.indexOf('active'))&#123; item.src = itemSrc.replace('-active.png','.png'); &#125; &#125;); //设置当前的图标 targetIcon.src = targetIcon.getAttribute('src').replace('.png','-active.png'); &#125;); 这里我们使用了图片而不是图标，因为考虑有些项目可能设计比较个性化，我们不一定可以在Iconfont-阿里巴巴矢量图标库上找到合适的图，有时候用字体文件有局限性，所以这个例子里面我们使用了图片演示。 这个地方需要对几个细节特别说说： mui.fire()触发自定义事件按照文档的说明我们知道有三个参数：（不知道文档在哪里的请戳这里【文档】） mui.fire( target , event , data ) target为你要传入数据的那个webview，我们这里是要出入到父webview，由于我们没有给父webview指定id，我们前面知道这样就不方便拿到父webview对象，这里就使用当前webview的parent()间接获取。event是你可以指定的自定义事件名称。data是你要传入的数据，为json格式 (不知道json为何物的同学请戳我上一篇文章mui初级入门教程（三）— html5+ XMLHttpRequest 与mui ajax用法详解) 。 我们获取数据也很简单：1234567// 添加targetTab自定义事件监听window.addEventListener('targetTab',function(event)&#123; // 获得选项卡点击事件参数 var targetTitle = event.detail.targetTitle; var targetTab = event.detail.targetTab; //接下来这里拿到数据后写逻辑代码了...&#125;); 不过这里有一个特别需要注意的问题，由于我还没有遇到，但是看官网文档有说明，贴出来方便后来遇到这个问题的同学： 目标webview必须触发loaded事件后才能使用自定义事件若新创建一个webview，不等该webview的loaded事件发生，就立即使用webview.evalJS()或mui.fire(webview,’eventName’,{})，则可能无效；案例参考：这里 mui对象和DOM对象的区别之所以说说这个是因为在写那个用图片代码字体图标的时候出现一个问题就是选中当前选项，选项卡图片要换成对应激活状态的图片。那么问题来了，怎么拿到a标签下的img标签对象,如果用过jQuery,我们知道直接用下面的代码就可以实现：1$('.mui-bar-tab a').children(\"img\").css(\"src\",\"xxx-active.png\"); 然而mui本着极简的原则没有children和css方法，那么我们只考虑用原生js操作DOM。这里推荐大家用mui和原生js实现，毕竟就那么一点代码引入一个库不值得，也不利于提高自身的水平。那么我们这里就补一下基础知识，考虑到每个人基础不同，这里尽可能精简的说一下。 HTML DOM 基础什么是 DOM?DOM ，全称Document Object Model（文档对象模型），是 W3C（万维网联盟）的标准。DOM 定义了访问 HTML 和 XML 文档的标准： “W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。” W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 什么是 HTML DOM？HTML DOM 是HTML 的标准对象模型和标准编程接口，W3C 标准。HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。 HTML DOM 节点树HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树：{% image http://www.w3school.com.cn/i/ct_htmltree.gif '' '' %}节点父、子和同胞：节点树中的节点彼此拥有层级关系。父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。 HTML DOM 属性属性是节点（HTML 元素）的值，您能够获取或设置。可通过 JavaScript （以及其他编程语言）对 HTML DOM 进行访问。 1.innerHTML 属性：获取元素内容的最简单方法是使用 innerHTML 属性。innerHTML 属性对于获取或替换 HTML 元素的内容很有用。 2.nodeName 属性：nodeName 属性规定节点的名称，是只读的，nodeName 始终包含 HTML 元素的大写字母标签名。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text 文档节点的 nodeName 始终是 #document 3.nodeValue 属性：nodeValue 属性规定节点的值。 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 4.nodeType 属性：nodeType 属性返回节点的类型， 是只读的。比较重要的节点类型有：| 元素类型 | NodeType || :——–: | :——–:|| 元素 | 1 || 属性 | 2 || 文本 | 3 || 注释 | 8 || 文档 | 9 | 5.childNodes属性与children属性childNodes 属性返回包含被选节点的子节点的 NodeList。如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。childNodes包含的不仅仅只有html节点，所有属性，文本、注释等节点都包含在childNodes里面。children只返回元素如input, span, script, div等，不会返回TextNode，注释。 HTML DOM方法通常使用的最多的就是 Document和 window 对象。简单的说, window 对象表示浏览器中的内容，而 document 对象是文档本身的根节点。Element 继承了通用的 Node 接口, 将这两个接口结合后就提供了许多方法和属性可以供单个元素使用。在处理这些元素所对应的不同类型的数据时，这些元素可能会有专用的接口。下面是在web和XML页面脚本中使用DOM时，一些常用的方法: 方法 描述 getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 appendChild() 把新的子节点添加到指定节点。 removeChild() 删除子节点。 replaceChild() 替换子节点。 insertBefore() 在指定的子节点前面插入新的子节点。 createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 getAttribute() 返回指定的属性值。 setAttribute() 把指定属性设置或修改为指定的值。 具体更详细的大家可以参考这篇文章JavaScript DOM——“节点层次”的注意要点 mui对象和dom对象的具体区别我们上面讲了一下DOM对象的基本属性和方法，限于篇幅，只是简单说了说，如果说连上面的都不知道的就需要查一下咯，当然DOM历史悠久，肯定不止这么多内容，对于新手来说熟悉常用的DOM是很有必要的，我自己在这方面目前就做得不够好，后期还会继续深入学习。 首先我们得说mui对象和dom对象都我们是两个对象，都有自己的独有的属性和方法，如果一个对象调用了一个自己没有另外一个对象有的属性和方法，肯定会报错的。这里我们先举个小例子：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"../js/mui.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;button type=\"button\" id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; // dom对象实现 var btn = document.getElementById(\"btn\"); btn.addEventListener('click',function()&#123; console.log(\"用dom对象获取button元素点击了按钮\") &#125;); // mui对象实现 mui(\"#btn\")[0].addEventListener('click',function()&#123; console.log(\"用mui对象获取button元素点击了按钮\") &#125;); //判断这两个方法是否等同 console.log(document.getElementById(\"btn\")===mui(\"#btn\")[0]) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 经常容易犯错的一个就是下面的使用方法：123mui(\"#btn\").addEventListener('click',function()&#123; console.log(\"用mui对象获取button元素点击了按钮\")&#125;); 我们通过mui(&quot;#btn&quot;)获取的是一个mui对象实例，然而mui对象没有addEventListener，就会报错，我们用jQuery也会出现这种问题，然而jQuery中on方法很常用，不会想那么多，但是mui中的on方法实现批量元素的事件绑定，非得传入第二个参数，和我们的需求有时候不相符合，mui推荐我们直接使用addEventListener方法，然而这个是dom对象的方法，我们又不想用document.getElementById(&quot;btn&quot;)这种一长串的方法怎么办呢？我们可以考虑将mui对象转成dom对象，方法是：mui对象mui(&quot;#btn&quot;)转成dom对象为mui(“#btn”)[0]，我们后面也会陆续讲到怎么自己封装一些常用的dom对象操作方法。 我们接下来说说mui对象中的on()中的this指向和父子节点问题：123mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; console.log(this.innerHTML)&#125;) 我们这里执行这个会发现这里的this指向的是当前点击的a标签。 我们如果想获取子节点，我们前面提到了有两个方法：childNodes和children,我们可以用下面的方面遍历：123456789mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; for(var i=0;i&lt;this.childNodes.length;i++)&#123; console.log(\"childNodes:\"+this.childNodes[i]); &#125; for(var i=0;i&lt;this.children.length;i++)&#123; console.log(\"children:\"+this.children[i]) &#125;&#125;) 结果：1234567childNodes:[object Text] at html/tabbar.html:85childNodes:[object HTMLImageElement] at html/tabbar.html:85childNodes:[object Text] at html/tabbar.html:85childNodes:[object HTMLSpanElement] at html/tabbar.html:85childNodes:[object Text] at html/tabbar.html:85children:[object HTMLImageElement] at html/tabbar.html:89children:[object HTMLSpanElement] at html/tabbar.html:89 我们会发现使用childNodes会有[object Text]，我们这里的其实是因为我们上面的HTML结构中有回车和空格的原因，去掉后会发现和children结果一致。 注：Internet Explorer 下使用childNodes会忽略节点之间生成的空白文本节点（比如换行字符）。 为了简单我们通常使用children，比如上面的例子我们用到了1var targetIcon=mui(this.children[0])[0]; 这样我们就拿到了HTMLImageElement对象，我们通过getAttribute(&#39;src&#39;)方法就可以拿到src属性。 其实写到这里我们发现只要掌握了原生js操作DOM的方法，我们其实可以不过度依赖jQuery这种库，当然jQuery也不仅仅只是这么多内容，很多封装的思路值得我们去学习，小白学习前端的路很长，但是一定要脚踏实地去落实，不要急于求成。 项目实战之父子页面弹出层这一篇文章本来上次就应该完成的，但是一直拖了很久，一来是因为时间久了，这么问题感觉也不想继续写，毕竟写文章要花时间，但是又有强迫症，想想还是完善一下，详不详细都不要紧，但是要把主要的内容写出来就可以。 先看效果图： {% image https://segmentfault.com/img/bVysZ7 'clipboard.png' '' %} 就是前面我们点击中间那个选项弹出的一个菜单，很显然这个问题具有一定的代表性。做过类似需求的朋友肯定知道问题所在，我们把弹出菜单如果放在父webview，那么在这种情况下会被子webview盖住，当然我们可以考虑在点击弹出层时候动态设置父页面的层级比子页面高，然后关闭再设置恢复，但是这个过程很麻烦，不是最佳实战方法，在子webview的话，那么设计父子webview通信的问题，对于这种多子webview页面的情况是不是过于麻烦呢，这种时候我们用新建一个webview装弹出层我觉得是一种最合适的方案。 知道思路了，方案实施很简单的，其实就是当我们点击那个弹出层的时候，然后显示webview，当关闭的时候隐藏或者关闭webview。打开时候的关键代码如下： 123456789101112131415161718192021222324252627282930313233//弹出菜单var menuWebview;var menuTab = 'menu.html';mui.plusReady(function()&#123; //预加载弹出菜单子页面 menuWebview = mui.preload(&#123; url:menuTab, id:menuTab, styles:&#123; top: '0px', bottom: '0px', background: 'transparent' &#125; &#125;);&#125;)//...此处略去若干代码// 如果点击中间的菜单栏弹出菜单if(targetTab == menuTab)&#123; if(window.plus)&#123; // 创建mask遮罩 plus.webview.create(\"\",\"mask\",&#123; mask:\"rgba(0,0,0,0.4)\", background: \"transparent\" &#125;).show(); // 打开弹出层 plus.webview.show(menuWebview,\"slide-in-bottom\",300); &#125;else&#123; mui.alert(\"请在html5+引擎环境使用\"); &#125; return;&#125; 我们这里做了一些特别的处理，我们设置弹出层webview中的background: &#39;transparent&#39;，以及弹出层页面的body{background: transparent;}是为了得到一个透明的弹出层，如果不需要可以忽略，同时可以可以通过设置top和bottom设置弹出层的范围，这些具体配置参数在上面的内容中都有讲解，具体的大家可以详细看看。另外考虑到有人需要遮罩这种布局，我们专门新建了一个webview创建mask遮罩，具体的参数类似。 至于关闭弹出层也很简单，我们在弹出层的页面重写mui.back()方法。12345678910/* * 这里重写mui.back()方法，在需要执行关闭命令的地方 * 加上 mui-action-back 类，可以绑定back()方法。*/mui.back = function()&#123; // 隐藏弹出层 plus.webview.currentWebview().hide(); // 关闭遮罩 plus.webview.getWebviewById('mask').close();&#125; 至此我们这个弹出层是算完美解决了。 另外很多人总是尝试去关闭webview，其实webview开着的时候真正的占多少内存呢，你打开浏览器就知道，不会说你开了几页面就被卡死了，当然暴力操作和页面内面阻塞错误除外，不过一般浏览器也好像限制了页面打开的数量，我手机自带的浏览器是最多可以打开15个窗口。所以我们尽量不要开启过多的webview，能够使用单页去代替的可以考虑单页。这里有个div模式的tabbar切换动画：【demo传送门】。另外webview不建议都关闭，如果后面会用到的webview可以用hide()代替，同时即使要关闭，也不适宜一次性关闭，经常看到有人用all查找当前的webview，用循环一次性关闭，造成内存溢出。我首先不想说底层的原理实现，就想用常识想想，你打开webview的时候需要执行操作，那么关闭的时候就不执行操作吗？你同时一下子做那么多事，手机浏览器是不是都被你占用了执行关闭操作，那么这个过程难道不需要内存消耗吗？你根据id分时去close自然会好得多，有时候我们出现问题先考虑一下是不是自己的方式不对。 写在后面其实回过头来再看看其实内容并不算多，也不是很复杂，为啥依然有那么多抱怨呢，说来说去不按套路出牌，很多人用mui完全但是不按mui的思路，想当然的去做，开发前文档都不看，出问题了也不懂原因，其实有时候再喷的时候能不能把那个时间拿来看看文档再说。我一向主张是做事前先花时间去搞清楚一些基本规则，花时间去学习，然后再去做事就不会花很多冤枉时间；但是我常常看到的是很多人花很少的时间学习，然后花很多时间去填坑。这种情况通常时间也花了不少，但是没有什么长进，更谈不上深刻理解。（完全个人意见，不满可以忽略） 【MUI从入门到精通】专栏地址：https://segmentfault.com/blog/mui mui demo地址：https://github.com/zhaomenghuan/mui-demo 写文章不容易，也许写这些代码就几分钟的事，写一篇大家好接受的文章或许需要几天的酝酿，然后加上几天的码字，累并快乐着。如果文章对您有帮助请我喝杯咖啡吧！","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"html5plus","slug":"html5plus","permalink":"https://zhaomenghuan.github.io/tags/html5plus/"},{"name":"webview","slug":"webview","permalink":"https://zhaomenghuan.github.io/tags/webview/"}]},{"title":"mui初级入门教程（三）— html5+ XMLHttpRequest 与mui ajax用法详解","slug":"mui初级入门教程（三）—html5+ XMLHttpRequest 与mui ajax用法详解","date":"2016-05-28T16:00:00.000Z","updated":"2017-05-03T16:15:23.500Z","comments":true,"path":"2016/05/29/mui初级入门教程（三）—html5+ XMLHttpRequest 与mui ajax用法详解/","link":"","permalink":"https://zhaomenghuan.github.io/2016/05/29/mui初级入门教程（三）—html5+ XMLHttpRequest 与mui ajax用法详解/","excerpt":"","text":"写在前面这是这个系列的的第三篇文章，前面的文章在多个地方（本人github博客、dcloud ask社区、segmentfault）发出来了，很多朋友收藏点赞，只是没有多少人反映内容的深浅，也没有人提出意见，所以实话说不知道符不符合大家胃口，不过我写博客一向以详细为标准，尽可能照顾到各种人群，特别是入门级的同学，力求还原我学习这个东西的一个思路和过程，在文章中也分享一些不错的干货，最近在折腾博客，用webpack和vue-cli打包了一下，目前还有些问题有待解决，自己尝试写一个markdown编辑器因为bug过多的问题，然后开始使用马克飞象写博客，毕竟生成的界面美观多了，这样可以方便大家阅读吧。废话不多说，开始我们今天的内容，今天主要是学习一下html5+的XMLHttpRequest以及mui的基本用法。 基础铺垫Javascript XMLHttpRequest网络请求 XMLHttpRequest 是一个 JavaScript 对象，它最初由微软设计,随后被 Mozilla、Apple 和 Google采纳. 如今,该对象已经被 W3C组织标准化. 通过它,你可以很容易的取回一个URL上的资源数据. 尽管名字里有XML, 但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于XML。 而且除了HTTP ,它还支持file 和 ftp 协议. —— MDN XMLHttpRequest XMLHttpRequest 让发送一个HTTP请求变得非常容易。你只需要简单的创建一个请求对象实例，打开一个URL，然后发送这个请求。当传输完毕后，结果的HTTP状态以及返回的响应内容也可以从请求对象中获取。 XMLHttpRequest网络请求的一般步骤：第一步：创建一个 XMLHttpRequest 实例1new XMLHttpRequest(); 第二步：初始化HTTP请求参数1234567void open( DOMString method, DOMString url, optional boolean async, optional DOMString user, optional DOMString password); method：请求所使用的HTTP方法; 例如 &quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;等. 如果下个参数是非HTTP(S)的URL,则忽略该参数. url：该请求所要访问的URL async：一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart属性是true，否则将会出现一个意外。 user：用户名,可选参数,为授权使用;默认参数为空string. password：密码,可选参数,为授权使用;默认参数为空string. 第三步：发送请求1send(); 发送请求. 如果该请求是异步模式(默认),该方法会立刻返回. 相反,如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回. 如下例：123456789var xhr = new XMLHttpRequest();xhr.onload = function () &#123; console.log(this.responseText);&#125;;xhr.onreadystatechange = function() &#123; console.log(this.readyState);&#125;;xhr.open(\"get\", \"https://www.baidu.com\", true);xhr.send(); 我们在hbuilder里面打开，控制台会报错：1[Web浏览器] &quot;XMLHttpRequest cannot load https://www.baidu.com/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://127.0.0.1:8020&apos; is therefore not allowed access.&quot; 用浏览器打开，按F12在控制台console下查看也会发现上述错误，这是为啥呢？ 这是因为普通网页能够使用XMLHttpRequest对象发送或者接受服务器数据, 但是它们受限于同源策略。只要先获取了跨域请求许可，就可以进行跨域请求。 同源策略：如果两个页面的协议、域名和端口是完全相同的，那么它们就是同源的。同源策略是为了防止从一个地址加载的文档或脚本访问或者设置从另外一个地址加载的文档的属性。如果两个页面的主域名相同，则还可以通过设置 document.domain属性将它们认为是同源的。 {% image https://segmentfault.com/img/bVxCld 'clipboard.png' '' %} 跨域请求的几种常用方法CORS，使用XMLHttpRequest对象CORS 的全称是 Cross-Origin Resource Sharing，即跨域资源共享。他的原理就是使用自定义的 HTTP 头部，让服务器与浏览器进行沟通，主要是通过设置响应头的 Access-Control-Allow-Origin 来达到目的的。这样，XMLHttpRequest 就能跨域了。想要进一步了解CORS的朋友可以看看这篇文章：了解跨域资源共享 (CORS) 在服务器端添加响应头Access-Control-Allow-Origin，使用XMLHttpRequest对象请求。值得注意的是，正常情况下的 XMLHttpRequest 是只发送一次请求的，但是跨域问题下很可能是会发送两次的请求（预发送）。 PHP:1header('Access-Control-Allow-Origin: *'); java:1response.addHeader( \"Access-Control-Allow-Origin\", \"*\" ); 大家不妨将上面那个例子中的地址换成这个试试：http://zhaomenghuan.github.io/api/blog.json（仅用于学习测试，禁止直接用于任何不经征求本人同意的站点）123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; var xhr = new XMLHttpRequest(); xhr.open(\"get\", \"http://zhaomenghuan.github.io/api/blog.json\", true); xhr.onload = function () &#123; console.log(this.responseText); var data = JSON.parse(this.responseText); for(var i in data)&#123; document.write(data[i].pageId + '：' + data[i].title+\"&lt;br /&gt;\") &#125; &#125;; xhr.onerror = function () &#123; alert('error making the request.'); &#125;; xhr.send(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 哈哈，执行完这段代码你会发现，你能够查看到我博客的列表，所以大家是不是懂了些什么， CORS能否跨域实现需要服务器端支持，我们这里能够收到信息，是因为github上的资源是支持CORS访问的，这和框架无关，很多人以为用了框架就可以跨域，这都是不正确的理解，框架只是封装了一些方法，让我们使用更加方便，能不能跨域还是取决于我们服务器端的访问权限。这里顺便说一下很多人用mui会发现在浏览器端会报错，在app环境能够访问，这是因为mui依赖html5+ XMLHttpRequest网络请求模块，后面会详细讲到。 Jsonp，只适用于get请求Jsonp的跨域不是用XMLHttpRequest实现的，而是一个script标签，script是可以跨域的，回调函数作为get参数传入请求里。 原理很简单，比如你在A域名请求B域名： 在A域名的页面中使用script标签src写成B域名中服务器的URLscript标签是可以跨域的，比如你调用Google Map或Google Analytics时引入的js就是google域名下的。 后端程序在最后需要把一段js代码的字符串打印出来，这样就可以运行A域名js中写好的callback方法，将要返回的数据放入参数就可以了 A域名中的js文件：12345678910111213141516function CreateScript(src)&#123; var el = document.createElement('script'); el.src = src; el.async = true; el.defer = true; document.body.appendChild(el);&#125;// 响应的方法function jsonpcallback(rs) &#123; console.log(JSON.stringify(rs)); document.getElementById(\"output\").innerHTML = JSON.stringify(rs);&#125; // 发起get请求CreateScript('http://127.0.0.1:8888?userid=001&amp;callback=jsonpcallback'); B域名中node服务器：1234567891011121314151617181920212223242526var http = require('http'); var url = require('url'); var data = &#123; 'name': 'zhaomenghuan', 'age': '22'&#125;; http.createServer(function(req, res)&#123; // 将url字符串转换成Url对象 var params = url.parse(req.url, true); console.log(params); // 查询参数 if(params.query)&#123; // 根据附件条件查询 if(params.query.userid === '001')&#123; // 判断是否为jsonp方式请求，若是则使用jsonp方式，否则为普通web方式 if (params.query.callback) &#123; var resurlt = params.query.callback + '(' + JSON.stringify(data) + ')'; res.end(resurlt); &#125; else &#123; res.end(JSON.stringify(data)); &#125; &#125; &#125; &#125;).listen(8888); 这样我们就可以在A域名下跨域请求，当然我们经常看到很多框架如jquery对jsonp进行了进一步封装，但是基本原理同上面。这里给出两个例子： native-JavaScript实现 mui-jsonp实现 总之，不论是XMLHttpRequest的跨域，还是Jsonp，都是需要请求的网站服务器端提供支持，在愿意分享给你数据的情况下你才能得到。在对方没有提供支持的情况下，你是取不到它的数据的。当然跨域的解决方案有很多种，由于本人没有实践过，没有实践就没有发言权，这里给大家贴一个帖子，自己跨域自行验证，浅谈浏览器端JavaScript跨域解决方法。 html5+ XMLHttpRequest网络请求上面我们花了很大篇幅讲解了JavaScript XMLHttpRequest对象，而且也简单的讲解了同源策略和跨域请求的常用方法，我们注意到无论是JavaScript XMLHttpRequest还是jsonp都需要通过服务器端的支持才能实现跨域，另外还有几种也有一定的局限性，所以总还是让人觉得美中不足。html5+提供了一个XMLHttpRequest模块，在APP端很完美的解决了这种问题，而且提供了和JavaScript XMLHttpRequest对象用法类似的一系列属性方法。由于本文的重在在于讲解html5+ XMLHttpRequest,所以前面的JavaScript XMLHttpRequest相关的属性方法只是初略介绍了一下，下面重点介绍html5+ XMLHttpRequest模块。 适用范围：由于html5+ XMLHttpRequest是一种拓展方案，所以需要底层支持，基于html5+ XMLHttpRequest的方法不能用于非5+环境，如果对这些概念不清楚的欢迎先阅读我之前写的文章mui初级入门教程（一）— 菜鸟入手mui的学习路线。 我们用hbuilder新建一个app工程，然后运行下面的代码：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; document.addEventListener('plusready', function()&#123; var xhr = new plus.net.XMLHttpRequest(); xhr.onreadystatechange = function () &#123; switch ( xhr.readyState ) &#123; case 0: console.log( \"xhr请求已初始化\" ); break; case 1: console.log( \"xhr请求已打开\" ); break; case 2: console.log( \"xhr请求已发送\" ); break; case 3: console.log( \"xhr请求已响应\"); break; case 4: if ( xhr.status == 200 ) &#123; alert( \"xhr请求成功：\"+xhr.responseText ); &#125; else &#123; console.log( \"xhr请求失败：\"+xhr.readyState ); &#125; break; default : break; &#125; &#125; xhr.open(\"GET\", \"https://www.baidu.com/\"); xhr.send(); &#125;, false ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们会发现最后弹出了弹框，里面写有百度首页的代码。 5+ XMLHttpRequest对象创建一个XMLHttpRequest 对象，对象创建时不触发任何时间和网络请求，需和open，send方法配合使用。123var xhr = new plus.net.XMLHttpRequest();xhr.open(method, url);xhr.send(); XMLHttpRequest的属性： readyState: HTTP 请求的状态 response: 请求从服务器接收到的响应数据 responseText: 请求从服务器接收到的响应数据（字符串数据） responseType:请求响应数据response的类型 responseXML: 请求响应的Document对象 status: 服务器返回的HTTP状态代码 statusText: 服务器返回的HTTP状态描述 timeout: 请求服务器的超时时间，单位为毫秒（ms） withCredentials: 是否支持跨域请求 XMLHttpRequest的方法： abort: 取消当前响应，关闭连接并且结束任何未决的网络活动 getAllResponseHeaders: 获取HTTP响应头部信息 getResponseHeader: 获取指定的HTTP响应头部的值 open: 初始化HTTP请求参数，例如URL和HTTP方法，但是并不发送请求 send: 发送HTTP请求 setRequestHeader: 指定一个HTTP请求的Header XMLHttpRequest的事件： onreadystatechange: 网络请求状态发生变化事件 onloadstart: 网络请求开始事件 onprogress: 网络请求传输数据事件 onabort: 网络请求取消事件 onerror: 网络请求错误事件 onload: 网络请求成功事件 ontimeout: 网络请求超时事件 onloadend: 网络请求结束事件 mui ajaxmui框架基于htm5plus的XMLHttpRequest，封装了常用的Ajax函数，支持GET、POST请求方式，支持返回json、xml、html、text、script数据类型； 本着极简的设计原则，mui提供了mui.ajax方法，并在mui.ajax方法基础上，进一步简化出最常用的mui.get()、mui.getJSON()、mui.post()三个方法。 mui.ajax(url [,settings]) url：请求发送的目标地址 settings：key/value格式的json对象，用来配置ajax请求参数，支持的参数如下： data：发送到服务器的业务数据； type：请求方式，目前仅支持’GET’和’POST’，默认为’GET’方式； dataType：预期服务器返回的数据类型；如果不指定，mui将自动根据HTTP包的MIME头信息自动判断；支持设置的dataType可选值： “xml”: 返回XML文档 “html”: 返回纯文本HTML信息； “script”: 返回纯文本JavaScript代码 “json”: 返回JSON数据 “text”: 返回纯文本字符串 success：Type: Functon（Anything data,String textStatus,XMLHttpRequest xhr）请求成功时触发的回调函数，该函数接收三个参数： data：服务器返回的响应数据，类型可以是json对象、xml对象、字符串等； textStatus：状态描述，默认值为’success’ xhr：xhr实例对象 error：Type: Functon（XMLHttpRequest xhr,String type,String errorThrown）请求失败时触发的回调函数；该函数接收三个参数： xhr：xhr实例对象 type：错误描述，可取值：”timeout”, “error”, “abort”, “parsererror”、”null” errorThrown：可捕获的异常对象 timeout：Type: Number，请求超时时间（毫秒），默认值为0，表示永不超时；若超过设置的超时时间(非0的情况)，依然未收到服务器响应，则触发error回调； headers：Type: Object,格式为：{&#39;Content-Type&#39;：&#39;application/json&#39;}，详情参考html5+ setRequestHeader。 基本格式如下：1234567891011121314151617mui.ajax(url,&#123; data:&#123; username:'username', password:'password' &#125;, dataType:'json',//服务器返回json格式数据 type:'post',//HTTP请求类型 timeout:10000,//超时时间设置为10秒； success:function(data)&#123; //服务器返回响应，根据响应结果，分析是否登录成功； ... &#125;, error:function(xhr,type,errorThrown)&#123; //异常处理； console.log(type); &#125;&#125;); mui.post( url [,data] [,success] [,dataType] ) mui.post()方法是对mui.ajax()的一个简化方法，直接使用POST请求方式向服务器发送数据、且不处理timeout和异常（若需处理异常及超时，请使用mui.ajax()方法）12345678mui.post('http://server-name/login.php',&#123; username:'username', password:'password' &#125;,function(data)&#123; //服务器返回响应，根据响应结果，分析是否登录成功； ... &#125;,'json'); mui.get( url [,data] [,success] [,dataType] ) mui.get()方法和mui.post()方法类似，只不过是直接使用GET请求方式向服务器发送数据、且不处理timeout和异常（若需处理异常及超时，请使用mui.ajax()方法）。如下为获得某服务器新闻列表的代码片段，服务器以json格式返回数据列表：1234567mui.get('http://server-name/list.php', &#123;category:'news'&#125;, function(data)&#123; //获得服务器响应 ... &#125;,'json'); mui.get( url [,data] [,success] ) mui.getJSON()方法是在mui.get()方法基础上的更进一步简化，限定返回json格式的数据，其它参数和mui.get()方法一致，如上获得新闻列表的代码换成mui.getJSON()方法后，更为简洁，如下：1234567mui.getJSON('http://server-name/list.php', &#123;category:'news'&#125;, function(data)&#123; //获得服务器响应 ... &#125;); mui在getJSON基础上封装了一个jsonp插件，具体dem可以参考这里：mui-jsonp实现有道词典翻译 注：初学者肯对于GET与POST的区别不是很清楚，这里不做详细介绍，若要深入了解请查看：GET，POST — 简述 项目实战我们接着上一篇文章的项目开始进行本节的内容，上一篇我们讲解了html5+ webview的使用方法，并且实现了一个基于父子webview的tab bar切换的案例，我们这次利用网易音乐API接口请求数据，完成我们后续的音乐播放器功能。 API分析网易音乐搜索API： url：http://s.music.163.com/search/get/ type：”GET”或“POST” //HTTP请求类型 请求参数： type: 1 s: //关键词 limit: 10 //限制返回结果数为10 offset: 0 //偏移 src: lofter //可为空 filterDj: true | false //可为空 callback: //为空时返回json，反之返回jsonp callback 由于HTTP请求类型包含get，我们只需要把请求的参数拼接到url里面就可以得到返回的数据，格式为url?key1=value1&amp;key2=value2。 在这个例子中我们打开这个网址http://s.music.163.com/search/get/?type=1&amp;limit=5&amp;s=喜欢你,我们会发现一些数据返回了，如下图： OK，我们下面讲解怎么通过程序得到这些数据，并且我们并且怎么解析这些数据。 在开始之前我们先对我们要得到的数据进行美化，这里我在网上随便搜了一个在线JSON校验格式化工具，我们只需要把刚刚那些数据复制粘贴到我给的这个工具里面，然后点击校验就变整齐了。12345678910111213141516171819202122232425262728293031&#123; \"result\": &#123; \"songCount\": 3224, \"songs\": [ &#123; \"id\": 28949444, \"name\": \"喜欢你\", \"artists\": [ &#123; \"id\": 7763, \"name\": \"G.E.M.邓紫棋\", \"picUrl\": null &#125; ], \"album\": &#123; \"id\": 2956076, \"name\": \"喜欢你\", \"artist\": &#123; \"id\": 0, \"name\": \"\", \"picUrl\": null &#125;, \"picUrl\": \"http://p1.music.126.net/u_1EudmF8Swgow6vfgYe1g==/8896148580676276.jpg\" &#125;, \"audio\": \"http://m2.music.126.net/_icR1apQHVl8wa0EP_REkQ==/3269947581061892.mp3\", \"djProgramId\": 0 &#125; ] &#125;, \"code\": 200&#125; 我们可以看到1\"picUrl\":\"http://p1.music.126.net/u_1EudmF8Swgow6vfgYe1g==/8896148580676276.jpg\" 打开这个图片地址我们就可以看到邓紫棋了，哈哈，也就是说我们只需要抓取到这个地址就可以进行下面的工作咯，其他的类似。 mui.ajax请求实例我们在上次新建的M-BOX下的home.html下写这个例子：123456789101112131415161718192021&lt;script src=\"../js/mui.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var url = \"http://s.music.163.com/search/get/\"; mui.ajax(url,&#123; data: &#123; 'type': 1, 's': \"喜欢你\", 'limit': 10 &#125;, dataType:'json',//服务器返回json格式数据 type:'post',//HTTP请求类型 timeout:10000,//超时时间设置为10秒； success:function(data)&#123; console.log(JSON.stringify(data)); &#125;, error:function(xhr,type,errorThrown)&#123; //异常处理； console.log(type); &#125; &#125;);&lt;/script&gt; hbuilder很方便的一个功能就是真机调试，我们直接将电脑与手机连接，通过console.log() 函数可以很方便的将数据在控制台打印出来，例如上述例子如果我们在success的回调函数中执行console.log(data);,在控制台会输出[object Object]，我们只需要利用JSON.stringify() 方法可以将任意的JavaScript 值序列化成 JSON 字符串。 Javascript JSON语法基础每次看到很多同学在解析json的时候错误百出，严重暴漏了基本功，这里我就总结几条与解析json可能相关的知识点。 什么是JSON？JSON:JavaScript Object Notation(JavaScript 对象表示法)，JSON 是存储和交换文本信息的语法,独立于语言。类似 XML。JSON 比 XML 更小、更快，更易解析,具有自我描述性，更易理解的特点。 JSON就是一串字符串，只不过元素会使用特定的符号标注。 {} 双括号表示对象 [] 中括号表示数组 “” 双引号内是属性或值 ：表示后者是前者的值(这个值可以是字符串、数字、也可以是另一个数组或对象) {&quot;name&quot;: &quot;Dcloud&quot;}可以理解为是一个包含name为Dcloud的对象;[{&quot;name&quot;: &quot;mui&quot;},{&quot;name&quot;: &quot;html5+&quot;}]就表示包含两个对象的数组。 通过JavaScript，您可以创建一个对象数组，并像这样进行赋值：12345var employees = [ &#123; \"firstName\":\"John\" , \"lastName\":\"Doe\" &#125;, &#123; \"firstName\":\"Anna\" , \"lastName\":\"Smith\" &#125;, &#123; \"firstName\":\"Peter\" , \"lastName\": \"Jones\" &#125;]; 可以像这样访问 JavaScript 对象数组中的第一项：employees[0].lastName;返回的内容是：Doe可以像这样修改数据：employees[0].firstName = &quot;Jonatan&quot;; JSON.stringify和JSON.parse这里需要特别说明的是两个非常有用的方法：JSON.stringify和JSON.parse。我们可以通过JSON.stringify将json对象转成json字符串，方便用alert,console.log打印出来，可以方便的查看json对象内容。反之我们可以通过JSON.parse将json字符串转成json对象以便可以方便对json对象取值。例：123456789101112// 场景1var data = &#123; name: 'zhaomenghuan', age: 22&#125;console.log(typeof data); // \"object\"console.log(JSON.stringify(data)) // \"&#123;\"name\":\"zhaomenghuan\",\"age\":22&#125;\"// 场景2var str = '&#123;\"name\":\"zhaomenghuan\",\"age\":22&#125;';console.log(typeof str) // \"string\"console.log(JSON.parse(str).name) // \"zhaomenghuan\" 上面的例子列举了两种应用场景，大家根据自己的情况合适的选取正确的方法。 运算符[ ] 和 .[ ]可以用于数组和对象取值，数组中按下边取值。12var array=[\"one\",\"two\",\"three\",\"four\"];array[0]; 对象属性取值时，当我们不知道属性名或属性名本身包含点（.）的键，应当使用[ ]。123for(var key in obj)&#123; console.log(key + \":\" + obj[key]);&#125; 12345var obj=&#123; id:&quot;obj&quot;, &quot;self.ref&quot;:ref&#125;console.log(obj[&quot;self.ref&quot;]); .运算符的左边为一个对象，右边为属性名。如：obj.id 可以动态访问属性：12345678var key=\"property\";console.log(key);var obj=&#123; property:\"hello word\"&#125;console.log(obj[key]); 数组的map方法：1234var array=[1,2,3,4,5];array.map(function(item)&#123; return item*2;&#125;); 数组map方法可以接受一个匿名函数，数组中每个元素都会调用这个匿名函数，并且讲返回结果放在一个数组中。 获取数据更新UImui中的each()方法既是一个类方法，同时也是一个对象方法，两个方法适用场景不同；换言之，你可以使用mui.each()去遍历数组或json对象，也可以使用mui(selector).each()去遍历DOM结构。 mui.each( obj , handler ) obj :Type: Array||JSONObj 需遍历的对象或数组；若为对象，仅遍历对象根节点下的key handler :Type: Function( Integer||String index,Anything element)为每个元素执行的回调函数；其中，index表示当前元素的下标或key，element表示当前匹配元素 对于前面说到的音乐api返回的json数据，首先我们要通过var songs=data.result.songs;获取&quot;songs&quot;的值，然后遍历&quot;songs&quot;对象的子对象。12345678910111213···success:function(data)&#123; // console.log(JSON.stringify(data)); var songs=data.result.songs; mui.each(songs,function(index,item)&#123; var id = item.id, name = item.album.name, author = item.artists[0].name, picUrl = item.album.picUrl, audio = item.audio; &#125;)&#125;,··· 我们用上述代码可以得到我们想要的数据，下面就是需要将信息展示出来，这里我们只获取 歌曲id、歌曲所属专辑名name、歌曲第一作者author、歌曲所属专辑图片picUrl 、歌曲音频文件audio。 考虑到要加载很多图片，这里我们使用懒加载实现效果，这里我们直接使用hello mui里面的模板页面lazyload-image.html，我们需要引入mui.lazyload.js和mui.lazyload.img.js两个文件，还有占位图。下面先贴出修改后的基本的代码，然后再讲解其中的内容。home.html:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;M-BOX&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no\"&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; &lt;!--标准mui.css--&gt; &lt;link rel=\"stylesheet\" href=\"../css/mui.min.css\"&gt; &lt;style type=\"text/css\"&gt; .mui-content&gt;.mui-table-view:first-child &#123; margin-top: 0px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"mui-content\"&gt; &lt;ul id=\"list\" class=\"mui-table-view mui-table-view-chevron\"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"../js/mui.min.js \"&gt;&lt;/script&gt; &lt;script src=\"../js/mui.lazyload.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/mui.lazyload.img.js\"&gt;&lt;/script&gt; &lt;script&gt; mui.init(); var url = \"http://s.music.163.com/search/get/\"; mui.ajax(url,&#123; data: &#123; 'type': 1, 's': \"喜欢你\", 'limit': 10 &#125;, dataType:'json',//服务器返回json格式数据 type:'post',//HTTP请求类型 timeout:10000,//超时时间设置为10秒； success:function(data)&#123; //console.log(JSON.stringify(data)); var songs=data.result.songs; var list = document.getElementById(\"list\"); var fragment = document.createDocumentFragment(); var li; mui.each(songs,function(index,item)&#123; var id = item.id, name = item.album.name, author = item.artists[0].name, picUrl = item.album.picUrl, audio = item.audio; li = document.createElement('li'); li.className = 'mui-table-view-cell mui-media'; li.innerHTML = '&lt;a class=\"mui-navigate-right\" id='+ id +' data-audio='+ audio +'&gt;'+ '&lt;img class=\"mui-media-object mui-pull-left\" data-lazyload=\"'+picUrl+'\"&gt;'+ '&lt;div class=\"mui-media-body\"&gt;'+name+ '&lt;p class=\"mui-ellipsis\"&gt;'+author+'&lt;/p&gt;'+ '&lt;/div&gt;'+ '&lt;/a&gt;'; fragment.appendChild(li); &#125;) list.appendChild(fragment) mui(document).imageLazyload(&#123; placeholder: '../img/60x60.gif' &#125;); &#125;, error:function(xhr,type,errorThrown)&#123; //异常处理； console.log(type); &#125; &#125;); //列表点击事件 mui(\"#list\").on('tap','li a',function()&#123; var id = this.getAttribute('id'); var audio = this.getAttribute('data-audio'); //打开详情页面 mui.openWindow(&#123; url:'music.html', id:'music.html', extras:&#123; musicId:id, audioUrl:audio &#125; &#125;); &#125;); &lt;/script&gt;&lt;/html&gt; music.html:12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=\"../css/mui.min.css\" rel=\"stylesheet\"/&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"../js/mui.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; mui.init(); mui.plusReady(function()&#123; var self = plus.webview.currentWebview(); var musicId = self.musicId; var audioUrl = self.audioUrl; document.write(\"musicId:\" + musicId + \"&lt;br /&gt;\"); document.write(\"audioUrl:\" + audioUrl); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们这里说几个开发者常见的问题： 拼接html字符串首先打开hello mui里面的模板页面lazyload-image.html，我们打开控制台查看elements，结构如下：1234567891011&lt;ul id=\"list\" class=\"mui-table-view mui-table-view-chevron\"&gt; &lt;li class=\"mui-table-view-cell mui-media\"&gt; &lt;a class=\"mui-navigate-right\"&gt; &lt;img class=\"mui-media-object mui-pull-left\" data-lazyload-id=\"0\" src=\"http://www.dcloud.io/hellomui/images/1.jpg?version=447.4190210457891\"&gt; &lt;div class=\"mui-media-body\"&gt; 主标题 &lt;p class=\"mui-ellipsis\"&gt;列表二级标题&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 我们需要将获取的内容动态的填充到这个里面，这里常用的方法就是动态的生成节点，这里我们就要用到DOM的创建方法document.createElement,通过这个方法我们可以生成一个节点:li = document.createElement(&#39;li&#39;);这个可以生成一个li节点，我们需要为这个li指定class,通过对对象的className赋值实现，如：li.className = &#39;mui-table-view-cell mui-media&#39;;,我们使用appendChild(li)方法将li节点挂着父节点上，比如: 12var list = document.getElementById(\"list\");list.appendChild(li); 这个就是把li节点挂在list下，同理我们可以在li节点下 创建子节点，上面为了简单，我们使用给innerHTML属性赋值的做法，这样innerHTML的值同样会挂在li节点下，大家需要注意的是innerHTML属性的值我字符串，所以我们往中间插入了变量，要使用+连接起来。我们可以通过循环创建多个节点，如下面这样创建十个段落：123456for(var i = 0 ; i &lt; 10; i ++) &#123; var p = document.createElement(\"p\"); var oTxt = document.createTextNode(\"段落\" + i); p.appendChild(oTxt); document.body.appendChild(p);&#125; 上面我们使用的是mui.each()方法，效果类似。 如果细心的同学或许注意到我们使用了一个奇怪的写法：123456var fragment = document.createDocumentFragment();mui.each(songs,function(index,item)&#123; ... fragment.appendChild(li);&#125;);list.appendChild(fragment); 为啥我们要在这里使用document.createDocumentFragment()呢？ 如果是对前端技术感兴趣的同学说不定回去查一下，我相信大部分人可能就放过了吧！这里我查了一下资料： 在《javascript高级程序设计》一书的6.3.5:创建和操作节点一节中，介绍了几种动态创建html节点的方法，其中有以下几种常见方法： crateAttribute(name)： 用指定名称name创建特性节点 createComment(text)： 创建带文本text的注释节点 createDocumentFragment()： 创建文档碎片节点 createElement(tagname)： 创建标签名为tagname的节点 createTextNode(text)： 创建包含文本text的文本节点 其中最感兴趣且以前没有接触过的一个方法是createDocumentFragment()方法，书中介绍说：在更新少量节点的时候可以直接向document.body节点中添加，但是当要向document中添加大量数据是，如果直接添加这些新节点，这个过程非常缓慢，因为每添加一个节点都会调用父节点的appendChild()方法，为了解决这个问题，可以创建一个文档碎片，把所有的新节点附加其上，然后把文档碎片一次性添加到document中。—— document的createDocumentFragment()方法 页面传值我们点击了列表，我们会进入一个详情页，我们肯定是想知道我们究竟点了哪一个我们想把一些数据传入到详情页面，这里我们使用了mui.openWindow()方法中的拓展参数extras传入几个值，在详情页面通过plus.webview.currentWebview获取：1234567mui.plusReady(function()&#123; var self = plus.webview.currentWebview(); var musicId = self.musicId; var audioUrl = self.audioUrl; document.write(\"musicId:\" + musicId + \"&lt;br /&gt;\"); document.write(\"audioUrl:\" + audioUrl);&#125;); 这是在页面初始化时，通过扩展参数extras传值；另外还有页面已创建，通过自定义事件传值，参考mui官网中自定义事件的介绍，这里先不讲得太多，后面会专门花时间详细讲解相关细节。 jsonp实现由于前面已经详细讲解，这里就不再赘述，只给出一个基本的demo：jsonp获取网易云音乐。 当我们写到这里，发现这篇依然是长长的一篇干货，很多内容摘自文档，主要是为了新手可以详细去了解整个流程。其实还有很多没有写出来，限于篇幅还是后面再写吧！由于代码在文章中写得很详细，工程代码先不给出来，最后整个系列写完了再放出来吧！ 随便聊聊这段时间在技术上花得时间确实太多，刚刚和女朋友在图书馆学习，她和我开个玩笑，我在忙着做作业因为不喜欢被打扰，然后就觉得很烦躁，然后就聊着聊着她说和我分手，我不知道她是不是认真的，只是觉得空空的，自从走上代码这条路，我已经失去太多东西，我不想失去女朋友，毕竟谈了三年，我是真的爱她，写完这个就去找她道歉吧！还有要向环头道歉，昨天可能说话有点直接，不小心伤到他了，后来想想真的可能是我太较真，他只是想玩玩程序，我何必那种执着呢？如果环头看到这篇博客，希望你可以原谅哥，我只是不想让你走弯路，或许每个都应该自己去把握自己的人生，我们不必去干涉。 写文章不容易，也许写这些代码就几分钟的事，写一篇大家好接受的文章或许需要几天的酝酿，然后加上几天的码字，累并快乐着。如果文章对您有帮助请我喝杯咖啡吧！","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"html5plus","slug":"html5plus","permalink":"https://zhaomenghuan.github.io/tags/html5plus/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"https://zhaomenghuan.github.io/tags/XMLHttpRequest/"},{"name":"ajax","slug":"ajax","permalink":"https://zhaomenghuan.github.io/tags/ajax/"},{"name":"懒加载","slug":"懒加载","permalink":"https://zhaomenghuan.github.io/tags/懒加载/"}]},{"title":"mui初级入门教程（二）— html5+ webview 底部栏用法详解","slug":"mui初级入门教程（二）—html5+ webview 底部栏用法详解","date":"2016-05-18T16:00:00.000Z","updated":"2017-05-03T16:15:28.095Z","comments":true,"path":"2016/05/19/mui初级入门教程（二）—html5+ webview 底部栏用法详解/","link":"","permalink":"https://zhaomenghuan.github.io/2016/05/19/mui初级入门教程（二）—html5+ webview 底部栏用法详解/","excerpt":"","text":"写在前面本系列文章我们将利用mui基于网易云音乐API实现一个音乐播放器APP，同时基于环形或者融云实现聊天功能。作为本系列文章的第一篇，本文会详细讲解html5+中管理应用窗口界面的Webview模块的用法，因为是初级教程篇不过多讲解原理部分，初级用户只需要知道基本用法就可以，并使用mui.js中的组件进行页面效果展示。 webview基本知识 Webview模块管理应用窗口界面，实现多窗口的逻辑控制管理操作。通过plus.webview可获取应用界面管理对象。 什么是窗口？什么是webview?这里我们首先来举个例子，大家都用过浏览器，常用的浏览器可以打开多个网页。电脑屏幕就是一个窗口，不同的页面我们可以什么是不同的webview，我们可以通过控制webview的切换从而控制浏览不同的页面。 对于我们这里就是一个html页面就是一个窗口，一个html页面可以创建多个webview。这个webview是原生APP中浏览网页的组件，android和iOS都有，html5plus中的webview是对原生webview的封装，可以用js进行调用，所以它的运行环境是APP环境，普通浏览器不支持。 首先我们现在html5plus官网看一下webview API文档,这里我们重点看一下下面几个方法: 创建新的Webview窗口1WebviewObject plus.webview.create( url, id, styles, extras ); 说明:创建Webview窗口，用于加载新的HTML页面，可通过styles设置Webview窗口的样式，创建完成后需要调用show方法才能将Webview窗口显示出来。 显示Webview窗口1void plus.webview.show( id_wvobj, aniShow, duration, showedCB, extras ); 说明：显示已创建或隐藏的Webview窗口，需先获取窗口对象或窗口id，并可指定显示窗口的动画及动画持续时间。 隐藏Webview窗口1void plus.webview.hide( id_wvobj, aniHide, duration, extras ); 说明：根据指定的WebviewObject对象或id隐藏Webview窗口，使得窗口不可见。 获取当前窗口的WebviewObject对象1WebviewObject plus.webview.currentWebview(); 说明：获取当前页面所属的Webview窗口对象。 查找指定标识的WebviewObject窗口1WebviewObject plus.webview.getWebviewById( id ); 说明：在已创建的窗口列表中查找指定标识的Webview窗口并返回。 若没有查找到指定标识的窗口则返回null，若存在多个相同标识的Webview窗口，则返回第一个创建的Webview窗口。 如果要获取应用入口页面所属的Webview窗口，其标识为应用的%APPID%，可通过plus.runtime.appid获取。 创建并打开Webview窗口1WebviewObject plus.webview.open( url, id, styles, aniShow, duration, showedCB ); 说明：创建并显示Webview窗口，用于加载新的HTML页面，可通过styles设置Webview窗口的样式，创建完成后自动将Webview窗口显示出来。 以上来源于html5plus文档，只列举了部分最常用的方法，旨在为后文做铺垫，由于不是文档，所以也得也不清楚，如果想详细了解请看这里html5plus webview API。 mui双webview模式首先我们要了解mui为了解决窗体切换白屏和区域滚动提出的双webview模式。 页面初始化 mui框架将很多功能配置都集中在mui.init方法中，要使用某项功能，只需要在mui.init方法中完成对应参数配置即可，目前支持在mui.init方法中配置的功能包括：创建子页面、关闭页面、手势事件配置、预加载、下拉刷新、上拉加载、设置系统状态栏背景颜色。mui需要在页面加载时初始化很多基础控件,如监听返回键,因此务必在每个页面中调用. 以下是可以配置的参数：123456789101112131415161718192021222324252627282930313233mui.init(&#123; //子页面 subpages: [&#123; //... &#125;], //预加载 preloadPages:[ //... ], //下拉刷新、上拉加载 pullRefresh : &#123; //... &#125;, //手势配置 gestureConfig:&#123; //... &#125;, //侧滑关闭 swipeBack:true, //Boolean(默认false)启用右滑关闭功能 //监听Android手机的back、menu按键 keyEventBind: &#123; backbutton: false, //Boolean(默认truee)关闭back按键监听 menubutton: false //Boolean(默认true)关闭menu按键监听 &#125;, //处理窗口关闭前的业务 beforeback: function() &#123; //... //窗口关闭前处理其他业务详情点击 ↑ \"关闭页面\"链接查看 &#125;, //设置状态栏颜色 statusBarBackground: '#9defbcg', //设置状态栏颜色,仅iOS可用 preloadLimit:5//预加载窗口数量限制(一旦超出,先进先出)默认不限制&#125;) 在app开发中，若要使用HTML5+扩展api，必须等plusready事件发生后才能正常使用，mui将该事件封装成了mui.plusReady()方法，涉及到HTML5+的api，建议都写在mui.plusReady方法中。 如下为打印当前页面URL的示例：123mui.plusReady(function()&#123; console.log(\"当前页面URL：\"+plus.webview.currentWebview().getURL());&#125;); 创建子页面在mobile app开发过程中，经常遇到卡头卡尾的页面，此时若使用局部滚动，在android手机上会出现滚动不流畅的问题； mui的解决思路是：将需要滚动的区域通过单独的webview实现，完全使用原生滚动。具体做法则是：将目标页面分解为主页面和内容页面，主页面显示卡头卡尾区域，比如顶部导航、底部选项卡等；内容页面显示具体需要滚动的内容，然后在主页面中调用mui.init方法初始化内容页面。1234567891011121314mui.init(&#123; subpages:[&#123; url:your-subpage-url,//子页面HTML地址，支持本地地址和网络地址 id:your-subpage-id,//子页面标志 styles:&#123; top:subpage-top-position,//子页面顶部位置 bottom:subpage-bottom-position,//子页面底部位置 width:subpage-width,//子页面宽度，默认为100% height:subpage-height,//子页面高度，默认为100% ...... &#125;, extras:&#123;&#125;//额外扩展参数 &#125;]&#125;); 参数说明：styles:表示窗口属性，参考5+规范中的WebviewStyle；特别注意，height和width两个属性,即使不设置，也默认按100%计算；因此若设置了top值为非”0px”的情况，建议同时设置bottom值，否则5+ runtime根据高度100%计算，可能会造成页面真实底部位置超出屏幕范围的情况；left、right同理。 示例：Hello mui的首页其实就是index.html加list.html合并而成的，如下： {% image https://segmentfault.com/img/remote/1460000005340870 '' '' %} index.html的作用就是显示固定导航，list.html显示具体列表内容，列表项的滚动是在list.html所在webview中使用原生滚动，既保证了滚动条不会穿透顶部导航，符合app的体验，也保证了列表流畅滚动，解决了区域滚动卡顿的问题。 list.html就是index.html的子页面，创建代码比较简单，如下：12345678910mui.init(&#123; subpages:[&#123; url:'list.html', id:'list.html', styles:&#123; top:'45px',//mui标题栏默认高度为45px； bottom:'0px'//默认为0px，可不定义； &#125; &#125;]&#125;); 打开新页面做web app，一个无法避开的问题就是转场动画；web是基于链接构建的，从一个页面点击链接跳转到另一个页面，如果通过有刷新的打开方式，用户要面对一个空白的页面等待；如果通过无刷新的方式，用Javascript移入DOM节点（常见的SPA解决方案），会碰到很高的性能挑战：DOM节点繁多，页面太大，转场动画不流畅甚至导致浏览器崩溃； mui的解决思路是：单webview只承载单个页面的dom，减少dom层级及页面大小；页面切换使用原生动画，将最耗性能的部分交给原生实现。1234567891011121314151617181920212223242526272829mui.openWindow(&#123; url:new-page-url, id:new-page-id, styles:&#123; top:newpage-top-position,//新页面顶部位置 bottom:newage-bottom-position,//新页面底部位置 width:newpage-width,//新页面宽度，默认为100% height:newpage-height,//新页面高度，默认为100% ...... &#125;, extras:&#123; .....//自定义扩展参数，可以用来处理页面间传值 &#125;, createNew:false,//是否重复创建同样id的webview，默认为false:不重复创建，直接显示 show:&#123; autoShow:true,//页面loaded事件发生后自动显示，默认为true aniShow:animationType,//页面显示动画，默认为”slide-in-right“； duration:animationTime//页面动画持续时间，Android平台默认100毫秒，iOS平台默认200毫秒； &#125;, waiting:&#123; autoShow:true,//自动显示等待框，默认为true title:'正在加载...',//等待对话框上显示的提示内容 options:&#123; width:waiting-dialog-widht,//等待框背景区域宽度，默认根据内容自动计算合适宽度 height:waiting-dialog-height,//等待框背景区域高度，默认根据内容自动计算合适高度 ...... &#125; &#125;&#125;) 参数说明： styles:表示窗口参数，参考5+规范中的WebviewStyle；特别注意，runtime```根据高度```100%```计算，可能会造成页面真实底部位置超出屏幕范围的情况,```left```、```right```同理。12345678910- **extras:**新窗口的额外扩展参数，可用来处理页面间传值；例如：```jsvar webview = mui.openWindow(&#123; url:&apos;info.html&apos;, extras:&#123; name:&apos;mui&apos; &#125;&#125;);console.log(webview.name); 控制台会输出”mui”字符串；注意：扩展参数仅在打开新窗口时有效，若目标窗口为预加载页面，则通过mui.openWindow方法打开时传递的extras参数无效。 createNew:是否重复创建相同id的v1.7.0开始增加```createNew```参数，默认为false；判断逻辑如下：若createNew为true，则不判断重复，每次都新建```webview```；若为fasle，则先计算当前App中是否已存在同样id的webview，若存在则直接显示；否则新创建并根据show参数执行显示逻辑；该参数可能导致的影响：若业务写在```plusReady```事件中，而```plusReady```事件仅首次创建时会触发，则下次再次通过```mui.openWindow```方法打开同样webview时，是不会再次触发```plusReady```事件的，此时可通过自定义事件触发；案例参考：```http://ask.dcloud.net.cn/question/6514```;12345678910111213- **show:**表示窗口显示控制。autoShow：目标窗口loaded事件发生后，是否自动显示；若目标页面为预加载页面，则该参数无效；aniShow表示页面显示动画，比如从右侧划入、从下侧划入等，具体可参考[5+规范中的AnimationTypeShow](http://www.html5plus.org/doc/zh_cn/webview.html#plus.webview.AnimationTypeShow)。- **waiting:**表示系统等待框；mui框架在打开新页面时等待框的处理逻辑为：显示等待框--&gt;创建目标页面webview--&gt;目标页面loaded事件发生--&gt;关闭等待框；因此，只有当新页面为新创建页面（webview）时，会显示等待框，否则若为预加载好的页面，则直接显示目标页面，不会显示等待框。waiting中的参数：autoShow表示自动显示等待框，默认为true，若为false，则不显示等待框；注意：若显示了等待框，但目标页面不自动显示，则需在目标页面中通过如下代码关闭等待框```plus.nativeUI.closeWaiting()```;。title表示等待框上的提示文字，options表示等待框显示参数，比如宽高、背景色、提示文字颜色等，具体可参考[5+规范中的WaitingOption](http://www.html5plus.org/doc/zh_cn/nativeui.html#plus.nativeUI.WaitingOptions)。**示例1：Hello mui中，点击首页右上角的图标，会打开关于页面，实现代码如下：**```js//tap为mui封装的单击事件，可参考手势事件章节document.getElementById(&apos;info&apos;).addEventListener(&apos;tap&apos;, function() &#123; //打开关于页面 mui.openWindow(&#123; url: &apos;examples/info.html&apos;, id:&apos;info&apos; &#125;);&#125;); 因没有传入styles参数，故默认全屏显示；也没有传入show参数，故使用slide-in-right动画，新页面从右侧滑入。 示例2：从A页面打开B页面，B页面为一个需要从服务端加载的列表页面，若在B页面loaded事件发生时就将其显示出来，因服务器数据尚未加载完毕，列表页面为空，用户体验不好；可通过如下方式改善用户体验（最好的用户体验应该是通过预加载的方式） 第一步，B页面loaded事件发生后，不自动显示1234567//A页面中打开B页面，设置show的autoShow为false，则B页面在其loaded事件发生后，不会自动显示；mui.openWindow(&#123; url: 'B.html', show:&#123; autoShow:false &#125;&#125;); 第二步，在B页面获取列表数据后，再关闭等待框、显示B页面12345678910111213//B页面onload从服务器获取列表数据；window.onload = function()&#123; //从服务器获取数据 .... //业务数据获取完毕，并已插入当前页面DOM； //注意：若为ajax请求，则需将如下代码放在处理完ajax响应数据之后； mui.plusReady(function()&#123; //关闭等待框 plus.nativeUI.closeWaiting(); //显示当前页面 mui.currentWebview.show(); &#125;);&#125; 关闭页面mui框架将窗口关闭功能封装在mui.back方法中，具体执行逻辑是：若当前webview为预加载页面，则hide当前webview；否则，close当前webview。 在mui框架中，有三种操作会触发页面关闭（执行mui.back方法）。 点击包含.mui-action-back类的控件 在页面上，向右快速滑动 Android手机按下back按键 hbuilder中敲mheader生成的代码块，会自动生成带有返回导航箭头的标题栏，点击返回箭头可关闭当前页面，原因就是因为该返回箭头包含.mui-action-back类，代码如下：1234&lt;header class=\"mui-bar mui-bar-nav\"&gt; &lt;a class=\"mui-action-back mui-icon mui-icon-left-nav mui-pull-left\"&gt;&lt;/a&gt; &lt;h1 class=\"mui-title\"&gt;标题&lt;/h1&gt;&lt;/header&gt; 若希望在顶部导航栏之外的其它区域添加关闭页面的控件，只需要在对应控件上添加.mui-action-back类即可，如下为一个关闭按钮示例：1&lt;button type=\"button\" class='mui-btn mui-btn-danger mui-action-back'&gt;关闭&lt;/button&gt; mui框架封装的页面右滑关闭功能，默认未启用，若要使用右滑关闭功能，需要在1234```jsmui.init(&#123; swipeBack:true //启用右滑关闭功能&#125;); mui框架默认会监听Android手机的back按键，然后执行页面关闭逻辑； 若不希望mui自动处理back按键，可通过如下方式关闭mui的back按键监听；12345mui.init(&#123; keyEventBind: &#123; backbutton: false //关闭back按键监听 &#125;&#125;); 除了如上三种操作外，也可以直接调用123456789101112131415执行```beforeback```参数对应的函数若返回false，则不再执行mui.back()方法；否则（返回true或无返回值），继续执行mui.back()方法；示例：从列表打开详情页面，从详情页面再返回后希望刷新列表界面，此时可注册beforeback参数，然后通过自定义事件通知列表页面刷新数据，示例代码如下：```jsmui.init(&#123; beforeback: function()&#123; //获得列表界面的webview var list = plus.webview.getWebviewById(&apos;list&apos;); //触发列表界面的自定义事件（refresh）,从而进行数据刷新 mui.fire(list,&apos;refresh&apos;); //返回true，继续页面关闭逻辑 return true; &#125;&#125;); 注意：12345678910111213```js//备份mui.back，mui.back已将窗口关闭逻辑封装的比较完善（预加载及父子窗口），因此最好复用mui.backvar old_back = mui.back;mui.back = function()&#123; var btn = [&quot;确定&quot;,&quot;取消&quot;]; mui.confirm(&apos;确认关闭当前窗口？&apos;,&apos;Hello MUI&apos;,btn,function(e)&#123; if(e.index==0)&#123; //执行mui封装好的窗口关闭逻辑； old_back(); &#125; &#125;);&#125; 注意：自定义关闭逻辑时，一定要重写因为```addEventListener```只会增加新的执行逻辑，老的监听逻辑依然会执行；123456789101112131415161718192021222324252627282930313233343536373839404142434445## 项目实战这个系列的教程我准备带大家一起实现音乐播放器和即时通讯的功能,先上图不多说：![](http://i.imgur.com/ZUU01cb.jpg)开始的页面效果很简单，就是一个tab bar页面切换组件，我们重点讲解实现方法，至于美化是后面的事。在开始项目之前我先抄了文档的内容，不是为了凑内容，只是想让新手在开始项目之前还是多看看基本概念，俗话说磨刀不误砍柴工，我们对mui的设计思路有一定了解之后写起来才能得心应手。相信大家对于```mui```的双```webview```模式有初步认识，我们可以分析一下我们接下来要做的这个的实际例子，首先我们的入口文件```index.html```是一个包括头部和底部的导航栏的```webview```,中间是一个动态的```webview```，我们通过点击底部导航栏进行页面切换，并且动态的改变顶部导航栏的内容。下面我们新建一个mui项目，这里我命名为M-BOX：- 点击【文件】=》【新建】=》【移动APP】- 设置应用名称、文件存储路径、选择模板![](http://i.imgur.com/1YeZtIP.png)- js,css,fonts文件的详细介绍请戳这里[手把手教你开发HelloWord](https://zhaomenghuan.gitbooks.io/mui/content/1-1.html)- **[HBuilder对前端代码的调试方式](http://ask.dcloud.net.cn/docs/#http://ask.dcloud.net.cn/article/483)**这个是很重要的一个部分，限于篇幅，这里不能讲解，请自己看教程。### 开始写布局文件相信很多人看了前面那么多文档介绍内心肯定是崩溃的，其实我也是，毕竟写了那么多还没有开始写代码我也是拒绝的，只是考虑到很多新手对于找文档这事不一定有经验，那还是先贴一下，大不了回过头再去看咯。![](http://i.imgur.com/RbeJl2R.gif)好，那我们开始写布局文件：在[MUI开发注意事项](http://ask.dcloud.net.cn/article/122)这篇文章中提到了几个重要的注意事项，我们在一个就注意一下会比较好，这里不再一一详细列举了，读者自己去看。文章中DOM结构提到：- 固定栏靠前所谓的固定栏，也就是带有.mui-bar属性的节点，都是基于fixed定位的元素；常见组件包括：顶部导航栏（.mui-bar-nav）、底部工具条(.mui-bar-footer)、底部选项卡（.mui-bar-tab）;这些元素使用时需遵循一个规则：放在.mui-content元素之前，即使是底部工具条和底部选项卡，也要放在.mui-content之前，否则固定栏会遮住部分主内容；- 一切内容都要包裹在mui-content中除了固定栏之外，其它内容都要包裹在.mui-content中，否则就有可能被固定栏遮罩，原因：固定栏基于Fixed定位，不受流式布局限制，普通内容依然会从top:0的位置开始布局，这样就会被固定栏遮罩，mui为了解决这个问题，定义了如下css代码：```css.mui-bar-nav ~ .mui-content &#123; padding-top: 44px;&#125;.mui-bar-footer ~ .mui-content &#123; padding-bottom: 44px;&#125;.mui-bar-tab ~ .mui-content &#123; padding-bottom: 50px;&#125; 我们这里重点看这两条规则，因为这个对于我们正确布局是至关重要的。 下面我们体验一下1234哈哈，页面头部出来了，不错，这里我们然后删除下面的：```html&lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&gt;&lt;/a&gt; 先去掉返回箭头。 然后继续输入12345678910111213141516171819202122232425262728293031323334整体代码如下：```html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;title&gt;M-BOX&lt;/title&gt; &lt;link href=&quot;css/mui.min.css&quot; rel=&quot;stylesheet&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;mui-bar mui-bar-nav&quot;&gt; &lt;h1 class=&quot;mui-title&quot;&gt;标题&lt;/h1&gt; &lt;/header&gt; &lt;nav class=&quot;mui-bar mui-bar-tab&quot;&gt; &lt;a class=&quot;mui-tab-item mui-active&quot; href=&quot;html/home.html&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-home&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;首页&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot; href=&quot;html/message.html&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-chatboxes&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;消息&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot; href=&quot;html/setting.html&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-gear&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;设置&lt;/span&gt; &lt;/a&gt; &lt;/nav&gt; &lt;script src=&quot;js/mui.min.js&quot;&gt;&lt;/script&gt;; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; // 初始化mui.init()写在这里 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 首页的静态布局我们写完了，我们接下来新建三个含mui的html文件： 选择工程名，邮件就可以看到【新建】，然后就是选择【目录】新建文件夹和【html文件】新建含mui的html文件。我们新建一个文件夹1234567- 在三个页面`body`之间分别输入`mbody`,就可以开始分别写页面了，比如可以先在页面上写上文件名，我们先来完善首页的子页切换逻辑。### 动态页面切换#### 1.创建子页面，首个选项卡页面显示，其它均隐藏主要方法就是用```plus.webview.create```和```plus.webview.hide(); 123456789101112131415161718192021222324252627//设置默认打开首页显示的子页序号；var Index=0;//把子页的路径写在数组里面var subpages = ['html/home.html','html/message.html','html/setting.html'];//所有的plus-*方法写在mui.plusReady中或者后面。mui.plusReady(function() &#123; //获取当前页面所属的Webview窗口对象 var self = plus.webview.currentWebview(); for (var i = 0; i &lt; 3; i++) &#123; //创建webview子页 var sub = plus.webview.create( subpages[i], //子页url subpages[i], //子页id &#123; top: '45px',//设置距离顶部的距离 bottom: '50px'//设置距离底部的距离 &#125; ); //如不是我们设置的默认的子页则隐藏，否则添加到窗口中 if (i != Index) &#123; sub.hide(); &#125; //将webview对象填充到窗口 self.append(sub); &#125;&#125;); 注：如果Index不是0，需要将nav下的a标签中的1234567891011121314151617181920执行完我们会发现home.html的内容显示出来了，但是底部切换还不能，因为这里我们还没有监听底部的点击事件。在进行下一步之前，我们可以先做一个小实验，将上面的代码中的top或者bottom改为0,我们会发现，底部栏或者底部栏会被覆盖，这是因为mui一个重要的**潜规则**，**父子结构的页面子页面会比父页面层级高**，说白了就是子页面可以盖住父页面。这会导致开发者常犯的一个错误：将弹出层或者弹出菜单写在父页面被子页面盖住的bug。&gt; 这里的apend()方法在html5plus文档中没有提到，这里的这个方法是将webview对象填充到窗口的方法。#### 2.选项卡点击事件mui 内部封装了一些常用的方法，其中DOM选择器、事件绑定等事件管理。具体可以参考文档：[选择器](http://dev.dcloud.net.cn/mui/util/#selector)、[事件管理](http://dev.dcloud.net.cn/mui/event/)。&gt; mui()mui使用css选择器获取HTML元素，返回mui对象数组。- `mui(&quot;p&quot;)`：选取所有`p`元素- `mui(&quot;p.title&quot;)`：选取所有包含`.title`类的`&lt;p&gt;`元素若要将mui对象转化成dom对象，可使用如下方法（类似jquery对象转成dom对象）：```js//obj1是mui对象var obj1 = mui(&quot;#title&quot;);//obj2是dom对象var obj2 = obj1[0]; .on( event , selector , handler ) event Type: String 需监听的事件名称，例如：’tap’ selector Type: String-选择器 handler Type: Function( Event event ) 事件触发时的回调函数，通过回调中的event参数可以获得事件详情 除了可以使用addEventListener()方法监听某个特定元素上的事件外， 也可以使用.on()方法实现批量元素的事件绑定。 这里我们将为底部导航按钮添加事件：1234//选项卡点击事件mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; alert(true);&#125;); 当我们点击底部选项卡的时候会弹出true，这不够，我们要能够分辨当前对象具体是哪一个，有两种思路: 第一我们能够知道当前点击的a标签所在序号就好了，就是找到index,然后根据上面那个subpages数组，利用plus.webview.show(subpages[index])方法显示。 我们给当前点击的a标签添加一个可以识别的属性，然后根据那个属性获取当前a的特征，然后就可以显示点击的子页，隐藏当前子页。 第一种方法需要遍历此案获取index，第二种方法添加一个href很容易拿到子页id，我们采用第二种方案。 getAttribute() getAttribute() 方法返回指定属性名的属性值。提示：如果您希望以Attr对象返回属性，请使用getAttributeNode。 于是我们可以这样写：123456789101112131415161718//当前激活选项var activeTab = subpages[Index],title=document.querySelector(\".mui-title\");//选项卡点击事件mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; //获取目标子页的id var targetTab = this.getAttribute('href'); if (targetTab == activeTab) &#123; return; &#125; //更换标题 title.innerHTML = this.querySelector('.mui-tab-label').innerHTML; //显示目标选项卡 plus.webview.show(targetTab); //隐藏当前选项卡 plus.webview.hide(activeTab); //更改当前活跃的选项卡 activeTab = targetTab;&#125;); 兼容浏览器的处理办法这是后面补充的内容，最开始写的时候没有这个内容，在这里加上吧。为啥要加这个内容呢，因为很多人思维还是比较局限，用mui依然还是用原来的方法，有很多人依然使用href,之所以这么用就是大家改不了习惯，这就是被很多人说的坑。。。但是真的是坑吗？与其说是坑，我觉得是大家思维上没有转变过来，不明白mui为啥要禁用href这种方式，也不明白自己该怎么做。 下面贴出一个用iframe代替多子webview形式的tabbar在浏览器的兼容处理方法： 1234567891011121314151617181920212223var createIframe = function (el, opt) &#123; var elContainer = document.querySelector(el); var wrapper = document.querySelector(\".mui-iframe-wrapper\"); if(!wrapper)&#123; // 创建wrapper 和 iframe wrapper = document.createElement('div'); wrapper.className = 'mui-iframe-wrapper'; for(var i in opt.style)&#123; wrapper.style[i] = opt.style[i]; &#125; var iframe = document.createElement('iframe'); iframe.src = opt.url; iframe.id = opt.id || opt.url; iframe.name = opt.id; wrapper.appendChild(iframe); elContainer.appendChild(wrapper); &#125;else&#123; var iframe = wrapper.querySelector('iframe'); iframe.src = opt.url; iframe.id = opt.id || opt.url; iframe.name = iframe.id; &#125;&#125; 调用也很简单：1234567891011121314151617181920212223242526272829//当前激活选项var activeTab = subpages[Index],title=document.querySelector(\".mui-title\");mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; // 获取目标子页的id var targetTab = this.getAttribute('href'); if (targetTab == activeTab) &#123; return; &#125; // 更换标题 title.innerHTML = this.querySelector('.mui-tab-label').innerHTML; // 子页内容切换 if(mui.os.plus)&#123; // 显示目标webview plus.webview.show(targetTab); // 隐藏当前webview plus.webview.hide(activeTab); // 更改当前活跃的选项卡 activeTab = targetTab; &#125;else&#123; // 创建iframe代替子页面 createIframe('.mui-content',&#123; url: targetTab, style: &#123; top: '45px',//设置距离顶部的距离 bottom: '50px'//设置距离底部的距离 &#125; &#125;); &#125;&#125;) 这样你就可以一套代码实现在多平台的利用啦，是不是很棒。完整代码可以看这里：iframe兼容处理tababr的方法 双首页配置的优化方案HBuilder8.0.1版更新说明App中有一条：【重要】新增双首页配置（manifest-&gt;plus-&gt;secondwebview），加速首页为双webview模式时的应用启动速度。这对于我们优化app很有帮助，以前的方案中父子页面都在启动页，首页显示会过慢，8.0后的这次大更新可以很好的处理这个问题，官方配置说明见：【示例】双首页secondwebview配置的使用,但是官方文档中没有说明父子页的配置方法，这里给出一种方案： 1.按照文档配置manifest.json文件中的secondwebview节点2.将动态创建子页面放在点击事件中，例如： manifest.json文件：12345678...\"secondwebview\": &#123; \"launch_path\": \"_www/html/home.html\", \"id\": \"html/home.html\", \"top\": \"0px\", \"bottom\": \"51px\"&#125;... 首页的逻辑：12345678910111213141516171819202122232425262728293031323334var subpages = ['html/home.html', 'html/message.html', 'html/person.html'];var subpage_style = &#123; top: '0px', bottom: '51px'&#125;;// 当前激活选项var activeTab = subpages[0];// 创建子页面，首个选项卡页面显示，其它均隐藏；var currentWebview;mui.plusReady(function() &#123; currentWebview = plus.webview.currentWebview(); var secondWebview = plus.webview.getSecondWebview(); currentWebview.append(secondWebview);&#125;);// 选项卡点击事件mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; var targetTab = this.getAttribute('href'); if (targetTab == activeTab) &#123; return; &#125; var targetWebview = plus.webview.getWebviewById(targetTab); if(!targetWebview)&#123; targetWebview = plus.webview.create(targetTab, targetTab, subpage_style); currentWebview.append(targetWebview ); &#125; targetWebview.show(\"fade-in\",300); // 隐藏当前; plus.webview.hide(activeTab); // 更改当前活跃的选项卡 activeTab = targetTab;&#125;); 后记虽然最后实现的效果很简单，好像直接看demo就可以写出来，但是新手甚至写了一段时间的同学也不见得对webview掌握得很好，这篇文章花了很长的篇幅去讲解webview的用法，旨在为新手建立一种学习mui这边的思路，那就是先看html5plus里面的模块，然后看mui对应的文档，最后看hello mui的demo,把握这种学习路线个人觉得是一种最佳的方案。本文作为系列文章第一篇讲代码的，所以做了很多铺垫，所以有一定基础的同学可能会觉得写得并没有什么看点，后面的肯定会有所不一样的。下一篇讲解的是网络请求XMLHttpRequest模块，下一讲会结合mui.ajax和网易云音乐API一起讲解。 mui-demo仓库地址： https://github.com/zhaomenghuan/mui-demo 写文章不容易，也许写这些代码就几分钟的事，写一篇大家好接受的文章或许需要几天的酝酿，然后加上几天的码字，累并快乐着。如果文章对您有帮助请我喝杯咖啡吧！","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"html5plus","slug":"html5plus","permalink":"https://zhaomenghuan.github.io/tags/html5plus/"},{"name":"webview","slug":"webview","permalink":"https://zhaomenghuan.github.io/tags/webview/"}]},{"title":"mui初级入门教程（一）— 小白入手mui的学习路线","slug":"mui初级入门教程（一）—小白入手mui的学习路线","date":"2016-05-14T16:00:00.000Z","updated":"2017-05-03T16:15:13.127Z","comments":true,"path":"2016/05/15/mui初级入门教程（一）—小白入手mui的学习路线/","link":"","permalink":"https://zhaomenghuan.github.io/2016/05/15/mui初级入门教程（一）—小白入手mui的学习路线/","excerpt":"","text":"写在前面相信很多朋友初次接触到dcloud这边的产品，一般都是hbuilder和mui，所以很多朋友对于dcloud这边的产品链的认识也是各不相同。我相信对于很多新手来说，初次使用dcloud这边的产品的第一感觉一定是觉得这个东西很好却无从下手，然后被一些新的概念转得云里雾里，然后就开始吐槽官方文档，其实真的是文档不好吗？ 稍微有点基础的开发者可能仔细去看看官方文档，然后就可以自己跟着文档或者demo做点小例子，然而很多人由于是业务临时需要才转到跨平台app开发的，很多可以说零基础，即使有文档也不定会看得懂，或者看了更晕，相信这部分开发者最期待的是有人手把手教最好，我见过很多开发者一上来一言不合就要例子，如果你让他去看hello mui,hello h5+这两个最精华的例子，他也许会觉得你在逗他。 其实这是因为我们很多时候把精力搞分散了，没有把力量集中起来去逐个突破，所以导致看起来感觉到处是肉，啃起来到处是骨头。哈哈，说了这么多，你可能觉得是废话，你也可能觉得说到你心理去了，如果你对dcloud这边的产品还是有点不明不白，那希望你耐心看下面的分析，也请你等待我后续的基础教程。 资源索引先把几个常用的地址丢出来，因为你如果不想看我后面的，你直接去看这些也可以！ 新手值得收藏的地址 Dcloud官网：http://dcloud.io/ Dcloud问答社区：http://ask.dcloud.net.cn/ Dcloud文档汇总地址：http://ask.dcloud.net.cn/docs/ Hello mui线上演示地址：http://www.dcloud.io/hellomui/index.html Hello mui演示APP下载地址： Hello 5+演示APP下载地址： 官方入门文档(强烈推荐阅读): DCloud产品概述 App入门开发 mui产品 mui新手指南 案例汇总：http://dcloud.io/case/ github地址：https://github.com/dcloudio/ 开源项目地址：https://github.com/dcloudio/casecode mui-demo仓库: https://github.com/zhaomenghuan/mui-demo 官方分类文档 html5+官网文档：http://www.html5plus.org/doc/ mui文档：http://dev.dcloud.net.cn/mui/ui/ 5+ App开发Native.js入门指南：http://ask.dcloud.net.cn/article/88 Native.js示例汇总：http://ask.dcloud.net.cn/article/114 流应用开发指南：http://ask.dcloud.net.cn/article/406 其他学习资源 小青年博客 0Hich的网校视频 东翌学院视频 51CTO学院-张伟芝老师视频 猿团视频 E家课堂视频 网友YanRong的心得 滴石App开发者的心得 hCoder视频教程网——MUI前端框架开发教程 hCoder视频教程网——HTML5+开发教程 学习路线当我列出上面的这些网址，我发现其实文档并不算少，但是新手为啥感觉还是很难呢？我们会发现一个问题，官方文档很分散，或许分散了导致开发者每次遇到问题查找文档的范围可能或许片面，其实也许他把所有的看完了就会找到答案，但是一般人恐怕没那么耐心吧，还有新手根本就没有一个清晰的思路，所以很难快速去找到自己需要的文档，所以我想官方文档需要统一化具体化。 而且把这些大致浏览一下会发现内容真多，光html5+里面的标准就那么多，一个个去认真学习完到猴年马月去了，mui组件也那么多，难道也要一个个学习？还有native.js、流应用等等，感觉太多东西了，是不是瞬间觉得头大了，哈哈，人总是有点偷懒的，如果有人帮我们写好现成的我们直接用那就好了，于是dcloud这块想了很多办法让开发者去开心开发，hbuilder丰富的语法提示、代码快捷键、真机调试、演示demo等等，mui提供了丰富的组件，如果熟悉这些，开发起来还是很快的。 前提是熟悉了以后才会爽，如果不熟会感觉什么，学的东西太多，比如熟悉hbuilder都要一段时间，然后熟悉html5+，native.js，页面布局和写逻辑功能，对于新手来说，门坎儿并不小，这也是为啥很多新手喜欢吐槽的原因。因为当开发者熟悉了基本流程，会发现dcloud这边相对其他平台来说更开放，个人可定制空间更大，正因为越发开放，那么可以应用的场景更加广泛，自然开发者问题更多，这也希望有能力的开发者能够去完善整个开发生态链。 这里给各位的建议是先熟悉html5+的常用api，比如webview，你只有对html5+里面的webview有所了解，才能理解为什么mui里面会去封装一些原生实现的组件如双webview的上拉刷新，tabbar多子页面底部导航等。mui里面的这些组件通过对html5+ webview的封装，极大的提升了app的性能。由于用hbuilder打包的app默认包含html5+ rumtime，所以当你使用hbuilder构建app项目时候，无论你是否引用mui文件，无需引用任何其他文件，你都可以调用html5+ api和native.js。也就是说即使你不用mui，只用html5+提供的api，然后自己书写html，css，js文件就可以打包生成一个app。 当然考虑到大部分人时间精力有限，为了让开发者有较快的开发速度，官方提供了mui框架，mui框架拥有丰富的组件，可以极大的提高开发效率。根据hello mui演示app提供的demo，开发者可以快速构建一个自己的app。 mui是基于html5+构建的框架，所以对于mui中提供的原生组件，其适用环境是app中的原生组件webview，并不能在浏览器中运行，如果想用mui构建浏览器上的手机站点，只能使用mui中基于h5的组件。对于原生实现的组件，mui都有对应的h5实现，所以开发者可以做合理的处理，在书写较少代码的情况下，实现多端发布。 流应用是dcloud这边很有创新的一个产品，流应用基于HTML5+技术，可达到原生应用的体验。同时基于DCloud专利的流式发行和更新技术，可以大幅压缩安装包并实现边下边用。让App可5秒内完成下载、启动。目前拥有6亿手机用户的360手机助手已经集成了DCloud的流应用引擎，可以发行流应用。建议对dcloud的产品有个大致了解后再实践这块的内容。 所以我给新手的学习路线是hbuilder = &gt; html5+ = &gt; mui = &gt; 多端发布和流应用，当熟悉了这边的产品链以后开发起来会快很多，像hbuilder,html5+开始可以简单看看，了解基本的东西就可以。用mui的话至少得有基本的前端基础吧，再怎么样也得会基本的css布局和js基础吧，如果没有这些基础，先花点时间学一下基础或许更好。不要相信那种什么从零开始一周开发app的广告词，没有基础，也很难说做一个体验极好的app。 如果有原生开发经验的开发者一定会理解java在android中或者Objective-C在ios中的地位，做跨平台app开发，其实主要还是在于js功底，特别是原生js水平，所以如果js基础一般的开发者还是要不断加强学习，这里给的建议跟着hello mui里面的例子学，看官方人员是怎么写的，自己学着写，然后也可以在业余时间去研究一下基础。相信假以时日，你会发现你的js水平也会不断提高。 学习疑惑解答html5+是什么？html5+是DCloud提供的html5强化引擎，可以把HTML5 App打包为原生App，并且达到原生的功能和体验。说白了就是原本只能原生APP才能实现的功能，现在可以通过html5+这个强化引擎作为桥梁，你通过调用plus.*方法实现，也就是你可以通过书写js代码实现android和ios两套的原生功能。html5+封装了一些最常用的功能，并向W3C提交了作为标准的提案，具体的可以参考html5+规范API。 html5+和native.js有什么区别？html5+作为一种通用标准，只封装了最常用的一些API，如果你有其他需求但是5+里面没有怎么办，这个时候如果你懂原生应用开发，你可以基于native.js语法规范进行个性化封装。Native.js for Android封装一条通过JS语法直接调用Native Java接口通道，通过plus.android可调用几乎所有的系统API。Native.js for iOS封装一条通过JS语法直接调用Native Objective-C接口通道，通过plus.ios可调用几乎所有的系统API。 5+ sdk是什么？我们经常看到html5+(即html5plus)、5+ sdk,其实本质是一样的，不过这里的5+ sdk是针对离线打包开发和Hybrid开发模式，因为用hbuilder在线打包，html5+和native.js的底层会被自动打包到安装包里面，开发者无需引用什么即可调用相关API。只要当开发者想要离线打包及Hybrid开发模式或者深入了解html5+的引擎实现原理，才需要去了解一下5+ sdk，一般情况下我们只需要知道5+标准里面的基本用法就足够我们开发出一个APP。 mui与html5+有什么关系？mui是Dcloud官方推出的一个基于html5+标准的框架，同时拥有h5组件和原生组件，原生组件依赖于html5+运行环境，也就是原生app里面的webview组件（能加载显示网页，可以将其视为一个浏览器），所以mui里面的原生组件不能用于浏览器环境，可以通过mui里面的mui.os.plus进行判断，如果是plus环境会返回true，否则会返回undefined。开发者可以根据自己的需要进行代码适配，对于APP使用增强的原生组件，对于普通浏览器里面运行的页面使用h5组件。同时用户还可以使用mui.os.android、mui.os.ios及mui.os.wechat对平台进行检测，然后书写不同的逻辑代码。对于mui里面没有封装的原生组件，大家可以根据自己的需要基于html5+标准和native.js语法进行个性化定制。因此这里我们可以有一个基本影响就是我们开始可以直接上手mui，不过需要明白mui与其他UI框架的区别在于，mui拥有独有的原生组件，而且这个是依赖于html5+标准的，所以mui里面的很多组件实现方法甚至用户就是html5+里面的标准写法，对html5+标准有一定了解有助于我们理解mui的一些使用方法。 后记本文没有给出任何实际代码，只是根据很多朋友的一些疑惑谈了谈自己的看法，所以不一定很全面，大家可以参考官方文档去详细了解细节。从今天开始我会写一个mui的系列教程。在此承诺，每周至少会保证更新一篇文章。如果有朋友有与之相关的优秀学习资源可以给我推荐，联系邮箱：zhaomenghuan@foxmail.com 。 文章原始地址是我博客地址： http://zhaomenghuan.github.io 写文章不容易，也许写这些代码就几分钟的事，写一篇大家好接受的文章或许需要几天的酝酿，然后加上几天的码字，累并快乐着。如果文章对您有帮助请我喝杯咖啡吧！","categories":[{"name":"MUI从入门到精通","slug":"MUI从入门到精通","permalink":"https://zhaomenghuan.github.io/categories/MUI从入门到精通/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://zhaomenghuan.github.io/tags/mui/"},{"name":"html5plus","slug":"html5plus","permalink":"https://zhaomenghuan.github.io/tags/html5plus/"}]},{"title":"webpack入门详解","slug":"webpack入门详解","date":"2016-04-21T16:00:00.000Z","updated":"2017-05-03T16:16:38.651Z","comments":true,"path":"2016/04/22/webpack入门详解/","link":"","permalink":"https://zhaomenghuan.github.io/2016/04/22/webpack入门详解/","excerpt":"","text":"写在前面上一篇文章里面讲到前端模块化的基本概念，同时用webpack进行打包演示了一个基础的hello world实例，webpack的内容肯定不止那么多，在这篇文章里面我会详细介绍webpack的使用细节。同时，会结合vue.js完成一个更加实用的例子。如果你还没有看上一篇内容，建议你先阅读相关的内容，再看本篇文章效果会更好。 小伙伴戳这里 → 浅析前端模块化 webpack插件详解在讲解插件之前我们先说明一下接下来的实例的目录结构如下： 项目名/ ├── dist //打包之后最终部署到服务器上的文件（名称自定义） ├── src //资源文件（名称自定义） ├── node_modules //在打包过程中依赖的包 ├── package.json //包含各种所需模块以及项目的配置信息。 └── webpack.config.js //打包配置文件 package.json包含可配置项 name 名称 description 应用描述 version 版本号 config 应用的配置项 author 作者 respository 资源仓库地址 licenses 授权方式 directories 目录 main 应用入口文件 bin 命令行文件 dependencies 项目应用运行依赖模块 devDependencies 项目应用开发环境依赖 engines 运行引擎 script 脚本 这里沿用上一篇文章中的代码，不过要稍微修改一下，将下面的index.js和sub.js放在src文件夹下面。index.js:1234567//引用sub模块var sub = require('./sub');var app=document.createElement('div');app.innerHTML=\"hello world\";app.appendChild(sub());document.body.appendChild(app); sub.js:12345678//我们这里使用CommonJS的风格function getText()&#123; var element = document.createElement('h2'); element.innerHTML = \"Hello China\"; return element;&#125;module.exports = getText; html-webpack-plugin 这是一个webpack自动生成html文件的插件，在上一篇博客hello world那个例子中当我们合并合并了js，然后是手动的新建html文件并引用了生成的bundle.js文件，这里我们引用一个html-webpack-plugin插件，可以实现自动生成html模板文件。 执行下面的代码在命令行安装:1npm install html-webpack-plugin --save-dev 安装完这个插件,开始写webpack.config.js文件:1234567891011121314151617181920212223var path = require('path');var HtmlwebpackPlugin = require('html-webpack-plugin');//定义了一些文件夹的路径var ROOT_PATH = path.resolve(__dirname);var SRC_PATH = path.resolve(ROOT_PATH, 'src');var DIST_PATH = path.resolve(ROOT_PATH, 'dist');module.exports = &#123; //项目的文件夹 可以直接用文件夹名称 默认会找index.js 也可以确定是哪个文件名字 entry: SRC_PATH, //输出的文件名 合并以后的js会命名为bundle.js output: &#123; path: DIST_PATH, filename: 'bundle.js' &#125;, //添加我们的插件 会自动生成一个html文件 plugins: [ new HtmlwebpackPlugin(&#123; title: 'Hello World' &#125;) ]&#125;; 然后在项目根目录运行12345678&gt; **webpack-dev-server**上面任务虽然完成了，但是我们修改了要不断运行程序然后刷新页面，所以最好新建一个开发服务器，可以serve我们pack以后的代码，并且当代码更新的时候自动刷新浏览器。执行下面的代码在命令行安装:```jsnpm install webpack-dev-server --save-dev 安装完毕后,在webpack.config.js中添加配置:12345678910module.exports = &#123; .... devServer: &#123; historyApiFallback: true, hot: true, inline: true, progress: true, &#125;, ...&#125; 然后再package.json里面配置一下运行的命令,npm支持自定义一些命令12345...\"scripts\": &#123; \"start\": \"webpack-dev-server --hot --inline\"&#125;,... 好了，万事具备了，在项目根目录下输入npm start,一堆花花绿绿的信息后server已经起来了，在浏览器里面输入http://localhost:8080,发现伟大的hello world出现了，在js里面随便修改一些输出然后保存!这里我把sub.js里面的内容改为:1element.innerHTML = \"Hello China,I am zhaomenghuan\"; 浏览器自动刷新，新的结果出现了。 对比一下： 这个是直接打开的结果： 这个是webpack-dev-server下的结果： 这里我们可以看出来webpack-dev-server自动帮我们进行了内容的更新，这样避免了我们修改一下内容就要重新打包一下、刷新浏览器等一系列琐碎的事，我们只需要在最后部署的时候使用12345678&gt; **css-loader style-loader**现在来添加一些样式，webpack使用loader的方式来处理各种各样的资源，比如说样式文件，我们需要两种loader，css-loader 和 style－loader，css-loader会遍历css文件，找到所有的url(...)并且处理。style-loader会把所有的样式插入到你页面的一个style tag中。安装我们的loader:```jsnpm install css-loader style-loader --save-dev 在webpack.config.js中配置loader:12345678910... module: &#123; loaders: [ &#123; test: /\\.css$/, loaders: ['style', 'css'] &#125; ] &#125;,... 在新建一个样式文件 style.css123body&#123; background-color: #f00;&#125; 记得在入口文件index.js中引用1require('./style.css'); 然后发现页面背景颜色变成红色的了，webpack的理念是基于项目处理的，把对应的文件格式给对应的loader处理，然后你就不用管了，它会决定怎么压缩，编译。 那现在想使用一些有爱的css预编译程序，来点sass吧。你可能已经想到了，再来个loader就行啦，确实是这样简单。 不过特别注意：这里还需要添加node-sass来解析sass文件。1npm install sass-loader node-sass --save-dev 稍微修改一下webpack.config.js，删掉我们先前添加的css规则，加上下面的loader123456loaders: [ &#123; test: /\\.scss$/, loaders: ['style', 'css','sass'] &#125;] 添加两个sass文件，variables.scss和style.scss variables.scss:1$blue: blue; style.scss:12345import &quot;./variables.scss&quot;;body&#123; background-color: blue;&#125; 在index.js中引用:1require('./style.scss'); 然后会发现页面背景颜色变成了蓝色。 url-loader 上面的css-loader、style-loader、sass-loader主要是用于处理样式文件，这里url-loader用于处理图片文件的。 安装url-loader1npm install url-loader --save-dev 配置config文件1234&#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=40000'&#125; 注意后面那个limit的参数，当你图片大小小于这个限制的时候，会自动启用base64编码图片。 pic.js:12345678// 我们这里使用CommonJS的风格function getImg()&#123; var img = document.createElement(\"img\"); img.src = require(\"./demo.png\"); return img;&#125;module.exports = getImg; 在index.js里面添加如下内容：12var pic = require('./pic');app.appendChild(pic()); 如果不能显示，先使用start```启动服务器，在```http://localhost:8080/```查看效果，打开浏览器控制台然后查看图片的url，发现为base64编码图片。12345678![](http://i.imgur.com/ZyID5NW.png)&gt; babel-loader babel-preset-es2015如果你想通过项目熟悉一下ES6，那么你可以ES6的语法支持，但是考虑兼容性的问题，我们可以使用babel处理。### 安装loader ###```npmnpm install babel-loader babel-preset-es2015 --save-dev 配置我们的webpack.config.js文件123456789... &#123; test: /\\.jsx?$/, loader: 'babel', query: &#123; presets: ['es2015'] &#125; &#125;,... es2015这个参数是babel的plugin，可以支持各种最新的es6的特性,现在我们可以改掉CommonJS风格的文件了。 sub.js:123456//我们这里使用CommonJS的风格export default function()&#123; var element = document.createElement('h2'); element.innerHTML = \"Hello China,I am Chinese\"; return element;&#125; index.js:1import sub from './sub'; 通过import语句引入后加载模块时，可以为模块匿名函数指定任意名字。 参考文章 Webpack傻瓜式指南（一） ECMAScript 6 入门 纯扯淡最近在准备暑期实习生的面试，感慨万千，感觉真的越来越渴望进入前端这个行业成为一个真正的前端工程师，也希望各位朋友可以坚持自己的爱好，不要放弃，勇敢去追求，我相信我们都会成实现的。也真正体会到其实之前很多担忧是多余的，如果真的有技术，不用太在乎是不是计算机专业，因为一个人的天赋和潜力和所处的环境不一定是完全相关的，潜下心去钻研或许更好。","categories":[{"name":"node学习之路","slug":"node学习之路","permalink":"https://zhaomenghuan.github.io/categories/node学习之路/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://zhaomenghuan.github.io/tags/webpack/"}]},{"title":"浅析前端模块化","slug":"浅析前端模块化","date":"2016-04-14T16:00:00.000Z","updated":"2017-05-03T16:17:56.877Z","comments":true,"path":"2016/04/15/浅析前端模块化/","link":"","permalink":"https://zhaomenghuan.github.io/2016/04/15/浅析前端模块化/","excerpt":"","text":"写在前面近来学习了git，github，确实体验了一下开发效率这个问题，比如几条常用命令就可以把代码下载上传到github上，可以很快的去测试一下效果。去年就听说过前端模块化这个概念，但是一直没有深入去了解，所以准备继续学习一下相关的技术。虽然现在前端各种口水战，说什么前端目前浮躁，其实个人觉得不然，是因为人容易站在自己的立场去看问题，不管什么框架终究要适用于业务需求需要，各自有自己的适用环境，无从说哪种更好，自己觉得合适就好。 聊聊前端模块化由于我之前学过java和android app开发，也略知java这种语言的包管理，一方面可以解决命名冲突，一方面可以实现代码模块的复用，在开发过程中还是有一定好处的，代码结构和层次很清晰，容易管理。不过话又说回来，包名臭长臭长的好难记啊，基本写代码靠copy。/(ㄒoㄒ)/~~ 曾经尝试直接撸个小UI库eui(写出来用了一段时间bug太多，停了。。。），尝试了用jQuery风格的匿名自执行函数去包装库。期间也看了看很多js设计模式的帖子，看了看很多框架的实现方法。后来了解到vue.，react，angular这种mvvm框架，说什么鬼的模块化，最后选择试试了vue，用vue也写了一下，发现确实是挺优雅的一个框架，真的是感觉有可取之处，值得去学习。开始我都是把所有的组件写在一个xxx.js和xxx.css里面，但是内容多了，感觉有点烦，看官网上提到的单文件.vue，感觉确实是合理一些。那好吧，那就硬着头皮去入坑模块化，这里贴出知乎上的一篇帖子，仅供参考，后面等我有了自己的体会自己写一篇。 前端组件化和模块化的区别[1]模块化中的模块一般指的是 Javascript 模块，比如一个用来格式化时间的模块。组件则包含了 template、style 和 script，而它的 Script 可以由各种模块组成。比如一个显示时间的组件会调用上面的那个格式化时间的模块。 在这里直接引用一篇黄玄写的JavaScript 模块化七日谈[2]。 第一日 上古时期 Module? 从设计模式说起 第二日 石器时代 Script Loader 只有封装性可不够，我们还需要加载 第三日 蒸汽朋克 Module Loader 模块化架构的工业革命 第四日 号角吹响 CommonJS 征服世界的第一步是跳出浏览器 第五日 双塔奇兵 AMD/CMD 浏览器环境模块化方案 第六日 精灵宝钻 Browserify/Webpack 大势所趋，去掉这层包裹！ 第七日 王者归来 ES6 Module 最后的战役 webpack是什么鬼？看完大多数介绍前端模块化的文章你基本都会听到AMD，CommonJS，RequireJS等一些列很专业的名词，但是很多时候搞不清他们之间的关系，这里我们先简单分类： Javascript模块化标准：CommonJS，AMD，CMD，ES6 Modules这里简单说说就是定义一般的语法规范，注意与工具的区别。 最常见的模块加载器： browserify/webpack，基于CommonJS标准 RequireJS，基于AMD标准 SeaJS，基于CMD标准 这里不详细去讲解每一种的特点以及他们之间的差异，这里我们我们会使用webpack，所以下面只会详细介绍CommonJS标准和webpack的基本用法。 Webpack 是德国开发者 Tobias Koppers 开发的模块加载器,Instagram 工程师认为这个方案很棒, 似乎还把作者招过去了。在 Webpack 当中, 所有的资源都被当作是模块, js, css, 图片等等..因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl。 对应各种不同文件类型的资源, Webpack 有对应的模块 loader。比如 vue.js 用的是 vue-loader, 其他还有很多: http://webpack.github.io/docs/list-of-loaders.html 官网对webpack的定义是MODULE BUNDLER，他的目的就是把有依赖关系的各种文件打包成一系列的静态资源。 请看下图： webpack 入门webpack基于node的模块加载器，所以这里你要安装node.js的运行环境。（不过这里要特别说明的是经过webpack打包的前端静态代码是不用依赖与node.js环境的，直接放在服务器上可以打开，因为一开始这个我被有些人误导了一直没搞清楚）。使用webpack开发的时候不可避免的要使用一些模块包，所以这里要使用npm（Node Packaged Modules）。 npm是nodejs官方为nodejs定制的一个工具，是Node.js的包管理器，是Node Packaged Modules的简称，通过npm可以下载安装nodejs的模块包，nodejs有很多优秀的模块包可以让开发这快速开发。 安装方法： windows 下安装nodejs npm安装图文教程 如何在windows下安装GIT(建议安装git，当然这个随你) 安装好了之后，在命令行输入下面的命令查看当前安装版本。12node -vnpm -v 我安装的版本是: v5.10.1 , npm : 3.8.3```，若是版本问题，请更新到最新版。12345678910111213141516首先我们直接进行全局的安装，运行如下命令：```npm install webpack -g```，可能需要一点时间。安装成功后，在命令行输入```webpack -h```即可查看当前安装的版本信息。以及可以使用的指令。**hello world：**新建项目文件夹，然后命令行进入项目目录```js# 创建package.json，直接一路回车就好npm init# 安装 webpack 依赖npm install webpack --save-dev# 简单的写法：-_-,缩写形式npm i webpack -D# –save：模块名将被添加到dependencies，可以简化为参数-S。# –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。 经过上面的几步后你会发现项目目录下生成了一个package.json文件和node_modules文件夹。 package.json: 123456789101112131415&#123; \"name\": \"vue-webpack\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"dependencies\": &#123;&#125;, \"devDependencies\": &#123; \"webpack\": \"^1.12.15\" &#125;, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 既然环境都已经安装好了，那么我们就开始来用webpack进行我们的第一个打包运行程序吧！ 首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js,（这里你想用什么名字都可以，只需要在打包的时候读取文件为该名字就好，不过，到时候就知道这个名字的含义啦！）： index.html: 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"app\"&gt;&lt;/h1&gt; &lt;!-- 注意这里引入的不是我们创建的文件，而是用webpack生成的文件 --&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; entry.js: 1document.getElementById('app').innerHTML=\"hello world\"; 文件都已经创建成功了，那么就开始我们的打包吧！在命令行输入命令：1webpack entry.js bundle.js 运行成功会出现：123456Hash: 29cef45390255691137eVersion: webpack 1.12.15Time: 218ms Asset Size Chunks Chunk Namesbundle.js 1.45 kB 0 [emitted] main [0] ./entry.js 57 bytes &#123;0&#125; [built] 目录下会生成一个bundle.js文件，在浏览器中打开index.html，就能看到我们设置的文字啦！：hello world 这么简单的功能直接在html中引入不就好了吗？确实是这样的，不过我们这才刚刚开始嘛，不要急。 这里我们新建一个sub.js文件作为一个新的模块。sub.js: 12345678//我们这里使用CommonJS的风格function getText()&#123; var element = document.createElement('h2'); element.innerHTML = \"Hello China\"; return element;&#125;module.exports = getText; 修改entry.js文件如下：entry.js: 123456//引用sub模块var sub = require('./sub');var app=document.getElementById('app');app.innerHTML=\"hello world\";app.appendChild(sub()); 再来进行一次重复的工作，再打包一次。webpack entry.js bundle.js，如果成功，打包过程会显示日志：1234567Hash: af3c33f78683d1f00e10Version: webpack 1.12.15Time: 178ms Asset Size Chunks Chunk Namesbundle.js 1.8 kB 0 [emitted] main [0] ./entry.js 138 bytes &#123;0&#125; [built] [1] ./sub.js 178 bytes &#123;0&#125; [built] Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。 我们每次都需要输入入口文件entry.js和输出文件bundle.js，是不是很麻烦？这里我们简单设置一下webpack.config.js: entry 入口文件 让webpack用哪个文件作为项目的入口 output 出口 让webpack把处理完成的文件放在哪里 module 模块 要用什么不同的模块来处理各种类型的文件 12345678var Webpack = require(\"webpack\");module.exports = &#123; entry: [\"./entry.js\"], output: &#123; path: __dirname, filename: \"bundle.js\" &#125;&#125; 然后在项目根目录运行webpack，如果你的配置没有问题的话，可以在命令行中看到正确的输出，因为这个命令会自动在当前目录中查找webpack.config.js的配置文件，并按照里面定义的规则来进行执行。 这个hello world介绍了webpack的最简单的内容，还没有涉及到添加CSS样式，添加图片，由于本文作为前端模块化系列文章第一篇，先不做过多介绍，后面会补充更多内容。 参考文档：（商业转载请联系作者获得授权，非商业转载请注明出处。） [1] Jasin Yip http://www.zhihu.com/question/37649318 来源知乎 [2] 黄玄 http://www.zhihu.com/question/37011441/answer/71639106 来源知乎 [3] Webpack傻瓜式指南 https://github.com/vikingmute/webpack-for-fools/blob/master/entries/chapter-1.md","categories":[{"name":"JavaScript进阶学习","slug":"JavaScript进阶学习","permalink":"https://zhaomenghuan.github.io/categories/JavaScript进阶学习/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://zhaomenghuan.github.io/tags/webpack/"},{"name":"前端模块化","slug":"前端模块化","permalink":"https://zhaomenghuan.github.io/tags/前端模块化/"}]},{"title":"走近github王国，git入门教程","slug":"走近github王国，git入门教程","date":"2016-03-31T16:00:00.000Z","updated":"2017-05-03T16:18:57.151Z","comments":true,"path":"2016/04/01/走近github王国，git入门教程/","link":"","permalink":"https://zhaomenghuan.github.io/2016/04/01/走近github王国，git入门教程/","excerpt":"","text":"写在前面一个稳定简单，空间大，关注度高的博客分享平台是提高博客浏览量的必要条件，当然内容充实才是关键，废话不多说，今天我们就来搞定git和github，相信程序猿们都懂。 简介GIT Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 官网：https://git-scm.com/ Git教程:廖雪峰的官方网站 github 作为开源代码库以及版本控制系统，Github拥有140多万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。GitHub可以托管各种git库，并提供一个web界面，但与其它像 SourceForge或Google Code这样的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 官网：https://github.com/ 准备环节Git 安装配置 在使用Git前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 各平台安装包下载地址为：http://git-scm.com/downloads。 安装教程：https://git-scm.com/book/zh/v2/起步-安装-Git 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings\\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 用户信息配置个人的用户名称和电子邮件地址：12git config --global user.name \"zhaomenghuan\"git config --global user.email 1028317108@qq.com 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 查看配置信息要检查已有的配置信息，可以使用 $ git config –list 命令：1234567891011121314core.symlinks=falsecore.autocrlf=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlhttp.sslcainfo=f:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crtdiff.astextplain.textconv=astextplainrebase.autosquash=truecredential.helper=manageruser.name=zhaomenghuanuser.email=1028317108@qq.comgui.recentrepo=E:/coding/zhaomenghuan/github 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：1git config user.name Git工作流程详解Git一般工作流程 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 Git 工作区、暂存区和版本库我们先来理解下Git 工作区、暂存区和版本库概念 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 add```命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。12345678910111213141516- 当执行提交操作 ```git commit``` 时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。- 当执行 ```git reset HEAD``` 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。- 当执行 ```git rm --cached &lt;file&gt;``` 命令时，会直接从暂存区删除文件，工作区则不做出改变。- 当执行 ```git checkout .``` 或者 ```git checkout -- &lt;file&gt;``` 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。- 当执行 ```git checkout HEAD .``` 或者 ```git checkout HEAD &lt;file&gt;``` 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。## 常用命令说明&gt; **git init （初始化仓库）**git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。进入目标目录，右键单击选择Git Bash Here然后就可以输入命令。使用当前目录作为Git仓库，我们只需使它初始化。```jsgit init 该命令执行完后会在当期目录生成一个 .git 目录。 使用我们指定目录作为Git仓库。1git init folderPath folderPath为目录地址，初始化后，会在 folderPath 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后使用 git commit命令提交。 Git提交文件到版本库有两步： 第一步：使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 下面将详细介绍这两条命令： git add（添加工作区文件到暂存区） 比如在当前目录下新建README.md文件，然后输入下列命令：1git add README.md 注：添加当前目录下的所有文件和子目录为： 1git add . git commit（将暂存区内容提交到当前版本库） 1$ git commit -m \"README.md提交成功\" 结果显示：123[master (root-commit) f174e25] README.md提交成功 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md 当多个文件被修改时使用这个命令提交：1git commit -a -m &lt;file&gt;; 说明：-a, –all commit all changed files(提交所有被修改的文件)123$ git commit -a -m .[master f155b28] .5 files changed, 14 insertions(+), 8 deletions(-) git rm （移除当前版本库文件） 12$ git rm README.mdrm 'README.md' 执行完这句会发现README.md文件在工作区消失了，但是这个时候在版本库是否还存在呢？ git status（查看当前仓库状态） git status 以查看在你上次提交之后是否有修改,可以让我们时刻掌握仓库的状态，此时我们输入git status命令会得到下面的结果：123456$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) deleted: README.md 此时显示了 README.md 文件被删除但还没有被提交，与 git add 命令一样，git rm 只有经过git commit 命令之后才会真正在版本库被删除。 git diff 执行 git diff 来查看执行 git status 的结果的详细信息。git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git clone (克隆其他仓库) 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令： 1$ git clone [url] [url] 为你想要复制的项目地址。默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。 版本管理1.查看远程分支1git branch -a 2.查看本地分支1git branch 3.创建分支 git branch 4.切换分支到test1git checkout test 5.删除本地分支1git branch -d xxxxx 6.快速切换到master分支1git checkout master 当然上面这条命令是常规的，我们的快速切换回去的命令才是重点，可用它代替上面git checkout &lt;分支名&gt;的命令。 我们上面讲解了如何把当前工作区文件添加并提交到本地版本仓库，这里并没有讲解如何修改和撤销文件，版本比较之类的命令，因为考虑到作为入门级别教程不要求过于详细，所以更多的git命令会在后面深入探讨。 如何添加远程库？由于网上关于如何新建github仓库或博客的教程很多，我这里暂时不做赘述，直接引用几篇文章，后期如果有空再做补充。 使用GitHub Pages搭建博客 使用SSH密钥连接Github 设置NPM淘宝代理镜像1npm config set registry https://registry.npm.taobao.org git push 12$ git remote add origin 仓库地址$ git push -u origin master 仓库地址为你在github上面建的仓库的地址。 错误处理1error: failed to push some refs 当github上被改变了，有时候会发现直接使用git push -u origin master会出错，这个时候先使用git pull –rebase origin master更新就会解决。1fatal: Unable to create &apos;E:/coding/pop/.git/index.lock&apos;: File exists. 执行下面的可以解决：1rm -f ./.git/index.lock","categories":[{"name":"node学习之路","slug":"node学习之路","permalink":"https://zhaomenghuan.github.io/categories/node学习之路/"}],"tags":[{"name":"git","slug":"git","permalink":"https://zhaomenghuan.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://zhaomenghuan.github.io/tags/github/"}]},{"title":"基于JavaScript的桌面应用入门","slug":"基于JavaScript的桌面应用入门","date":"2016-03-27T16:00:00.000Z","updated":"2017-05-07T12:40:03.284Z","comments":true,"path":"2016/03/28/基于JavaScript的桌面应用入门/","link":"","permalink":"https://zhaomenghuan.github.io/2016/03/28/基于JavaScript的桌面应用入门/","excerpt":"","text":"写在前面为了让自己的博客体验更好，也方便自己平时发布，打算从零开始打造一个自己的博客文章发布平台。当然在这个过程中肯定会用到一些很优秀的第三方插件，这样一方面可以减少自己的工作量，一方面可以学习一下其他优秀的工具。 简介electron————使用web技术构建跨平台桌面应用程序Electron是一个原本为 Atom 编辑器设计的，跨平台的应用外壳（Application Shell），它将 Chromium 和 Node.js 的事件循环整合到了一起，同时提供了一些与原生系统交互的 API。 一个开源的跨平台的桌面应用构建框架，与node-webkit（简称nw.js）类似，具体对比可以参见知乎上的一个讨论——用Nodejs开发桌面应用。NW.js 和 Electron 各有什么优缺点，你选择哪个？。由于我自己对web相对熟悉一下，所以选择这张基于web的方式构建桌面平台应用，进行对比后我选择了electron。 英文官网：http://electron.atom.io/ github地址: https://github.com/atom/electron 中文文档：docs-translations/zh-CN markdown————一种最流行的博客书写语法markdown拥有简单的语法和众多开源的插件和使用者，markdown写博客无疑是一种不错的选择，同时可以让博客整体风格统一，而且让大家更加熟悉和适应。 使用语法： markdown简明语法 献给写作者的 Markdown 新手指南 Markdown 语法说明 (简体中文版) Vue.js————数据驱动的组件，为现代化的 Web 界面而生 中文官网 http://cn.vuejs.org/ Markdown 编辑器 Example：http://cn.vuejs.org/examples/ 本例子中用到了一个非常强大的markdown语法解析器marked.js。 marked.js————一个高效的markdown语法解析器 github地址: https://github.com/chjj/marked 项目实战1.又见hello word！下载electron，https://github.com/atom/electron/releases/ electron是绿色软件，下载下打开electron.exe即可使用。 如果打开后看到这个界面说明下载运行成功。 你可以下载electron-quick-start查看演示工程或者看下载electron时根目录下的的resources下的default_app工程。这里我们选择自己写一个工程，下面书写helloworld： Electron 应用的目录结构如下： app/ ├── package.json ├── main.js └── index.html 新建一个app文件夹 将这三个文件都放在里面，package.json 的格式和 Node 模块中的完全一致。你应用的启动脚本（的路径）需要在 app/package.json 中的main属性中指定。package.json的内容:12345&#123; \"name\": \"Hello WorLd\", \"version\" : \"0.1.0\", \"main\": \"main.js\"&#125; app/main.js是我们应用的入口。它负责创建主窗口和处理系统事件。 main.js 应该如下所示：1234567891011121314151617181920212223242526272829'use strict';//应用的控制模块const electron = require('electron');const app = electron.app;//创建原生浏览器窗口的模块const BrowserWindow = electron.BrowserWindow;let mainWindow;//初始化并准备创建浏览器窗口app.on('ready', function()&#123; //创建浏览器窗口 mainWindow = new BrowserWindow(&#123;width: 800, height: 600&#125;); //载入布局文件 mainWindow.loadURL('file://' + __dirname + '/index.html'); //打开开发调试工具 //mainWindow.webContents.openDevTools(); //窗口关闭时触发 mainWindow.on('closed', function() &#123; mainWindow = null; &#125;);&#125;);//当所有窗口都关闭的时候退出应用app.on('window-all-closed', function () &#123; if (process.platform !== 'darwin') &#123; app.quit(); &#125;&#125;); app/index.html是一个简单的 HTML 页面：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;style&gt; body &#123; color: #45828E; background-color: #A5ECFA; font-family: 'Helvetica Neue', 'Open Sans', Helvetica, Arial, sans-serif; padding: 0; margin: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 最终演示效果： 2.使用vue.js+marked.js实现markdown编辑器应用的目录结构如下： app/ ├── package.json ├── main.js ├── index.html └── app/ ├── css/├ markdown.css├ app.css ├── js/├ vue.js└ marked.min.js index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"app/css/markdown.css\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"app/css/app.css\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"editor\"&gt; &lt;textarea v-model=\"editorInput\" debounce=\"300\"&gt;&lt;/textarea&gt; &lt;div v-html=\"editorInput | marked\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"app/lib/js/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"app/lib/js/marked.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; /* eslint-disable */ // 初始化 new Vue(&#123; el: '#editor', data: &#123; editorInput: '# hello' &#125;, filters: &#123; marked: marked &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.css123456789101112131415161718192021222324252627html, body, #editor &#123; margin: 0; height: 100%; font-family: 'Helvetica Neue', Arial, sans-serif;&#125;textarea, #editor div &#123; display: inline-block; width: 49%; height: 100%; vertical-align: top; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; padding: 0 20px;&#125;textarea&#123; border: none; border-right: 1px solid #ccc; resize: none; outline: none; background-color: #f6f6f6; font-size: 20px; font-family: 'Monaco', courier, monospace; padding: 20px;&#125; 效果图：","categories":[{"name":"node学习之路","slug":"node学习之路","permalink":"https://zhaomenghuan.github.io/categories/node学习之路/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://zhaomenghuan.github.io/tags/vue-js/"},{"name":"electron","slug":"electron","permalink":"https://zhaomenghuan.github.io/tags/electron/"},{"name":"markdown","slug":"markdown","permalink":"https://zhaomenghuan.github.io/tags/markdown/"}]}]}